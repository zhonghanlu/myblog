<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Shell （尚硅谷转载）</title>
      <link href="/archives/15c82059.html"/>
      <url>/archives/15c82059.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第1章-Shell概述"><a href="#第1章-Shell概述" class="headerlink" title="第1章 Shell概述"></a>第1章 Shell概述</h1><p>大数据程序员为什么要学习Shell呢？</p><p>1）需要看懂运维人员编写的Shell程序。</p><p>2）偶尔会编写一些简单Shell程序来管理集群、提高开发效率。</p><h1 id="第2章-Shell解析器"><a href="#第2章-Shell解析器" class="headerlink" title="第2章 Shell解析器"></a>第2章 Shell解析器</h1><p>（1）Linux提供的Shell解析器有：</p><blockquote><p>[atguigu@hadoop101 ~]$ cat &#x2F;etc&#x2F;shells</p><p>&#x2F;bin&#x2F;sh</p><p>&#x2F;bin&#x2F;bash</p><p>&#x2F;sbin&#x2F;nologin</p><p>&#x2F;bin&#x2F;dash</p><p>&#x2F;bin&#x2F;tcsh</p><p>&#x2F;bin&#x2F;csh</p></blockquote><p>（2）bash和sh的关系</p><blockquote><p>[atguigu@hadoop101 bin]$ ll | grep bash</p><p>-rwxr-xr-x. 1 root root 941880 5月 11 2016 bash</p><p>lrwxrwxrwx. 1 root root 4 5月 27 2017 sh -&gt; bash</p></blockquote><p>（3）Centos默认的解析器是bash</p><blockquote><p>[atguigu@hadoop102 bin]$ echo $SHELL</p><p>&#x2F;bin&#x2F;bash</p></blockquote><h1 id="第3章-Shell脚本入门"><a href="#第3章-Shell脚本入门" class="headerlink" title="第3章 Shell脚本入门"></a>第3章 Shell脚本入门</h1><p>1．脚本格式</p><p>脚本以#!&#x2F;bin&#x2F;bash开头（指定解析器）</p><p>2．第一个Shell脚本：helloworld</p><p>（1）需求：创建一个Shell脚本，输出helloworld</p><p>（2）案例实操：</p><blockquote><p>[atguigu@hadoop101 datas]$ touch helloworld.sh</p><p>[atguigu@hadoop101 datas]$ vi helloworld.sh</p><p>在helloworld.sh中输入如下内容</p><p>#!&#x2F;bin&#x2F;bash</p><p>echo &quot;helloworld&quot;</p></blockquote><p>（3）脚本的常用执行方式</p><p>第一种：采用bash或sh+脚本的相对路径或绝对路径（不用赋予脚本+x权限）</p><p>sh+脚本的相对路径</p><blockquote><p>[atguigu@hadoop101 datas]$ sh helloworld.sh</p><p>Helloworld</p></blockquote><p>sh+脚本的绝对路径</p><blockquote><p>[atguigu@hadoop101 datas]$ sh &#x2F;home&#x2F;atguigu&#x2F;datas&#x2F;helloworld.sh</p><p>helloworld</p></blockquote><p>bash+脚本的相对路径</p><blockquote><p>[atguigu@hadoop101 datas]$ bash helloworld.sh</p><p>Helloworld</p></blockquote><p>bash+脚本的绝对路径</p><blockquote><p>[atguigu@hadoop101 datas]$ bash &#x2F;home&#x2F;atguigu&#x2F;datas&#x2F;helloworld.sh</p><p>Helloworld</p><p>第二种：采用输入脚本的绝对路径或相对路径执行脚本（必须具有可执行权限+x）</p></blockquote><p>（a）首先要赋予helloworld.sh 脚本的+x权限</p><blockquote><p>[atguigu@hadoop101 datas]$ chmod 777 helloworld.sh</p></blockquote><p>（b）执行脚本</p><blockquote><p>相对路径</p><p>[atguigu@hadoop101 datas]$ .&#x2F;helloworld.sh</p><p>Helloworld</p><p>绝对路径</p><p>[atguigu@hadoop101 datas]$ &#x2F;home&#x2F;atguigu&#x2F;datas&#x2F;helloworld.sh</p><p>Helloworld</p></blockquote><p>注意：第一种执行方法，本质是bash解析器帮你执行脚本，所以脚本本身不需要执行权限。第二种执行方法，本质是脚本需要自己执行，所以需要执行权限。</p><p>3．第二个Shell脚本：多命令处理</p><p>（1）需求：</p><blockquote><p>在&#x2F;home&#x2F;atguigu&#x2F;目录下创建一个banzhang.txt,在banzhang.txt文件中增加”I<br>love cls”。</p></blockquote><p>（2）案例实操：</p><blockquote><p>[atguigu@hadoop101 datas]$ touch batch.sh</p><p>[atguigu@hadoop101 datas]$ vi batch.sh</p><p>在batch.sh中输入如下内容</p><p>#!&#x2F;bin&#x2F;bash</p><p>cd &#x2F;home&#x2F;atguigu</p><p>touch cls.txt</p><p>echo &quot;I love cls&quot; &gt;&gt;cls.txt</p></blockquote><h1 id="第4章-Shell中的变量"><a href="#第4章-Shell中的变量" class="headerlink" title="第4章 Shell中的变量"></a>第4章 Shell中的变量</h1><h2 id="4-1-系统变量"><a href="#4-1-系统变量" class="headerlink" title="4.1 系统变量"></a>4.1 系统变量</h2><p>1. 常用系统变量</p><p>$HOME、$PWD、$SHELL、$USER等</p><p>2．案例实操</p><p>（1）查看系统变量的值</p><blockquote><p>[atguigu@hadoop101 datas]$ echo $HOME</p><p>&#x2F;home&#x2F;atguigu</p></blockquote><p>（2）显示当前Shell中所有变量：set</p><blockquote><p>[atguigu@hadoop101 datas]$ set</p><p>BASH&#x3D;&#x2F;bin&#x2F;bash</p><p>BASH_ALIASES&#x3D;()</p><p>BASH_ARGC&#x3D;()</p><p>BASH_ARGV&#x3D;()</p></blockquote><h2 id="4-2-自定义变量"><a href="#4-2-自定义变量" class="headerlink" title="4.2 自定义变量"></a>4.2 自定义变量</h2><p>1．基本语法</p><p>（1）定义变量：变量&#x3D;值</p><p>（2）撤销变量：unset 变量</p><p>（3）声明静态变量：readonly变量，注意：不能unset</p><p>2．变量定义规则</p><p>（1）变量名称可以由字母、数字和下划线组成，但是不能以数字开头，环境变量名建议大写。</p><p>（2）等号两侧不能有空格</p><p>（3）在bash中，变量默认类型都是字符串类型，无法直接进行数值运算。</p><p>（4）变量的值如果有空格，需要使用双引号或单引号括起来。</p><p>3．案例实操</p><p>（1）定义变量A</p><blockquote><p>[atguigu@hadoop101 datas]$ A&#x3D;5</p><p>[atguigu@hadoop101 datas]$ echo $A</p><p>5</p></blockquote><p>（2）给变量A重新赋值</p><blockquote><p>[atguigu@hadoop101 datas]$ A&#x3D;8</p><p>[atguigu@hadoop101 datas]$ echo $A</p><p>8</p></blockquote><p>（3）撤销变量A</p><blockquote><p>[atguigu@hadoop101 datas]$ unset A</p><p>[atguigu@hadoop101 datas]$ echo $A</p></blockquote><p>（4）声明静态的变量B&#x3D;2，不能unset</p><blockquote><p>[atguigu@hadoop101 datas]$ readonly B&#x3D;2</p><p>[atguigu@hadoop101 datas]$ echo $B</p><p>2</p><p>[atguigu@hadoop101 datas]$ B&#x3D;9</p><p>-bash: B: readonly variable</p></blockquote><p>（5）在bash中，变量默认类型都是字符串类型，无法直接进行数值运算</p><blockquote><p>[atguigu@hadoop102 ~]$ C&#x3D;1+2</p><p>[atguigu@hadoop102 ~]$ echo $C</p><p>1+2</p></blockquote><p>（6）变量的值如果有空格，需要使用双引号或单引号括起来</p><blockquote><p>[atguigu@hadoop102 ~]$ D&#x3D;I love banzhang</p><p>-bash: world: command not found</p><p>[atguigu@hadoop102 ~]$ D&#x3D;&quot;I love banzhang&quot;</p><p>[atguigu@hadoop102 ~]$ echo $A</p><p>I love banzhang</p></blockquote><p>（7）可把变量提升为全局环境变量，可供其他Shell程序使用</p><blockquote><p>export 变量名</p><p>[atguigu@hadoop101 datas]$ vim helloworld.sh</p><p>在helloworld.sh文件中增加echo $B</p><p>#!&#x2F;bin&#x2F;bash</p><p>echo &quot;helloworld&quot;</p><p>echo $B</p><p>[atguigu@hadoop101 datas]$ .&#x2F;helloworld.sh</p><p>Helloworld</p><p>发现并没有打印输出变量B的值。</p><p>[atguigu@hadoop101 datas]$ export B</p><p>[atguigu@hadoop101 datas]$ .&#x2F;helloworld.sh</p><p>helloworld</p><p>2</p></blockquote><h2 id="4-3-特殊变量：-n"><a href="#4-3-特殊变量：-n" class="headerlink" title="4.3 特殊变量：$n"></a>4.3 特殊变量：$n</h2><p>1．基本语法</p><p>$n<br>（功能描述：n为数字，$0代表该脚本名称，$1-$9代表第一到第九个参数，十以上的参数，十以上的参数需要用大括号包含，如${10}）</p><p>2．案例实操</p><p>（1）输出该脚本文件名称、输入参数1和输入参数2 的值</p><blockquote><p>[atguigu@hadoop101 datas]$ touch parameter.sh</p><p>[atguigu@hadoop101 datas]$ vim parameter.sh</p><p>#!&#x2F;bin&#x2F;bash</p><p>echo &quot;$0 $1 $2&quot;</p><p>[atguigu@hadoop101 datas]$ chmod 777 parameter.sh</p><p>[atguigu@hadoop101 datas]$ .&#x2F;parameter.sh cls xz</p><p>.&#x2F;parameter.sh cls xz</p></blockquote><h2 id="4-4-特殊变量："><a href="#4-4-特殊变量：" class="headerlink" title="4.4 特殊变量：$#"></a>4.4 特殊变量：$#</h2><p>1．基本语法</p><p>$# （功能描述：获取所有输入参数个数，常用于循环）。</p><p>2．案例实操</p><p>（1）获取输入参数的个数</p><blockquote><p>[atguigu@hadoop101 datas]$ vim parameter.sh</p><p>#!&#x2F;bin&#x2F;bash</p><p>echo &quot;$0 $1 $2&quot;</p><p>echo $#</p><p>[atguigu@hadoop101 datas]$ chmod 777 parameter.sh</p><p>[atguigu@hadoop101 datas]$ .&#x2F;parameter.sh cls xz</p><p>parameter.sh cls xz</p><p>2</p></blockquote><h2 id="4-5-特殊变量：-、"><a href="#4-5-特殊变量：-、" class="headerlink" title="4.5 特殊变量：$*、$@"></a>4.5 特殊变量：$*、$@</h2><p>1．基本语法</p><p>$*<br>（功能描述：这个变量代表命令行中所有的参数，$*把所有的参数看成一个整体）</p><p>$@<br>（功能描述：这个变量也代表命令行中所有的参数，不过$@把每个参数区分对待）</p><p>2．案例实操</p><p>（1）打印输入的所有参数</p><blockquote><p>[atguigu@hadoop101 datas]$ vim parameter.sh</p><p>#!&#x2F;bin&#x2F;bash</p><p>echo &quot;$0 $1 $2&quot;</p><p>echo $#</p><p>echo $*</p><p>echo $@</p><p>[atguigu@hadoop101 datas]$ bash parameter.sh 1 2 3</p><p>parameter.sh 1 2</p><p>3</p><p>1 2 3</p><p>1 2 3</p></blockquote><h2 id="4-6-特殊变量：-？"><a href="#4-6-特殊变量：-？" class="headerlink" title="4.6 特殊变量：$？"></a>4.6 特殊变量：$？</h2><p>1．基本语法</p><p>$？<br>（功能描述：最后一次执行的命令的返回状态。如果这个变量的值为0，证明上一个命令正确执行；如果这个变量的值为非0（具体是哪个数，由命令自己来决定），则证明上一个命令执行不正确了。）</p><p>2．案例实操</p><p>（1）判断helloworld.sh脚本是否正确执行</p><blockquote><p>[atguigu@hadoop101 datas]$ .&#x2F;helloworld.sh</p><p>hello world</p><p>[atguigu@hadoop101 datas]$ echo $?</p><p>0</p></blockquote><h1 id="第5章-运算符"><a href="#第5章-运算符" class="headerlink" title="第5章 运算符"></a>第5章 运算符</h1><p>1．基本语法</p><p>（1）”$((运算式))”或”$[运算式]“</p><p>（2）expr + , - , \*, &#x2F;, % 加，减，乘，除，取余</p><blockquote><p>注意：expr运算符间要有空格</p></blockquote><p>2．案例实操：</p><p>（1）计算3+2的值</p><blockquote><p>[atguigu@hadoop101 datas]$ expr 2 + 3</p><p>5</p></blockquote><p>（2）计算3-2的值</p><blockquote><p>[atguigu@hadoop101 datas]$ expr 3 - 2</p><p>1</p></blockquote><p>（3）计算（2+3）X4的值</p><blockquote><p>（a）expr一步完成计算</p><p>[atguigu@hadoop101 datas]$ expr `expr 2 + 3` \* 4</p><p>20</p><p>（b）采用$[运算式]方式</p><p>[atguigu@hadoop101 datas]# S&#x3D;$[(2+3)*4]</p><p>[atguigu@hadoop101 datas]# echo $S</p></blockquote><h1 id="第6章-条件判断"><a href="#第6章-条件判断" class="headerlink" title="第6章 条件判断"></a>第6章 条件判断</h1><p>1．基本语法</p><p>[ condition ]（注意condition前后要有空格）</p><p>注意：条件非空即为true，[ atguigu ]返回true，[] 返回false。</p><p>2. 常用判断条件</p><blockquote><p>（1）两个整数之间比较</p><p>&#x3D; 字符串比较</p><p>-lt 小于（less than） -le 小于等于（less equal）</p><p>-eq 等于（equal） -gt 大于（greater than）</p><p>-ge 大于等于（greater equal） -ne 不等于（Not equal）</p><p>（2）按照文件权限进行判断</p><p>-r 有读的权限（read） -w 有写的权限（write）</p><p>-x 有执行的权限（execute）</p><p>（3）按照文件类型进行判断</p><p>-f 文件存在并且是一个常规的文件（file）</p><p>-e 文件存在（existence） -d 文件存在并是一个目录（directory）</p></blockquote><p>3．案例实操</p><p>（1）23是否大于等于22</p><blockquote><p>[atguigu@hadoop101 datas]$ [ 23 -ge 22 ]</p><p>[atguigu@hadoop101 datas]$ echo $?</p><p>0</p></blockquote><p>（2）helloworld.sh是否具有写权限</p><blockquote><p>[atguigu@hadoop101 datas]$ [ -w helloworld.sh ]</p><p>[atguigu@hadoop101 datas]$ echo $?</p><p>0</p></blockquote><p>（3）&#x2F;home&#x2F;atguigu&#x2F;cls.txt目录中的文件是否存在</p><blockquote><p>[atguigu@hadoop101 datas]$ [ -e &#x2F;home&#x2F;atguigu&#x2F;cls.txt ]</p><p>[atguigu@hadoop101 datas]$ echo $?</p><p>1</p></blockquote><p>（4）多条件判断（&amp;&amp; 表示前一条命令执行成功时，才执行后一条命令，||<br>表示上一条命令执行失败后，才执行下一条命令）</p><blockquote><p>[atguigu@hadoop101 ~]$ [ condition ] &amp;&amp; echo OK || echo notok</p><p>OK</p><p>[atguigu@hadoop101 datas]$ [ condition ] &amp;&amp; [ ] || echo notok</p><p>notok</p></blockquote><h1 id="第7章-流程控制（重点）"><a href="#第7章-流程控制（重点）" class="headerlink" title="第7章 流程控制（重点）"></a>第7章 流程控制（重点）</h1><h2 id="7-1-if-判断"><a href="#7-1-if-判断" class="headerlink" title="7.1 if 判断"></a>7.1 if 判断</h2><p>1．基本语法</p><blockquote><p>if [ 条件判断式 ];then</p><p>程序</p><p>fi</p><p>或者</p><p>if [ 条件判断式 ]</p><p>then</p><p>程序</p><p>fi</p></blockquote><p>注意事项：</p><p>（1）[ 条件判断式 ]，中括号和条件判断式之间必须有空格</p><p>（2）if后要有空格</p><p>2．案例实操</p><p>（1）输入一个数字，如果是1，则输出banzhang zhen<br>shuai，如果是2，则输出cls zhen mei，如果是其它，什么也不输出。</p><blockquote><p>[atguigu@hadoop101 datas]$ touch if.sh</p><p>[atguigu@hadoop101 datas]$ vim if.sh</p><p>#!&#x2F;bin&#x2F;bash</p><p>if [ $1 -eq &quot;1&quot; ]</p><p>then</p><p>echo &quot;banzhang zhen shuai&quot;</p><p>elif [ $1 -eq &quot;2&quot; ]</p><p>then</p><p>echo &quot;cls zhen mei&quot;</p><p>fi</p><p>[atguigu@hadoop101 datas]$ chmod 777 if.sh</p><p>[atguigu@hadoop101 datas]$ .&#x2F;if.sh 1</p><p>banzhang zhen shuai</p></blockquote><h2 id="7-2-case-语句"><a href="#7-2-case-语句" class="headerlink" title="7.2 case 语句"></a>7.2 case 语句</h2><p>1．基本语法</p><blockquote><p>case $变量名 in</p><p>&quot;值1&quot;）</p><p>如果变量的值等于值1，则执行程序1</p><p>;;</p><p>&quot;值2&quot;）</p><p>如果变量的值等于值2，则执行程序2</p><p>;;</p><p>…省略其他分支…</p><p>*）</p><p>如果变量的值都不是以上的值，则执行此程序</p><p>;;</p><p>esac</p><p>注意事项：</p></blockquote><ol><li><p>case行尾必须为单词”in”，每一个模式匹配必须以右括号”）”结束。</p></li><li><p>双分号”<strong>;;</strong>“表示命令序列结束，相当于java中的break。</p></li><li><p>最后的”*）”表示默认模式，相当于java中的default。</p></li></ol><p>2．案例实操</p><p>（1）输入一个数字，如果是1，则输出banzhang，如果是2，则输出cls，如果是其它，输出renyao。</p><blockquote><p>[atguigu@hadoop101 datas]$ touch case.sh</p><p>[atguigu@hadoop101 datas]$ vim case.sh</p><p>!&#x2F;bin&#x2F;bash</p><p>case $1 in</p><p>&quot;1&quot;)</p><p>echo &quot;banzhang&quot;</p><p>;;</p><p>&quot;2&quot;)</p><p>echo &quot;cls&quot;</p><p>;;</p><p>*)</p><p>echo &quot;renyao&quot;</p><p>;;</p><p>esac</p><p>[atguigu@hadoop101 datas]$ chmod 777 case.sh</p><p>[atguigu@hadoop101 datas]$ .&#x2F;case.sh 1</p><p>1</p></blockquote><h2 id="7-3-for-循环"><a href="#7-3-for-循环" class="headerlink" title="7.3 for 循环"></a>7.3 for 循环</h2><p>1．基本语法1</p><p>for (( 初始值;循环控制条件;变量变化 ))</p><blockquote><p>do</p><p>程序</p><p>done</p></blockquote><p>2．案例实操</p><blockquote><p>（1）从1加到100</p><p>[atguigu@hadoop101 datas]$ touch for1.sh</p><p>[atguigu@hadoop101 datas]$ vim for1.sh</p><p>#!&#x2F;bin&#x2F;bash</p><p>s&#x3D;0</p><p>for((i&#x3D;0;i&lt;&#x3D;100;i++))</p><p>do</p><p>s&#x3D;$[$s+$i]</p><p>done</p><p>echo $s</p><p>[atguigu@hadoop101 datas]$ chmod 777 for1.sh</p><p>[atguigu@hadoop101 datas]$ .&#x2F;for1.sh</p><p>“5050”</p></blockquote><p>3．基本语法2</p><blockquote><p>for 变量 in 值1 值2 值3…</p><p>do</p><p>程序</p><p>done</p></blockquote><p>4．案例实操</p><p>（1）打印所有输入参数</p><blockquote><p>[atguigu@hadoop101 datas]$ touch for2.sh</p><p>[atguigu@hadoop101 datas]$ vim for2.sh</p><p>#!&#x2F;bin&#x2F;bash</p><p>#打印数字</p><p>for i in $*</p><p>do</p><p>echo &quot;ban zhang love $i &quot;</p><p>done</p><p>[atguigu@hadoop101 datas]$ chmod 777 for2.sh</p><p>[atguigu@hadoop101 datas]$ bash for2.sh cls xz bd</p><p>ban zhang love cls</p><p>ban zhang love xz</p><p>ban zhang love bd</p></blockquote><p>（2）比较$*和$@区别</p><p>（a）$*和$@都表示传递给函数或脚本的所有参数，不被双引号””包含时，都以$1<br>$2 …$n的形式输出所有参数。</p><p>+———————————————————————–+<br>| [atguigu@hadoop101 datas]$ touch for.sh                            |<br>|                                                                       |<br>| [atguigu@hadoop101 datas]$ vim for.sh                              |<br>|                                                                       |<br>| #!&#x2F;bin&#x2F;bash                                                           |<br>|                                                                       |<br>| for i in $*                                                         |<br>|                                                                       |<br>| do                                                                    |<br>|                                                                       |<br>| echo &quot;ban zhang love $i &quot;                                          |<br>|                                                                       |<br>| done                                                                  |<br>|                                                                       |<br>| for j in $@                                                          |<br>|                                                                       |<br>| do                                                                    |<br>|                                                                       |<br>| echo &quot;ban zhang love $j&quot;                                           |<br>|                                                                       |<br>| done                                                                  |<br>|                                                                       |<br>| [atguigu@hadoop101 datas]$ bash for.sh cls xz bd                   |<br>|                                                                       |<br>| ban zhang love cls                                                    |<br>|                                                                       |<br>| ban zhang love xz                                                     |<br>|                                                                       |<br>| ban zhang love bd                                                     |<br>|                                                                       |<br>| ban zhang love cls                                                    |<br>|                                                                       |<br>| ban zhang love xz                                                     |<br>|                                                                       |<br>| ban zhang love bd                                                     |<br>+———————————————————————–+</p><p>（b）当它们被双引号””包含时，”$*“会将所有的参数作为一个整体，以”$1<br>$2 …$n”的形式输出所有参数；”$@”会将各个参数分开，以”$1”<br>“$2”…”$n”的形式输出所有参数。</p><blockquote><p>[atguigu@hadoop101 datas]$ vim for.sh</p><p>#!&#x2F;bin&#x2F;bash</p><p>for i in &quot;$*&quot;</p><p>#$*中的所有参数看成是一个整体，所以这个for循环只会循环一次</p><p>do</p><p>echo &quot;ban zhang love $i&quot;</p><p>done</p><p>for j in &quot;$@&quot;</p><p>#$@中的每个参数都看成是独立的，所以”$@”中有几个参数，就会循环几次</p><p>do</p><p>echo &quot;ban zhang love $j&quot;</p><p>done</p><p>[atguigu@hadoop101 datas]$ chmod 777 for.sh</p><p>[atguigu@hadoop101 datas]$ bash for.sh cls xz bd</p><p>ban zhang love cls xz bd</p><p>ban zhang love cls</p><p>ban zhang love xz</p><p>ban zhang love bd</p></blockquote><h2 id="7-4-while-循环"><a href="#7-4-while-循环" class="headerlink" title="7.4 while 循环"></a>7.4 while 循环</h2><p>1．基本语法</p><blockquote><p>while [ 条件判断式 ]</p><p>do</p><p>程序</p><p>done</p></blockquote><p>2．案例实操</p><p>（1）从1加到100</p><blockquote><p>[atguigu@hadoop101 datas]$ touch while.sh</p><p>[atguigu@hadoop101 datas]$ vim while.sh</p><p>#!&#x2F;bin&#x2F;bash</p><p>s&#x3D;0</p><p>i&#x3D;1</p><p>while [ $i -le 100 ]</p><p>do</p><p>s&#x3D;$[$s+$i]</p><p>i&#x3D;$[$i+1]</p><p>done</p><p>echo $s</p><p>[atguigu@hadoop101 datas]$ chmod 777 while.sh</p><p>[atguigu@hadoop101 datas]$ .&#x2F;while.sh</p><p>5050</p></blockquote><h1 id="第8章-read读取控制台输入"><a href="#第8章-read读取控制台输入" class="headerlink" title="第8章 read读取控制台输入"></a>第8章 read读取控制台输入</h1><p>1．基本语法</p><p>read(选项)(参数)</p><p>选项：</p><blockquote><p>-p：指定读取值时的提示符；</p><p>-t：指定读取值时等待的时间（秒）。</p><p>参数</p><p>变量：指定读取值的变量名</p></blockquote><p>2．案例实操</p><p>（1）提示7秒内，读取控制台输入的名称</p><blockquote><p>[atguigu@hadoop101 datas]$ touch read.sh</p><p>[atguigu@hadoop101 datas]$ vim read.sh</p><p>#!&#x2F;bin&#x2F;bash</p><p>read -t 7 -p &quot;Enter your name in 7 seconds &quot; NAME</p><p>echo $NAME</p><p>[atguigu@hadoop101 datas]$ .&#x2F;read.sh</p><p>Enter your name in 7 seconds xiaoze</p><p>xiaoze</p></blockquote><h1 id="第9章-函数"><a href="#第9章-函数" class="headerlink" title="第9章 函数"></a>第9章 函数</h1><h2 id="9-1-系统函数"><a href="#9-1-系统函数" class="headerlink" title="9.1 系统函数"></a>9.1 系统函数</h2><p>1．basename基本语法</p><p>basename [string &#x2F; pathname] [suffix]<br>（功能描述：basename命令会删掉所有的前缀包括最后一个（’&#x2F;‘）字符，然后将字符串显示出来。</p><p>选项：</p><p>suffix为后缀，如果suffix被指定了，basename会将pathname或string中的suffix去掉。</p><p>2．案例实操</p><p>（1）截取该&#x2F;home&#x2F;atguigu&#x2F;banzhang.txt路径的文件名称</p><blockquote><p>[atguigu@hadoop101 datas]$ basename &#x2F;home&#x2F;atguigu&#x2F;banzhang.txt</p><p>banzhang.txt</p><p>[atguigu@hadoop101 datas]$ basename &#x2F;home&#x2F;atguigu&#x2F;banzhang.txt .txt</p><p>banzhang</p></blockquote><p>3. dirname基本语法</p><p>dirname 文件绝对路径<br>（功能描述：从给定的包含绝对路径的文件名中去除文件名（非目录的部分），然后返回剩下的路径（目录的部分））</p><p>4．案例实操</p><p>（1）获取banzhang.txt文件的路径</p><blockquote><p>[atguigu@hadoop101 ~]$ dirname &#x2F;home&#x2F;atguigu&#x2F;banzhang.txt</p><p>&#x2F;home&#x2F;atguigu</p></blockquote><h2 id="9-2-自定义函数"><a href="#9-2-自定义函数" class="headerlink" title="9.2 自定义函数"></a>9.2 自定义函数</h2><p>1．基本语法</p><blockquote><p>[ function ] funname[()]</p><p>{</p><p>Action;</p><p>[return int;]</p><p>}</p><p>funname</p></blockquote><p>2．经验技巧</p><p>（1）必须在调用函数地方之前，先声明函数，shell脚本是逐行运行。不会像其它语言一样先编译。</p><p>（2）函数返回值，只能通过$?系统变量获得，可以显示加：return返回，如果不加，将以最后一条命令运行结果，作为返回值。return后跟数值n(0-255)</p><p>3．案例实操</p><p>（1）计算两个输入参数的和</p><blockquote><p>[atguigu@hadoop101 datas]$ touch fun.sh</p><p>[atguigu@hadoop101 datas]$ vim fun.sh</p><p>#!&#x2F;bin&#x2F;bash</p><p>function sum()</p><p>{</p><p>s&#x3D;0</p><p>s&#x3D;$[ $1 + $2 ]</p><p>echo &quot;$s&quot;</p><p>}</p><p>read -p &quot;Please input the number1: &quot; n1;</p><p>read -p &quot;Please input the number2: &quot; n2;</p><p>sum $n1 $n2;</p><p>[atguigu@hadoop101 datas]$ chmod 777 fun.sh</p><p>[atguigu@hadoop101 datas]$ .&#x2F;fun.sh</p><p>Please input the number1: 2</p><p>Please input the number2: 5</p><p>7</p></blockquote><h1 id="第10章-Shell工具（重点）"><a href="#第10章-Shell工具（重点）" class="headerlink" title="第10章 Shell工具（重点）"></a>第10章 Shell工具（重点）</h1><h2 id="10-1-cut"><a href="#10-1-cut" class="headerlink" title="10.1 cut"></a>10.1 cut</h2><p>cut的工作就是”剪”，具体的说就是在文件中负责剪切数据用的。cut<br>命令从文件的每一行剪切字节、字符和字段并将这些字节、字符和字段输出。</p><p>1.基本用法</p><p>cut [选项参数] filename</p><p>说明：默认分隔符是制表符</p><p>2.选项参数说明</p><p>表1-55</p><hr><p>  选项参数      功能</p><p>  -f            列号，提取第几列</p><p>  -d            分隔符，按照指定分隔符分割列</p><hr><p>3.案例实操</p><blockquote><p>（0）数据准备</p><p>[atguigu@hadoop101 datas]$ touch cut.txt</p><p>[atguigu@hadoop101 datas]$ vim cut.txt</p><p>dong shen</p><p>guan zhen</p><p>wo wo</p><p>lai lai</p><p>le le</p><p>（1）切割cut.txt第一列</p><p>[atguigu@hadoop101 datas]$ cut -d &quot; &quot; -f 1 cut.txt</p><p>dong</p><p>guan</p><p>wo</p><p>lai</p><p>le</p><p>（2）切割cut.txt第二、三列</p><p>[atguigu@hadoop101 datas]$ cut -d &quot; &quot; -f 2,3 cut.txt</p><p>shen</p><p>zhen</p><p>wo</p><p>lai</p><p>le</p><p>（3）在cut.txt文件中切割出guan</p><p>[atguigu@hadoop101 datas]$ cat cut.txt | grep &quot;guan&quot; | cut -d<br>&quot; &quot; -f 1</p><p>guan</p><p>（4）选取系统PATH变量值，第2个”：”开始后的所有路径：</p><p>[atguigu@hadoop101 datas]$ echo $PATH</p><p>&#x2F;usr&#x2F;lib64&#x2F;qt-3.3&#x2F;bin:&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;bin:&#x2F;usr&#x2F;bin:&#x2F;usr&#x2F;local&#x2F;sbin:&#x2F;usr&#x2F;sbin:&#x2F;sbin:&#x2F;home&#x2F;atguigu&#x2F;bin</p><p>[atguigu@hadoop102 datas]$ echo $PATH | cut -d: -f 2-</p><p>&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;bin:&#x2F;usr&#x2F;bin:&#x2F;usr&#x2F;local&#x2F;sbin:&#x2F;usr&#x2F;sbin:&#x2F;sbin:&#x2F;home&#x2F;atguigu&#x2F;bin</p><p>（5）切割ifconfig 后打印的IP地址</p><p>[atguigu@hadoop101 datas]$ ifconfig eth0 | grep &quot;inet addr&quot; |<br>cut -d: -f 2 | cut -d&quot; &quot; -f1</p><p>192.168.1.102</p></blockquote><h2 id="10-2-sed"><a href="#10-2-sed" class="headerlink" title="10.2 sed"></a>10.2 sed</h2><p>sed是一种流编辑器，它一次处理一行内容。处理时，把当前处理的行存储在临时缓冲区中，称为”模式空间”，接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。文件内容并没有改变，除非你使用重定向存储输出。</p><ol><li>基本用法</li></ol><blockquote><p>sed [选项参数] ‘command’ filename</p></blockquote><ol start="2"><li>选项参数说明</li></ol><p>表1-56</p><hr><p>  选项参数      功能</p><p>  -e            直接在指令列模式上进行sed的动作编辑。</p><hr><ol start="3"><li>命令功能描述</li></ol><p>表1-57</p><hr><p>  命令          功能描述</p><p>  <em>a</em>           新增，a的后面可以接字串，在下一行出现</p><p>  d             删除</p><p>  s             查找并替换</p><hr><ol start="4"><li>案例实操</li></ol><p>（0）数据准备</p><blockquote><p>[atguigu@hadoop102 datas]$ touch sed.txt</p><p>[atguigu@hadoop102 datas]$ vim sed.txt</p><p>dong shen</p><p>guan zhen</p><p>wo wo</p><p>lai lai</p><p>le le</p></blockquote><p>（1）将”mei nv”这个单词插入到sed.txt第二行下，打印。</p><blockquote><p>[atguigu@hadoop102 datas]$ sed &#39;2a mei nv&#39; sed.txt</p><p>dong shen</p><p>guan zhen</p><p>mei nv</p><p>wo wo</p><p>lai lai</p><p>le le</p><p>[atguigu@hadoop102 datas]$ cat sed.txt</p><p>dong shen</p><p>guan zhen</p><p>wo wo</p><p>lai lai</p><p>le le</p><p>注意：文件并没有改变</p></blockquote><p>（2）删除sed.txt文件所有包含wo的行</p><blockquote><p>[atguigu@hadoop102 datas]$ sed &#39;&#x2F;wo&#x2F;d&#39; sed.txt</p><p>dong shen</p><p>guan zhen</p><p>lai lai</p><p>le le</p></blockquote><p>（3）将sed.txt文件中wo替换为ni</p><blockquote><p>[atguigu@hadoop102 datas]$ sed &#39;s&#x2F;wo&#x2F;ni&#x2F;g&#39; sed.txt</p><p>dong shen</p><p>guan zhen</p><p>ni ni</p><p>lai lai</p><p>le le</p><p>注意：’g’表示global，全部替换</p><p>（4）将sed.txt文件中的第二行删除并将wo替换为ni</p><p>[atguigu@hadoop102 datas]$ sed -e &#39;2d&#39; -e &#39;s&#x2F;wo&#x2F;ni&#x2F;g&#39; sed.txt</p><p>dong shen</p><p>ni ni</p><p>lai lai</p><p>le le</p></blockquote><h2 id="10-3-awk"><a href="#10-3-awk" class="headerlink" title="10.3 awk"></a>10.3 awk</h2><p>一个强大的文本分析工具，把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行分析处理。</p><ol><li>基本用法</li></ol><blockquote><p>awk [选项参数] ‘pattern1{action1} pattern2{action2}...’ filename</p><p>pattern：表示AWK在数据中查找的内容，就是匹配模式</p><p>action：在找到匹配内容时所执行的一系列命令</p></blockquote><ol start="2"><li>选项参数说明</li></ol><p>表1-55</p><hr><p>  选项参数      功能</p><p>  -F            指定输入文件折分隔符</p><p>  -v            赋值一个用户定义变量</p><hr><ol start="3"><li>案例实操</li></ol><blockquote><p>（0）数据准备</p><p>[atguigu@hadoop102 datas]$ sudo cp &#x2F;etc&#x2F;passwd .&#x2F;</p></blockquote><p>（1）搜索passwd文件以root关键字开头的所有行，并输出该行的第7列。</p><blockquote><p>[atguigu@hadoop102 datas]$ awk -F: &#39;&#x2F;^root&#x2F;{print $7}&#39; passwd</p><p>&#x2F;bin&#x2F;bash</p></blockquote><p>（2）搜索passwd文件以root关键字开头的所有行，并输出该行的第1列和第7列，中间以”，”号分割。</p><blockquote><p>[atguigu@hadoop102 datas]$ awk -F: &#39;&#x2F;^root&#x2F;{print $1&quot;,&quot;$7}&#39;<br>passwd</p><p>root,&#x2F;bin&#x2F;bash</p><p>注意：只有匹配了pattern的行才会执行action</p></blockquote><p>（3）只显示&#x2F;etc&#x2F;passwd的第一列和第七列，以逗号分割，且在所有行前面添加列名user，shell在最后一行添加&quot;dahaige，&#x2F;bin&#x2F;zuishuai&quot;。</p><blockquote><p>[atguigu@hadoop102 datas]$ awk -F : &#39;BEGIN{print &quot;user, shell&quot;}<br>{print $1&quot;,&quot;$7} END{print &quot;dahaige,&#x2F;bin&#x2F;zuishuai&quot;}&#39; passwd</p><p>user, shell</p><p>root,&#x2F;bin&#x2F;bash</p><p>bin,&#x2F;sbin&#x2F;nologin</p><p>。。。</p><p>atguigu,&#x2F;bin&#x2F;bash</p><p>dahaige,&#x2F;bin&#x2F;zuishuai</p><p>注意：BEGIN 在所有数据读取行之前执行；END 在所有数据执行之后执行。</p></blockquote><p>（4）将passwd文件中的用户id增加数值1并输出</p><blockquote><p>[atguigu@hadoop102 datas]$ awk -v i&#x3D;1 -F: &#39;{print $3+i}&#39; passwd</p><p>1</p><p>2</p><p>3</p><p>4</p></blockquote><ol start="4"><li>awk的内置变量</li></ol><blockquote><p>表1-56</p></blockquote><hr><p>  变量          说明</p><p>  FILENAME      文件名</p><p>  NR            已读的记录数</p><p>  NF            浏览记录的域的个数（切割后，列的个数）</p><hr><ol start="5"><li>案例实操</li></ol><blockquote><p>（1）统计passwd文件名，每行的行号，每行的列数</p><p>[atguigu@hadoop102 datas]$ awk -F: &#39;{print &quot;filename:&quot; FILENAME<br>&quot;, linenumber:&quot; NR &quot;,columns:&quot; NF}&#39; passwd</p><p>filename:passwd, linenumber:1,columns:7</p><p>filename:passwd, linenumber:2,columns:7</p><p>filename:passwd, linenumber:3,columns:7</p></blockquote><p>（2）切割IP</p><blockquote><p>[atguigu@hadoop102 datas]$ ifconfig eth0 | grep &quot;inet addr&quot; |<br>awk -F: &#39;{print $2}&#39; | awk -F &quot; &quot; &#39;{print $1}&#39;</p><p>192.168.1.102</p></blockquote><p>（3）查询sed.txt中空行所在的行号</p><blockquote><p>[atguigu@hadoop102 datas]$ awk &#39;&#x2F;^$&#x2F;{print NR}&#39; sed.txt</p><p>5</p></blockquote><h2 id="10-4-sort"><a href="#10-4-sort" class="headerlink" title="10.4 sort"></a>10.4 sort</h2><p>sort命令是在Linux里非常有用，它将文件进行排序，并将排序结果标准输出。</p><ol><li>基本语法</li></ol><blockquote><p>sort(选项)(参数)</p><p>表1-57</p></blockquote><hr><p>  选项          说明</p><p>  -n            依照数值的大小排序</p><p>  -r            以相反的顺序来排序</p><p>  -t            设置排序时所用的分隔字符</p><p>  -k            指定需要排序的列</p><hr><blockquote><p>参数：指定待排序的文件列表</p></blockquote><p>2. 案例实操</p><blockquote><p>（0）数据准备</p><p>[atguigu@hadoop102 datas]$ touch sort.sh</p><p>[atguigu@hadoop102 datas]$ vim sort.sh</p><p>bb:40:5.4</p><p>bd:20:4.2</p><p>xz:50:2.3</p><p>cls:10:3.5</p><p>ss:30:1.6</p><p>（1）按照”：”分割后的第三列倒序排序。</p><p>[atguigu@hadoop102 datas]$ sort -t : -nrk 3 sort.sh</p><p>bb:40:5.4</p><p>bd:20:4.2</p><p>cls:10:3.5</p><p>xz:50:2.3</p><p>ss:30:1.6</p></blockquote><h1 id="第11章-企业真实面试题（重点）"><a href="#第11章-企业真实面试题（重点）" class="headerlink" title="第11章 企业真实面试题（重点）"></a>第11章 企业真实面试题（重点）</h1><h2 id="11-1-京东"><a href="#11-1-京东" class="headerlink" title="11.1 京东"></a>11.1 京东</h2><blockquote><p>问题1：使用Linux命令查询file1中空行所在的行号</p><p>答案：</p><p>[atguigu@hadoop102 datas]$ awk &#39;&#x2F;^$&#x2F;{print NR}&#39; sed.txt</p><p>5</p><p>问题2：有文件chengji.txt内容如下:</p><p>张三 40</p><p>李四 50</p><p>王五 60</p></blockquote><p>使用Linux命令计算第二列的和并输出</p><blockquote><p>[atguigu@hadoop102 datas]$ cat chengji.txt | awk -F &quot; &quot;<br>&#39;{sum+&#x3D;$2} END{print sum}&#39;</p><p>150</p></blockquote><h2 id="11-2-搜狐-amp-和讯网"><a href="#11-2-搜狐-amp-和讯网" class="headerlink" title="11.2 搜狐&amp;和讯网"></a>11.2 搜狐&amp;和讯网</h2><p>问题1：Shell脚本里如何检查一个文件是否存在？如果不存在该如何处理？</p><blockquote><p>#!&#x2F;bin&#x2F;bash</p><p>if [ -f file.txt ]; then</p><p>echo &quot;文件存在!&quot;</p><p>else</p><p>echo &quot;文件不存在!&quot;</p><p>fi</p></blockquote><h2 id="11-3-新浪"><a href="#11-3-新浪" class="headerlink" title="11.3 新浪"></a>11.3 新浪</h2><p>问题1：用shell写一个脚本，对文本中无序的一列数字排序</p><blockquote><p>[root@CentOS6-2 ~]# cat test.txt</p><p>9</p><p>8</p><p>7</p><p>6</p><p>5</p><p>4</p><p>3</p><p>2</p><p>10</p><p>1</p><p>[root@CentOS6-2 ~]# sort -n test.txt|awk &#39;{a+&#x3D;$0;print<br>$0}END{print &quot;SUM&#x3D;&quot;a}&#39;</p><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>SUM&#x3D;55</p></blockquote><h2 id="11-3-金和网络"><a href="#11-3-金和网络" class="headerlink" title="11.3 金和网络"></a>11.3 金和网络</h2><p>问题1：请用shell脚本写出查找当前文件夹（&#x2F;home）下所有的文本文件内容中包含有字符”shen”的文件名称</p><blockquote><p>[atguigu@hadoop102 datas]$ grep -r &quot;shen&quot; &#x2F;home | cut -d &quot;:&quot;<br>-f 1</p><p>&#x2F;home&#x2F;atguigu&#x2F;datas&#x2F;sed.txt</p><p>&#x2F;home&#x2F;atguigu&#x2F;datas&#x2F;cut.txt</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty入门-第一话</title>
      <link href="/archives/3f9283e7.html"/>
      <url>/archives/3f9283e7.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><ul><li>因为学netty的过程中，发现计算机网络和操作系统蛮重要的，所以接下来会写几篇这方面的文章，希望读者不要觉得我东写一点，西写一点。</li><li>比如netty中有操作系统里的IO，零拷贝。有计算机网络里的通信(因为netty本身就是一个网络应用框架)。等等</li></ul></blockquote><h1 id="Netty简介"><a href="#Netty简介" class="headerlink" title="Netty简介"></a>Netty简介</h1><h2 id="Netty-的介绍"><a href="#Netty-的介绍" class="headerlink" title="Netty 的介绍"></a>Netty 的介绍</h2><ol><li><code>Netty</code> 是由 <code>JBOSS</code> 提供的一个 <code>Java</code> 开源框架，现为 <code>Github</code> 上的独立项目。</li><li><code>Netty</code> 是一个异步的、基于事件驱动的网络应用框架，用以快速开发高性能、高可靠性的网络 <code>IO</code> 程序。</li><li><code>Netty</code> 主要针对在 <code>TCP</code> 协议下，面向 <code>Client</code> 端的高并发应用，或者 <code>Peer-to-Peer</code> 场景下的大量数据持续传输的应用。</li><li><code>Netty</code> 本质是一个 <code>NIO</code> 框架，适用于服务器通讯相关的多种应用场景。</li><li>要透彻理解 <code>Netty</code>，需要先学习 <code>NIO</code>，这样我们才能阅读 <code>Netty</code> 的源码。</li></ol><p>相对简单的一个体系图</p><img src="https://npm.elemecdn.com/youthlql@1.0.0/netty/introduction/chapter_001/0001.png"/><h2 id="Netty-的应用场景"><a href="#Netty-的应用场景" class="headerlink" title="Netty 的应用场景"></a>Netty 的应用场景</h2><h3 id="互联网行业"><a href="#互联网行业" class="headerlink" title="互联网行业"></a>互联网行业</h3><ol><li>互联网行业：在分布式系统中，各个节点之间需要远程服务调用，高性能的 <code>RPC</code> 框架必不可少，<code>Netty</code> 作为异步高性能的通信框架，往往作为基础通信组件被这些 <code>RPC</code> 框架使用。</li><li>典型的应用有：阿里分布式服务框架 <code>Dubbo</code> 的 <code>RPC</code> 框 架使用 <code>Dubbo</code> 协议进行节点间通信，<code>Dubbo</code> 协议默认使用 <code>Netty</code> 作为基础通信组件，用于实现各进程节点之间的内部通信。</li></ol><h3 id="游戏行业"><a href="#游戏行业" class="headerlink" title="游戏行业"></a>游戏行业</h3><ol><li>无论是手游服务端还是大型的网络游戏，<code>Java</code> 语言得到了越来越广泛的应用。</li><li><code>Netty</code> 作为高性能的基础通信组件，提供了 <code>TCP/UDP</code> 和 <code>HTTP</code> 协议栈，方便定制和开发私有协议栈，账号登录服务器。</li><li>地图服务器之间可以方便的通过 <code>Netty</code> 进行高性能的通信。</li></ol><h3 id="大数据领域"><a href="#大数据领域" class="headerlink" title="大数据领域"></a>大数据领域</h3><ol><li>经典的 <code>Hadoop</code> 的高性能通信和序列化组件 <code>Avro</code> 的 <code>RPC</code> 框架，默认采用 <code>Netty</code> 进行跨界点通信。</li><li>它的 <code>NettyService</code> 基于 <code>Netty</code> 框架二次封装实现。</li></ol><h3 id="其它开源项目使用到-Netty"><a href="#其它开源项目使用到-Netty" class="headerlink" title="其它开源项目使用到 Netty"></a>其它开源项目使用到 Netty</h3><p>网址：<a href="https://netty.io/wiki/related-projects.html">https://netty.io/wiki/related-projects.html</a></p><h2 id="Netty-的学习资料参考"><a href="#Netty-的学习资料参考" class="headerlink" title="Netty 的学习资料参考"></a>Netty 的学习资料参考</h2><img src="https://npm.elemecdn.com/youthlql@1.0.0/netty/introduction/chapter_001/0002.png"/><h1 id="Java-BIO编程"><a href="#Java-BIO编程" class="headerlink" title="Java BIO编程"></a>Java BIO编程</h1><h2 id="I-x2F-O-模型"><a href="#I-x2F-O-模型" class="headerlink" title="I&#x2F;O 模型"></a>I&#x2F;O 模型</h2><ol><li><code>I/O</code> 模型简单的理解：就是用什么样的通道进行数据的发送和接收，很大程度上决定了程序通信的性能。</li><li><code>Java</code> 共支持 <code>3</code> 种网络编程模型 <code>I/O</code> 模式：<code>BIO</code>、<code>NIO</code>、<code>AIO</code>。</li><li><code>Java BIO</code>：同步并阻塞（传统阻塞型），服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销。【简单示意图】</li></ol><img src="https://npm.elemecdn.com/youthlql@1.0.0/netty/introduction/chapter_001/0003.png"/><ol start="4"><li><code>Java NIO</code>：同步非阻塞，服务器实现模式为一个线程处理多个请求（连接），即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有 <code>I/O</code> 请求就进行处理。【简单示意图】</li></ol><img src="https://npm.elemecdn.com/youthlql@1.0.0/netty/introduction/chapter_001/0004.png"/><ol start="5"><li><code>Java AIO(NIO.2)</code>：异步非阻塞，<code>AIO</code> 引入异步通道的概念，采用了 <code>Proactor</code> 模式，简化了程序编写，有效的请求才启动线程，它的特点是先由操作系统完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时间较长的应用。</li><li>我们依次展开讲解。</li></ol><h2 id="BIO、NIO、AIO-使用场景分析"><a href="#BIO、NIO、AIO-使用场景分析" class="headerlink" title="BIO、NIO、AIO 使用场景分析"></a>BIO、NIO、AIO 使用场景分析</h2><ol><li><code>BIO</code> 方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，<code>JDK1.4</code> 以前的唯一选择，但程序简单易理解。</li><li><code>NIO</code> 方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，弹幕系统，服务器间通讯等。编程比较复杂，<code>JDK1.4</code> 开始支持。</li><li><code>AIO</code> 方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用 <code>OS</code> 参与并发操作，编程比较复杂，<code>JDK7</code> 开始支持。</li></ol><h2 id="Java-BIO-基本介绍"><a href="#Java-BIO-基本介绍" class="headerlink" title="Java BIO 基本介绍"></a>Java BIO 基本介绍</h2><ol><li><code>Java BIO</code> 就是传统的 <code>Java I/O</code> 编程，其相关的类和接口在 <code>java.io</code>。</li><li><code>BIO(BlockingI/O)</code>：同步阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，可以通过线程池机制改善（实现多个客户连接服务器）。【后有应用实例】</li><li><code>BIO</code> 方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，<code>JDK1.4</code> 以前的唯一选择，程序简单易理解。</li></ol><h2 id="Java-BIO-工作机制"><a href="#Java-BIO-工作机制" class="headerlink" title="Java BIO 工作机制"></a>Java BIO 工作机制</h2><img src="https://npm.elemecdn.com/youthlql@1.0.0/netty/introduction/chapter_001/0005.png"/><p>对 <code>BIO</code> 编程流程的梳理</p><ol><li>服务器端启动一个 <code>ServerSocket</code>。</li><li>客户端启动 <code>Socket</code> 对服务器进行通信，默认情况下服务器端需要对每个客户建立一个线程与之通讯。</li><li>客户端发出请求后，先咨询服务器是否有线程响应，如果没有则会等待，或者被拒绝。</li><li>如果有响应，客户端线程会等待请求结束后，再继续执行。</li></ol><h2 id="Java-BIO-应用实例"><a href="#Java-BIO-应用实例" class="headerlink" title="Java BIO 应用实例"></a>Java BIO 应用实例</h2><p>实例说明：</p><ol><li>使用 <code>BIO</code> 模型编写一个服务器端，监听 <code>6666</code> 端口，当有客户端连接时，就启动一个线程与之通讯。</li><li>要求使用线程池机制改善，可以连接多个客户端。</li><li>服务器端可以接收客户端发送的数据（<code>telnet</code> 方式即可）。</li><li>代码演示：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BIOServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//线程池机制</span></span><br><span class="line">        <span class="comment">//思路</span></span><br><span class="line">        <span class="comment">//1. 创建一个线程池</span></span><br><span class="line">        <span class="comment">//2. 如果有客户端连接，就创建一个线程，与之通讯(单独写一个方法)</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">newCachedThreadPool</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">//创建ServerSocket</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">6666</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器启动了&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程信息id = &quot;</span> + Thread.currentThread().getId() + <span class="string">&quot;名字 = &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="comment">//监听，等待客户端连接</span></span><br><span class="line">            System.out.println(<span class="string">&quot;等待连接....&quot;</span>);</span><br><span class="line">            <span class="comment">//会阻塞在accept()</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">            System.out.println(<span class="string">&quot;连接到一个客户端&quot;</span>);</span><br><span class="line">            <span class="comment">//就创建一个线程，与之通讯(单独写一个方法)</span></span><br><span class="line">            newCachedThreadPool.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;<span class="comment">//我们重写</span></span><br><span class="line">                    <span class="comment">//可以和客户端通讯</span></span><br><span class="line">                    handler(socket);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写一个handler方法，和客户端通讯</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">handler</span><span class="params">(Socket socket)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程信息id = &quot;</span> + Thread.currentThread().getId() + <span class="string">&quot;名字 = &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="comment">//通过socket获取输入流</span></span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">            <span class="comment">//循环的读取客户端发送的数据</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程信息id = &quot;</span> + Thread.currentThread().getId() + <span class="string">&quot;名字 = &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">                System.out.println(<span class="string">&quot;read....&quot;</span>);</span><br><span class="line">                <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> inputStream.read(bytes);</span><br><span class="line">                <span class="keyword">if</span> (read != -<span class="number">1</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(bytes, <span class="number">0</span>, read));<span class="comment">//输出客户端发送的数据</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;关闭和client的连接&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://npm.elemecdn.com/youthlql@1.0.0/netty/introduction/chapter_001/0006.png"/><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><ol><li>每个请求都需要创建独立的线程，与对应的客户端进行数据 <code>Read</code>，业务处理，数据 <code>Write</code>。</li><li>当并发数较大时，需要创建大量线程来处理连接，系统资源占用较大。</li><li>连接建立后，如果当前线程暂时没有数据可读，则线程就阻塞在 <code>Read</code> 操作上，造成线程资源浪费。</li></ol><h1 id="Java-NIO编程"><a href="#Java-NIO编程" class="headerlink" title="Java NIO编程"></a>Java NIO编程</h1><h2 id="Java-NIO-基本介绍"><a href="#Java-NIO-基本介绍" class="headerlink" title="Java NIO 基本介绍"></a>Java NIO 基本介绍</h2><ol><li><code>Java NIO</code> 全称 <code>Java non-blocking IO</code>，是指 <code>JDK</code> 提供的新 <code>API</code>。从 <code>JDK1.4</code> 开始，<code>Java</code> 提供了一系列改进的输入&#x2F;输出的新特性，被统称为 <code>NIO</code>（即 <code>NewIO</code>），是同步非阻塞的。</li><li><code>NIO</code> 相关类都被放在 <code>java.nio</code> 包及子包下，并且对原 <code>java.io</code> 包中的很多类进行改写。【基本案例】</li><li><code>NIO</code> 有三大核心部分：**<code>Channel</code>（通道）、<code>Buffer</code>（缓冲区）、<code>Selector</code>（选择器）** 。</li><li><code>NIO</code> 是<strong>面向缓冲区，或者面向块编程</strong>的。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动，这就增加了处理过程中的灵活性，使用它可以提供非阻塞式的高伸缩性网络。</li><li><code>Java NIO</code> 的非阻塞模式，使一个线程从某通道发送请求或者读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取，而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。非阻塞写也是如此，一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。【后面有案例说明】</li><li>通俗理解：<code>NIO</code> 是可以做到用一个线程来处理多个操作的。假设有 <code>10000</code> 个请求过来,根据实际情况，可以分配 <code>50</code> 或者 <code>100</code> 个线程来处理。不像之前的阻塞 <code>IO</code> 那样，非得分配 <code>10000</code> 个。</li><li><code>HTTP 2.0</code> 使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比 <code>HTTP 1.1</code> 大了好几个数量级。</li><li>案例说明 <code>NIO</code> 的 <code>Buffer</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.IntBuffer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BasicBuffer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//举例说明 Buffer 的使用(简单说明)</span></span><br><span class="line">        <span class="comment">//创建一个 Buffer，大小为 5，即可以存放 5 个 int</span></span><br><span class="line">        <span class="type">IntBuffer</span> <span class="variable">intBuffer</span> <span class="operator">=</span> IntBuffer.allocate(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向buffer存放数据</span></span><br><span class="line">        <span class="comment">//intBuffer.put(10);</span></span><br><span class="line">        <span class="comment">//intBuffer.put(11);</span></span><br><span class="line">        <span class="comment">//intBuffer.put(12);</span></span><br><span class="line">        <span class="comment">//intBuffer.put(13);</span></span><br><span class="line">        <span class="comment">//intBuffer.put(14);</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; intBuffer.capacity(); i++) &#123;</span><br><span class="line">            intBuffer.put(i * <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如何从 buffer 读取数据</span></span><br><span class="line">        <span class="comment">//将 buffer 转换，读写切换(!!!)</span></span><br><span class="line">        intBuffer.flip();</span><br><span class="line">        <span class="keyword">while</span> (intBuffer.hasRemaining()) &#123;</span><br><span class="line">            System.out.println(intBuffer.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="NIO-和-BIO-的比较"><a href="#NIO-和-BIO-的比较" class="headerlink" title="NIO 和 BIO 的比较"></a>NIO 和 BIO 的比较</h2><ol><li><code>BIO</code> 以流的方式处理数据，而 <code>NIO</code> 以块的方式处理数据，块 <code>I/O</code> 的效率比流 <code>I/O</code> 高很多。</li><li><code>BIO</code> 是阻塞的，<code>NIO</code> 则是非阻塞的。</li><li><code>BIO</code> 基于字节流和字符流进行操作，而 <code>NIO</code> 基于 <code>Channel</code>（通道）和 <code>Buffer</code>（缓冲区）进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。<code>Selector</code>（选择器）用于监听多个通道的事件（比如：连接请求，数据到达等），因此使用单个线程就可以监听多个客户端通道。</li><li>Buffer和Channel之间的数据流向是双向的</li></ol><img src="https://npm.elemecdn.com/youthlql@1.0.0/netty/introduction/chapter_001/0007.png"/><h2 id="NIO-三大核心原理示意图"><a href="#NIO-三大核心原理示意图" class="headerlink" title="NIO 三大核心原理示意图"></a>NIO 三大核心原理示意图</h2><p>一张图描述 <code>NIO</code> 的 <code>Selector</code>、<code>Channel</code> 和 <code>Buffer</code> 的关系。</p><h3 id="Selector、Channel-和-Buffer-关系图（简单版）"><a href="#Selector、Channel-和-Buffer-关系图（简单版）" class="headerlink" title="Selector、Channel 和 Buffer 关系图（简单版）"></a>Selector、Channel 和 Buffer 关系图（简单版）</h3><p>关系图的说明:</p><img src="https://npm.elemecdn.com/youthlql@1.0.0/netty/introduction/chapter_001/0008.png"/><ol><li>每个 <code>Channel</code> 都会对应一个 <code>Buffer</code>。</li><li><code>Selector</code> 对应一个线程，一个线程对应多个 <code>Channel</code>（连接）。</li><li>该图反应了有三个 <code>Channel</code> 注册到该 <code>Selector</code> &#x2F;&#x2F;程序</li><li>程序切换到哪个 <code>Channel</code> 是由事件决定的，<code>Event</code> 就是一个重要的概念。</li><li><code>Selector</code> 会根据不同的事件，在各个通道上切换。</li><li><code>Buffer</code> 就是一个内存块，底层是有一个数组。</li><li>数据的读取写入是通过 <code>Buffer</code>，这个和 <code>BIO</code>是不同的，<code>BIO</code> 中要么是输入流，或者是输出流，不能双向，但是 <code>NIO</code> 的 <code>Buffer</code> 是可以读也可以写，需要 <code>flip</code> 方法切换 <code>Channel</code> 是双向的，可以返回底层操作系统的情况，比如 <code>Linux</code>，底层的操作系统通道就是双向的。</li></ol><h2 id="缓冲区（Buffer）"><a href="#缓冲区（Buffer）" class="headerlink" title="缓冲区（Buffer）"></a>缓冲区（Buffer）</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>缓冲区（<code>Buffer</code>）：缓冲区本质上是一个<strong>可以读写数据的内存块</strong>，可以理解成是一个<strong>容器对象（含数组）</strong>，该对象提供了一组方法，可以更轻松地使用内存块，，缓冲区对象内置了一些机制，能够跟踪和记录缓冲区的状态变化情况。<code>Channel</code> 提供从文件、网络读取数据的渠道，但是读取或写入的数据都必须经由 <code>Buffer</code>，如图:【后面举例说明】</p><img src="https://npm.elemecdn.com/youthlql@1.0.0/netty/introduction/chapter_001/0009.png"/><h3 id="Buffer-类及其子类"><a href="#Buffer-类及其子类" class="headerlink" title="Buffer 类及其子类"></a>Buffer 类及其子类</h3><ol><li>在 <code>NIO</code> 中，<code>Buffer</code> 是一个顶层父类，它是一个抽象类，类的层级关系图：</li></ol><img src="https://npm.elemecdn.com/youthlql@1.0.0/netty/introduction/chapter_001/0010.png" /><ol start="2"><li><code>Buffer</code> 类定义了所有的缓冲区都具有的四个属性来提供关于其所包含的数据元素的信息：</li></ol><img src="https://npm.elemecdn.com/youthlql@1.0.0/netty/introduction/chapter_001/0011.png"/><ol start="3"><li><code>Buffer</code> 类相关方法一览</li></ol><img src="https://npm.elemecdn.com/youthlql@1.0.0/netty/introduction/chapter_001/0013.png" /><h3 id="ByteBuffer"><a href="#ByteBuffer" class="headerlink" title="ByteBuffer"></a>ByteBuffer</h3><p>从前面可以看出对于 <code>Java</code> 中的基本数据类型（<code>boolean</code> 除外），都有一个 <code>Buffer</code> 类型与之相对应，最常用的自然是 <code>ByteBuffer</code> 类（二进制数据），该类的主要方法如下：</p><img src="https://npm.elemecdn.com/youthlql@1.0.0/netty/introduction/chapter_001/0014.png"/><h2 id="通道（Channel）"><a href="#通道（Channel）" class="headerlink" title="通道（Channel）"></a>通道（Channel）</h2><h3 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li><code>NIO</code> 的通道类似于流，但有些区别如下：<ul><li>通道可以同时进行读写，而流只能读或者只能写</li><li>通道可以实现异步读写数据</li><li>通道可以从缓冲读数据，也可以写数据到缓冲:</li></ul></li><li><code>BIO</code> 中的 <code>Stream</code> 是单向的，例如 <code>FileInputStream</code> 对象只能进行读取数据的操作，而 <code>NIO</code> 中的通道（<code>Channel</code>）是双向的，可以读操作，也可以写操作。</li><li><code>Channel</code> 在 <code>NIO</code> 中是一个接口 <code>public interface Channel extends Closeable&#123;&#125;</code></li><li>常用的 <code>Channel</code> 类有：**<code>FileChannel</code>、<code>DatagramChannel</code>、<code>ServerSocketChannel</code> 和 <code>SocketChannel</code>**。【<code>ServerSocketChanne</code> 类似 <code>ServerSocket</code>、<code>SocketChannel</code> 类似 <code>Socket</code>】</li><li><code>FileChannel</code> 用于文件的数据读写，<code>DatagramChannel</code> 用于 <code>UDP</code> 的数据读写，<code>ServerSocketChannel</code> 和 <code>SocketChannel</code> 用于 <code>TCP</code> 的数据读写。</li><li>图示</li></ol><img src="https://npm.elemecdn.com/youthlql@1.0.0/netty/introduction/chapter_001/0015.png"/><h3 id="FileChannel-类"><a href="#FileChannel-类" class="headerlink" title="FileChannel 类"></a>FileChannel 类</h3><p><code>FileChannel</code> 主要用来对本地文件进行 <code>IO</code> 操作，常见的方法有</p><ul><li><code>public int read(ByteBuffer dst)</code>，从通道读取数据并放到缓冲区中</li><li><code>public int write(ByteBuffer src)</code>，把缓冲区的数据写到通道中</li><li><code>public long transferFrom(ReadableByteChannel src, long position, long count)</code>，从目标通道中复制数据到当前通道</li><li><code>public long transferTo(long position, long count, WritableByteChannel target)</code>，把数据从当前通道复制给目标通道</li></ul><h3 id="应用实例1-本地文件写数据"><a href="#应用实例1-本地文件写数据" class="headerlink" title="应用实例1 - 本地文件写数据"></a>应用实例1 - 本地文件写数据</h3><p>实例要求：</p><ol><li>使用前面学习后的 <code>ByteBuffer</code>（缓冲）和 <code>FileChannel</code>（通道），将 “hello,尚硅谷” 写入到 <code>file01.txt</code> 中</li><li>文件不存在就创建</li><li>代码演示</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NIOFileChannel01</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello,尚硅谷&quot;</span>;</span><br><span class="line">        <span class="comment">//创建一个输出流 -&gt; channel</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;d:\\file01.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过 fileOutputStream 获取对应的 FileChannel</span></span><br><span class="line">        <span class="comment">//这个 fileChannel 真实类型是 FileChannelImpl</span></span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">fileChannel</span> <span class="operator">=</span> fileOutputStream.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个缓冲区 ByteBuffer</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将 str 放入 byteBuffer</span></span><br><span class="line">        byteBuffer.put(str.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对 byteBuffer 进行 flip</span></span><br><span class="line">        byteBuffer.flip();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将 byteBuffer 数据写入到 fileChannel</span></span><br><span class="line">        fileChannel.write(byteBuffer);</span><br><span class="line">        fileOutputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="应用实例2-本地文件读数据"><a href="#应用实例2-本地文件读数据" class="headerlink" title="应用实例2 - 本地文件读数据"></a>应用实例2 - 本地文件读数据</h3><p>实例要求：</p><ol><li>使用前面学习后的 <code>ByteBuffer</code>（缓冲）和 <code>FileChannel</code>（通道），将 <code>file01.txt</code> 中的数据读入到程序，并显示在控制台屏幕</li><li>假定文件已经存在</li><li>代码演示</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NIOFileChannel02</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建文件的输入流</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:\\file01.txt&quot;</span>);</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//通过 fileInputStream 获取对应的 FileChannel -&gt; 实际类型 FileChannelImpl</span></span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">fileChannel</span> <span class="operator">=</span> fileInputStream.getChannel();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建缓冲区</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate((<span class="type">int</span>)file.length());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将通道的数据读入到 Buffer</span></span><br><span class="line">        fileChannel.read(byteBuffer);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将 byteBuffer 的字节数据转成 String</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(byteBuffer.array()));</span><br><span class="line">        fileInputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="应用实例3-使用一个-Buffer-完成文件读取、写入"><a href="#应用实例3-使用一个-Buffer-完成文件读取、写入" class="headerlink" title="应用实例3 - 使用一个 Buffer 完成文件读取、写入"></a>应用实例3 - 使用一个 Buffer 完成文件读取、写入</h3><p>实例要求：</p><ol><li>使用 <code>FileChannel</code>（通道）和方法 <code>read、write</code>，完成文件的拷贝</li><li>拷贝一个文本文件 <code>1.txt</code>，放在项目下即可</li><li>代码演示</li></ol><img src="https://npm.elemecdn.com/youthlql@1.0.0/netty/introduction/chapter_001/0016.png"/><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NIOFileChannel03</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;1.txt&quot;</span>);</span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">fileChannel01</span> <span class="operator">=</span> fileInputStream.getChannel();</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;2.txt&quot;</span>);</span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">fileChannel02</span> <span class="operator">=</span> fileOutputStream.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">512</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123; <span class="comment">//循环读取</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//这里有一个重要的操作，一定不要忘了</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            public final Buffer clear() &#123;</span></span><br><span class="line"><span class="comment">                position = 0;</span></span><br><span class="line"><span class="comment">                limit = capacity;</span></span><br><span class="line"><span class="comment">                mark = -1;</span></span><br><span class="line"><span class="comment">                return this;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            byteBuffer.clear(); <span class="comment">//清空 buffer</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> fileChannel01.read(byteBuffer);</span><br><span class="line">            System.out.println(<span class="string">&quot;read = &quot;</span> + read);</span><br><span class="line">            <span class="keyword">if</span> (read == -<span class="number">1</span>) &#123; <span class="comment">//表示读完</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将 buffer 中的数据写入到 fileChannel02--2.txt</span></span><br><span class="line">            byteBuffer.flip();</span><br><span class="line">            fileChannel02.write(byteBuffer);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭相关的流</span></span><br><span class="line">        fileInputStream.close();</span><br><span class="line">        fileOutputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="应用实例4-拷贝文件-transferFrom-方法"><a href="#应用实例4-拷贝文件-transferFrom-方法" class="headerlink" title="应用实例4 - 拷贝文件 transferFrom 方法"></a>应用实例4 - 拷贝文件 transferFrom 方法</h3><ol><li>实例要求：</li><li>使用 <code>FileChannel</code>（通道）和方法 <code>transferFrom</code>，完成文件的拷贝</li><li>拷贝一张图片</li><li>代码演示</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NIOFileChannel04</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建相关流</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;d:\\a.jpg&quot;</span>);</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;d:\\a2.jpg&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取各个流对应的 FileChannel</span></span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">sourceCh</span> <span class="operator">=</span> fileInputStream.getChannel();</span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">destCh</span> <span class="operator">=</span> fileOutputStream.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用 transferForm 完成拷贝</span></span><br><span class="line">        destCh.transferFrom(sourceCh, <span class="number">0</span>, sourceCh.size());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭相关通道和流</span></span><br><span class="line">        sourceCh.close();</span><br><span class="line">        destCh.close();</span><br><span class="line">        fileInputStream.close();</span><br><span class="line">        fileOutputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="关于-Buffer-和-Channel-的注意事项和细节"><a href="#关于-Buffer-和-Channel-的注意事项和细节" class="headerlink" title="关于 Buffer 和 Channel 的注意事项和细节"></a>关于 Buffer 和 Channel 的注意事项和细节</h3><ol><li><code>ByteBuffer</code> 支持类型化的 <code>put</code> 和 <code>get</code>，<code>put</code> 放入的是什么数据类型，<code>get</code> 就应该使用相应的数据类型来取出，否则可能有 <code>BufferUnderflowException</code> 异常。【举例说明】</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NIOByteBufferPutGet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建一个 Buffer</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">64</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//类型化方式放入数据</span></span><br><span class="line">        buffer.putInt(<span class="number">100</span>);</span><br><span class="line">        buffer.putLong(<span class="number">9</span>);</span><br><span class="line">        buffer.putChar(<span class="string">&#x27;尚&#x27;</span>);</span><br><span class="line">        buffer.putShort((<span class="type">short</span>) <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//取出</span></span><br><span class="line">        buffer.flip();</span><br><span class="line">        </span><br><span class="line">        System.out.println();</span><br><span class="line">        </span><br><span class="line">        System.out.println(buffer.getInt());</span><br><span class="line">        System.out.println(buffer.getLong());</span><br><span class="line">        System.out.println(buffer.getChar());</span><br><span class="line">        System.out.println(buffer.getShort());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>可以将一个普通 <code>Buffer</code> 转成只读 <code>Buffer</code>【举例说明】</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadOnlyBuffer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个 buffer</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">64</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">64</span>; i++) &#123;</span><br><span class="line">            buffer.put((<span class="type">byte</span>) i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读取</span></span><br><span class="line">        buffer.flip();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//得到一个只读的 Buffer</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">readOnlyBuffer</span> <span class="operator">=</span> buffer.asReadOnlyBuffer();</span><br><span class="line">        System.out.println(readOnlyBuffer.getClass());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读取</span></span><br><span class="line">        <span class="keyword">while</span> (readOnlyBuffer.hasRemaining()) &#123;</span><br><span class="line">            System.out.println(readOnlyBuffer.get());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        readOnlyBuffer.put((<span class="type">byte</span>) <span class="number">100</span>); <span class="comment">//ReadOnlyBufferException</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><code>NIO</code> 还提供了 <code>MappedByteBuffer</code>，可以让文件直接在内存（堆外的内存）中进行修改，而如何同步到文件由 <code>NIO</code> 来完成。【举例说明】</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.RandomAccessFile;</span><br><span class="line"><span class="keyword">import</span> java.nio.MappedByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 说明 1.MappedByteBuffer 可让文件直接在内存（堆外内存）修改,操作系统不需要拷贝一次</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MappedByteBufferTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">RandomAccessFile</span> <span class="variable">randomAccessFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;1.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">        <span class="comment">//获取对应的通道</span></span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">channel</span> <span class="operator">=</span> randomAccessFile.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 参数 1:FileChannel.MapMode.READ_WRITE 使用的读写模式</span></span><br><span class="line"><span class="comment">         * 参数 2：0：可以直接修改的起始位置</span></span><br><span class="line"><span class="comment">         * 参数 3:5: 是映射到内存的大小（不是索引位置），即将 1.txt 的多少个字节映射到内存</span></span><br><span class="line"><span class="comment">         * 可以直接修改的范围就是 0-5</span></span><br><span class="line"><span class="comment">         * 实际类型 DirectByteBuffer</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">MappedByteBuffer</span> <span class="variable">mappedByteBuffer</span> <span class="operator">=</span> channel.map(FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        mappedByteBuffer.put(<span class="number">0</span>, (<span class="type">byte</span>) <span class="string">&#x27;H&#x27;</span>);</span><br><span class="line">        mappedByteBuffer.put(<span class="number">3</span>, (<span class="type">byte</span>) <span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">        mappedByteBuffer.put(<span class="number">5</span>, (<span class="type">byte</span>) <span class="string">&#x27;Y&#x27;</span>);<span class="comment">//IndexOutOfBoundsException</span></span><br><span class="line"></span><br><span class="line">        randomAccessFile.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;修改成功~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>前面我们讲的读写操作，都是通过一个 <code>Buffer</code> 完成的，<code>NIO</code> 还支持通过多个 <code>Buffer</code>（即 <code>Buffer</code>数组）完成读写操作，即 <code>Scattering</code> 和 <code>Gathering</code>【举例说明】</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Scattering：将数据写入到 buffer 时，可以采用 buffer 数组，依次写入 [分散]</span></span><br><span class="line"><span class="comment"> * Gathering：从 buffer 读取数据时，可以采用 buffer 数组，依次读</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScatteringAndGatheringTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//使用 ServerSocketChannel 和 SocketChannel 网络</span></span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">serverSocketChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        <span class="type">InetSocketAddress</span> <span class="variable">inetSocketAddress</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">7000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//绑定端口到 socket，并启动</span></span><br><span class="line">        serverSocketChannel.socket().bind(inetSocketAddress);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建 buffer 数组</span></span><br><span class="line">        ByteBuffer[] byteBuffers = <span class="keyword">new</span> <span class="title class_">ByteBuffer</span>[<span class="number">2</span>];</span><br><span class="line">        byteBuffers[<span class="number">0</span>] = ByteBuffer.allocate(<span class="number">5</span>);</span><br><span class="line">        byteBuffers[<span class="number">1</span>] = ByteBuffer.allocate(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//等客户端连接 (telnet)</span></span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> serverSocketChannel.accept();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">messageLength</span> <span class="operator">=</span> <span class="number">8</span>; <span class="comment">//假定从客户端接收 8 个字节</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//循环的读取</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">byteRead</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (byteRead &lt; messageLength) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> socketChannel.read(byteBuffers);</span><br><span class="line">                byteRead += l; <span class="comment">//累计读取的字节数</span></span><br><span class="line">                System.out.println(<span class="string">&quot;byteRead = &quot;</span> + byteRead);</span><br><span class="line">                <span class="comment">//使用流打印,看看当前的这个 buffer 的 position 和 limit</span></span><br><span class="line">                Arrays.asList(byteBuffers).stream().map(buffer -&gt; <span class="string">&quot;position = &quot;</span> + buffer.position() + <span class="string">&quot;, limit = &quot;</span> + buffer.limit()).forEach(System.out::println);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将所有的 buffer 进行 flip</span></span><br><span class="line">            Arrays.asList(byteBuffers).forEach(buffer -&gt; buffer.flip());</span><br><span class="line">            <span class="comment">//将数据读出显示到客户端</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">byteWirte</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (byteWirte &lt; messageLength) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> socketChannel.write(byteBuffers);<span class="comment">//</span></span><br><span class="line">                byteWirte += l;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//将所有的buffer进行clear</span></span><br><span class="line">            Arrays.asList(byteBuffers).forEach(buffer -&gt; &#123;</span><br><span class="line">                buffer.clear();</span><br><span class="line">            &#125;);</span><br><span class="line">            </span><br><span class="line">            System.out.println(<span class="string">&quot;byteRead = &quot;</span> + byteRead + <span class="string">&quot;, byteWrite = &quot;</span> + byteWirte + <span class="string">&quot;, messagelength = &quot;</span> + messageLength);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Selector（选择器）"><a href="#Selector（选择器）" class="headerlink" title="Selector（选择器）"></a>Selector（选择器）</h2><h3 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li><code>Java</code> 的 <code>NIO</code>，用非阻塞的 <code>IO</code> 方式。可以用一个线程，处理多个的客户端连接，就会使用到 <code>Selector</code>（选择器）。</li><li><code>Selector</code> 能够检测多个注册的通道上是否有事件发生（注意：多个 <code>Channel</code> 以事件的方式可以注册到同一个 <code>Selector</code>），如果有事件发生，便获取事件然后针对每个事件进行相应的处理。这样就可以只用一个单线程去管理多个通道，也就是管理多个连接和请求。</li><li>只有在连接&#x2F;通道真正有读写事件发生时，才会进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程。</li><li>避免了多线程之间的上下文切换导致的开销。</li></ol><h3 id="Selector-示意图和特点说明"><a href="#Selector-示意图和特点说明" class="headerlink" title="Selector 示意图和特点说明"></a>Selector 示意图和特点说明</h3><img src="https://npm.elemecdn.com/youthlql@1.0.0/netty/introduction/chapter_001/0017.png"/><p>说明如下：</p><ol><li><code>Netty</code> 的 <code>IO</code> 线程 <code>NioEventLoop</code> 聚合了 <code>Selector</code>（选择器，也叫多路复用器），可以同时并发处理成百上千个客户端连接。</li><li>当线程从某客户端 <code>Socket</code> 通道进行读写数据时，若没有数据可用时，该线程可以进行其他任务。</li><li>线程通常将非阻塞 <code>IO</code> 的空闲时间用于在其他通道上执行 <code>IO</code> 操作，所以单独的线程可以管理多个输入和输出通道。</li><li>由于读写操作都是非阻塞的，这就可以充分提升 <code>IO</code> 线程的运行效率，避免由于频繁 <code>I/O</code> 阻塞导致的线程挂起。</li><li>一个 <code>I/O</code> 线程可以并发处理 <code>N</code> 个客户端连接和读写操作，这从根本上解决了传统同步阻塞 <code>I/O</code> 一连接一线程模型，架构的性能、弹性伸缩能力和可靠性都得到了极大的提升。</li></ol><h3 id="Selector-类相关方法"><a href="#Selector-类相关方法" class="headerlink" title="Selector 类相关方法"></a>Selector 类相关方法</h3><img src="https://npm.elemecdn.com/youthlql@1.0.0/netty/introduction/chapter_001/0018.png"/><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li><code>NIO</code> 中的 <code>ServerSocketChannel</code> 功能类似 <code>ServerSocket</code>、<code>SocketChannel</code> 功能类似 <code>Socket</code>。</li><li><code>Selector</code> 相关方法说明<ul><li><code>selector.select();</code> &#x2F;&#x2F;阻塞</li><li><code>selector.select(1000);</code> &#x2F;&#x2F;阻塞 1000 毫秒，在 1000 毫秒后返回</li><li><code>selector.wakeup();</code> &#x2F;&#x2F;唤醒 selector</li><li><code>selector.selectNow();</code> &#x2F;&#x2F;不阻塞，立马返还</li></ul></li></ol><h2 id="NIO-非阻塞网络编程原理分析图"><a href="#NIO-非阻塞网络编程原理分析图" class="headerlink" title="NIO 非阻塞网络编程原理分析图"></a>NIO 非阻塞网络编程原理分析图</h2><p><code>NIO</code> 非阻塞网络编程相关的（<code>Selector</code>、<code>SelectionKey</code>、<code>ServerScoketChannel</code> 和 <code>SocketChannel</code>）关系梳理图</p><img src="https://npm.elemecdn.com/youthlql@1.0.0/netty/introduction/chapter_001/0019.png"/><p>对上图的说明：</p><ol><li>当客户端连接时，会通过 <code>ServerSocketChannel</code> 得到 <code>SocketChannel</code>。</li><li><code>Selector</code> 进行监听 <code>select</code> 方法，返回有事件发生的通道的个数。</li><li>将 <code>socketChannel</code> 注册到 <code>Selector</code> 上，<code>register(Selector sel, int ops)</code>，一个 <code>Selector</code> 上可以注册多个 <code>SocketChannel</code>。</li><li>注册后返回一个 <code>SelectionKey</code>，会和该 <code>Selector</code> 关联（集合）。</li><li>进一步得到各个 <code>SelectionKey</code>（有事件发生）。</li><li>在通过 <code>SelectionKey</code> 反向获取 <code>SocketChannel</code>，方法 <code>channel()</code>。</li><li>可以通过得到的 <code>channel</code>，完成业务处理。</li><li>直接看后面代码吧</li></ol><h2 id="NIO-非阻塞网络编程快速入门"><a href="#NIO-非阻塞网络编程快速入门" class="headerlink" title="NIO 非阻塞网络编程快速入门"></a>NIO 非阻塞网络编程快速入门</h2><p>案例：</p><ol><li>编写一个 <code>NIO</code> 入门案例，实现服务器端和客户端之间的数据简单通讯（非阻塞）</li><li>目的：理解 <code>NIO</code> 非阻塞网络编程机制</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NIOServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建ServerSocketChannel -&gt; ServerSocket</span></span><br><span class="line"></span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">serverSocketChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//得到一个Selecor对象</span></span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//绑定一个端口6666, 在服务器端监听</span></span><br><span class="line">        serverSocketChannel.socket().bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">6666</span>));</span><br><span class="line">        <span class="comment">//设置为非阻塞</span></span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把 serverSocketChannel 注册到  selector 关心 事件为 OP_ACCEPT       pos_1</span></span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;注册后的selectionkey 数量=&quot;</span> + selector.keys().size()); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//循环等待客户端连接</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//这里我们等待1秒，如果没有事件发生, 返回</span></span><br><span class="line">            <span class="keyword">if</span>(selector.select(<span class="number">1000</span>) == <span class="number">0</span>) &#123; <span class="comment">//没有事件发生</span></span><br><span class="line">                System.out.println(<span class="string">&quot;服务器等待了1秒，无连接&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果返回的&gt;0, 就获取到相关的 selectionKey集合</span></span><br><span class="line">            <span class="comment">//1.如果返回的&gt;0， 表示已经获取到关注的事件</span></span><br><span class="line">            <span class="comment">//2. selector.selectedKeys() 返回关注事件的集合</span></span><br><span class="line">            <span class="comment">//   通过 selectionKeys 反向获取通道</span></span><br><span class="line">            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">            System.out.println(<span class="string">&quot;selectionKeys 数量 = &quot;</span> + selectionKeys.size());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//遍历 Set&lt;SelectionKey&gt;, 使用迭代器遍历</span></span><br><span class="line">            Iterator&lt;SelectionKey&gt; keyIterator = selectionKeys.iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (keyIterator.hasNext()) &#123;</span><br><span class="line">                <span class="comment">//获取到SelectionKey</span></span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> keyIterator.next();</span><br><span class="line">                <span class="comment">//根据key 对应的通道发生的事件做相应处理</span></span><br><span class="line">                <span class="keyword">if</span>(key.isAcceptable()) &#123; <span class="comment">//如果是 OP_ACCEPT, 有新的客户端连接</span></span><br><span class="line">                    <span class="comment">//该该客户端生成一个 SocketChannel</span></span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> serverSocketChannel.accept();</span><br><span class="line">                    System.out.println(<span class="string">&quot;客户端连接成功 生成了一个 socketChannel &quot;</span> + socketChannel.hashCode());</span><br><span class="line">                    <span class="comment">//将  SocketChannel 设置为非阻塞</span></span><br><span class="line">                    socketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                    <span class="comment">//将socketChannel 注册到selector, 关注事件为 OP_READ， 同时给socketChannel</span></span><br><span class="line">                    <span class="comment">//关联一个Buffer</span></span><br><span class="line">                    socketChannel.register(selector, SelectionKey.OP_READ, ByteBuffer.allocate(<span class="number">1024</span>));</span><br><span class="line"></span><br><span class="line">                    System.out.println(<span class="string">&quot;客户端连接后 ，注册的selectionkey 数量=&quot;</span> + selector.keys().size()); <span class="comment">//2,3,4..</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(key.isReadable()) &#123;  <span class="comment">//发生 OP_READ</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//通过key 反向获取到对应channel</span></span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (SocketChannel)key.channel();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//获取到该channel关联的buffer</span></span><br><span class="line">                    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> (ByteBuffer)key.attachment();</span><br><span class="line">                    channel.read(buffer);</span><br><span class="line">                    System.out.println(<span class="string">&quot;form 客户端 &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(buffer.array()));</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//手动从集合中移动当前的selectionKey, 防止重复操作</span></span><br><span class="line">                keyIterator.remove();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>pos1：</p><p>1、对操作系统有一定了解的同学，就会大概知道这里监听的是一个Accept通道。这个通道的<br>作用就是监听，实际建立连接了还会有一个通道。<br>2、简单说一下为什么。因为客户端发请求的时候，服务器这边是肯定要先有一个监听通道，<br>监听某个端口是否有客户端要建立链接，如果有客户端想要建立链接，那么会再创建一个和<br>客户端真正通信的通道。<br>3、如果有其它客户端还想要建立链接，这个Accept监听端口监听到了，就会再创建几个真正<br>的通信通道。<br>4、也就是Server的一个端口可以建立多个TCP连接，因为IP层协议通过<br>目标地址+端口+源地址+源端口四个信息识别一个上下文</p><p><strong>顺便插一句嘴：因为学netty的过程中，发现计算机网络和操作系统蛮重要的，所以接下来会写几篇这方面的文章</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NIOClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//得到一个网络通道</span></span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> SocketChannel.open();</span><br><span class="line">        <span class="comment">//设置非阻塞</span></span><br><span class="line">        socketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        <span class="comment">//提供服务器端的ip 和 端口</span></span><br><span class="line">        <span class="type">InetSocketAddress</span> <span class="variable">inetSocketAddress</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6666</span>);</span><br><span class="line">        <span class="comment">//连接服务器</span></span><br><span class="line">        <span class="keyword">if</span> (!socketChannel.connect(inetSocketAddress)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (!socketChannel.finishConnect()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;因为连接需要时间，客户端不会阻塞，可以做其它工作..&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//...如果连接成功，就发送数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello, 尚硅谷~&quot;</span>;</span><br><span class="line">        <span class="comment">//Wraps a byte array into a buffer</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.wrap(str.getBytes());</span><br><span class="line">        <span class="comment">//发送数据，将 buffer 数据写入 channel</span></span><br><span class="line">        socketChannel.write(buffer);</span><br><span class="line">        System.in.read();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际执行效果可以复制代码去试下</p><h3 id="SelectionKey"><a href="#SelectionKey" class="headerlink" title="SelectionKey"></a>SelectionKey</h3><ol><li><code>SelectionKey</code>，表示 <code>Selector</code> 和网络通道的注册关系，共四种：<ul><li><code>int OP_ACCEPT</code>：有新的网络连接可以 <code>accept</code>，值为 <code>16</code></li><li><code>int OP_CONNECT</code>：代表连接已经建立，值为 <code>8</code></li><li><code>int OP_READ</code>：代表读操作，值为 <code>1</code></li><li><code>int OP_WRITE</code>：代表写操作，值为 <code>4</code></li></ul></li></ol><p>源码中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OP_READ</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OP_WRITE</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OP_CONNECT</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">3</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OP_ACCEPT</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br></pre></td></tr></table></figure><ol start="2"><li><code>SelectionKey</code> 相关方法</li></ol><img src="https://npm.elemecdn.com/youthlql@1.0.0/netty/introduction/chapter_001/0020.png"/><h3 id="ServerSocketChannel"><a href="#ServerSocketChannel" class="headerlink" title="ServerSocketChannel"></a>ServerSocketChannel</h3><ol><li><code>ServerSocketChannel</code> 在服务器端监听新的客户端 <code>Socket</code> 连接，负责监听，不负责实际的读写操作</li><li>相关方法如下</li></ol><img src="https://npm.elemecdn.com/youthlql@1.0.0/netty/introduction/chapter_001/0021.png"/><h3 id="SocketChannel"><a href="#SocketChannel" class="headerlink" title="SocketChannel"></a>SocketChannel</h3><ol><li><code>SocketChannel</code>，网络 <code>IO</code> 通道，<strong>具体负责进行读写操作</strong>。<code>NIO</code> 把缓冲区的数据写入通道，或者把通道里的数据读到缓冲区。</li><li>相关方法如下</li></ol><img src="https://npm.elemecdn.com/youthlql@1.0.0/netty/introduction/chapter_001/0022.png"/><h2 id="NIO网络编程应用实例-群聊系统"><a href="#NIO网络编程应用实例-群聊系统" class="headerlink" title="NIO网络编程应用实例 - 群聊系统"></a>NIO网络编程应用实例 - 群聊系统</h2><p>实例要求：</p><ol><li>编写一个 <code>NIO</code> 群聊系统，实现服务器端和客户端之间的数据简单通讯（非阻塞）</li><li>实现多人群聊</li><li>服务器端：可以监测用户上线，离线，并实现消息转发功能</li><li>客户端：通过 <code>Channel</code> 可以无阻塞发送消息给其它所有用户，同时可以接受其它用户发送的消息（有服务器转发得到）</li><li>目的：进一步理解 <code>NIO</code> 非阻塞网络编程机制</li><li>示意图分析和代码</li></ol><img src="https://npm.elemecdn.com/youthlql@1.0.0/netty/introduction/chapter_001/0023.png"/><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 服务端：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.atguigu.nio.groupchat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Channel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GroupChatServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义属性</span></span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line">    <span class="keyword">private</span> ServerSocketChannel listenChannel;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PORT</span> <span class="operator">=</span> <span class="number">6667</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="comment">//初始化工作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GroupChatServer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//得到选择器</span></span><br><span class="line">            selector = Selector.open();</span><br><span class="line">            <span class="comment">//ServerSocketChannel</span></span><br><span class="line">            listenChannel = ServerSocketChannel.open();</span><br><span class="line">            <span class="comment">//绑定端口</span></span><br><span class="line">            listenChannel.socket().bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(PORT));</span><br><span class="line">            <span class="comment">//设置非阻塞模式</span></span><br><span class="line">            listenChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">            <span class="comment">//将该 listenChannel 注册到 selector</span></span><br><span class="line">            listenChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listen</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//循环处理</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> selector.select();</span><br><span class="line">                <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123; <span class="comment">//有事件处理</span></span><br><span class="line">                    <span class="comment">// 遍历得到 selectionKey 集合</span></span><br><span class="line">                    Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line">                    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                        <span class="comment">//取出 selectionkey</span></span><br><span class="line">                        <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">                        <span class="comment">//监听到 accept</span></span><br><span class="line">                        <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                            <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> listenChannel.accept();</span><br><span class="line">                            sc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                            <span class="comment">//将该 sc 注册到 seletor</span></span><br><span class="line">                            sc.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                            <span class="comment">//提示</span></span><br><span class="line">                            System.out.println(sc.getRemoteAddress() + <span class="string">&quot; 上线 &quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (key.isReadable()) &#123;<span class="comment">//通道发送read事件，即通道是可读的状态</span></span><br><span class="line">                            <span class="comment">// 处理读(专门写方法..)</span></span><br><span class="line">                            readData(key);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//当前的 key 删除，防止重复处理</span></span><br><span class="line">                        iterator.remove();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;等待....&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//发生异常处理....</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取客户端消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readData</span><span class="params">(SelectionKey key)</span> &#123;</span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//得到 channel</span></span><br><span class="line">            channel = (SocketChannel) key.channel();</span><br><span class="line">            <span class="comment">//创建 buffer</span></span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> channel.read(buffer);</span><br><span class="line">            <span class="comment">//根据 count 的值做处理</span></span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//把缓存区的数据转成字符串</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer.array());</span><br><span class="line">                <span class="comment">//输出该消息</span></span><br><span class="line">                System.out.println(<span class="string">&quot;form客户端:&quot;</span> + msg);</span><br><span class="line">                <span class="comment">//向其它的客户端转发消息(去掉自己),专门写一个方法来处理</span></span><br><span class="line">                sendInfoToOtherClients(msg, channel);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(channel.getRemoteAddress() + <span class="string">&quot;离线了..&quot;</span>);</span><br><span class="line">                <span class="comment">//取消注册</span></span><br><span class="line">                key.cancel();</span><br><span class="line">                <span class="comment">//关闭通道</span></span><br><span class="line">                channel.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e2) &#123;</span><br><span class="line">                e2.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//转发消息给其它客户(通道)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sendInfoToOtherClients</span><span class="params">(String msg, SocketChannel self)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;服务器转发消息中...&quot;</span>);</span><br><span class="line">        <span class="comment">//遍历所有注册到 selector 上的 SocketChannel,并排除 self</span></span><br><span class="line">        <span class="keyword">for</span> (SelectionKey key : selector.keys()) &#123;</span><br><span class="line">            <span class="comment">//通过 key 取出对应的 SocketChannel</span></span><br><span class="line">            <span class="type">Channel</span> <span class="variable">targetChannel</span> <span class="operator">=</span> key.channel();</span><br><span class="line">            <span class="comment">//排除自己</span></span><br><span class="line">            <span class="keyword">if</span> (targetChannel <span class="keyword">instanceof</span> SocketChannel &amp;&amp; targetChannel != self) &#123;</span><br><span class="line">                <span class="comment">//转型</span></span><br><span class="line">                <span class="type">SocketChannel</span> <span class="variable">dest</span> <span class="operator">=</span> (SocketChannel) targetChannel;</span><br><span class="line">                <span class="comment">//将 msg 存储到 buffer</span></span><br><span class="line">                <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.wrap(msg.getBytes());</span><br><span class="line">                <span class="comment">//将 buffer 的数据写入通道</span></span><br><span class="line">                dest.write(buffer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建服务器对象</span></span><br><span class="line">        <span class="type">GroupChatServer</span> <span class="variable">groupChatServer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GroupChatServer</span>();</span><br><span class="line">        groupChatServer.listen();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.atguigu.nio.groupchat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GroupChatClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义相关的属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">HOST</span> <span class="operator">=</span> <span class="string">&quot;127.0.0.1&quot;</span>;<span class="comment">//服务器的ip</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PORT</span> <span class="operator">=</span> <span class="number">6667</span>;<span class="comment">//服务器端口</span></span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line">    <span class="keyword">private</span> SocketChannel socketChannel;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器,完成初始化工作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GroupChatClient</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        </span><br><span class="line">        selector = Selector.open();</span><br><span class="line">        <span class="comment">//连接服务器</span></span><br><span class="line">        socketChannel = SocketChannel.open(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(HOST, PORT));</span><br><span class="line">        <span class="comment">//设置非阻塞</span></span><br><span class="line">        socketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        <span class="comment">//将 channel 注册到selector</span></span><br><span class="line">        socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">        <span class="comment">//得到 username</span></span><br><span class="line">        username = socketChannel.getLocalAddress().toString().substring(<span class="number">1</span>);</span><br><span class="line">        System.out.println(username + <span class="string">&quot; is ok...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向服务器发送消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendInfo</span><span class="params">(String info)</span> &#123;</span><br><span class="line">        info = username + <span class="string">&quot; 说：&quot;</span> + info;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socketChannel.write(ByteBuffer.wrap(info.getBytes()));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取从服务器端回复的消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">readChannels</span> <span class="operator">=</span> selector.select();</span><br><span class="line">            <span class="keyword">if</span> (readChannels &gt; <span class="number">0</span>) &#123;<span class="comment">//有可以用的通道</span></span><br><span class="line">                Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line">                <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                    <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">                    <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                        <span class="comment">//得到相关的通道</span></span><br><span class="line">                        <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">                        <span class="comment">//得到一个 Buffer</span></span><br><span class="line">                        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                        <span class="comment">//读取</span></span><br><span class="line">                        sc.read(buffer);</span><br><span class="line">                        <span class="comment">//把读到的缓冲区的数据转成字符串</span></span><br><span class="line">                        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer.array());</span><br><span class="line">                        System.out.println(msg.trim());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                iterator.remove(); <span class="comment">//删除当前的 selectionKey,防止重复操作</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//System.out.println(&quot;没有可以用的通道...&quot;);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//启动我们客户端</span></span><br><span class="line">        <span class="type">GroupChatClient</span> <span class="variable">chatClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GroupChatClient</span>();</span><br><span class="line">        <span class="comment">//启动一个线程,每个 3 秒，读取从服务器发送数据</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    chatClient.readInfo();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.currentThread().sleep(<span class="number">3000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送数据给服务器端</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNextLine()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">            chatClient.sendInfo(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="NIO与零拷贝"><a href="#NIO与零拷贝" class="headerlink" title="NIO与零拷贝"></a>NIO与零拷贝</h2><blockquote><p>1、尚硅谷这里的零拷贝感觉讲的感觉有点问题，但是为了笔记的完整性，任然保留了这里的笔记。不过笔者考虑再写一篇零拷贝。</p><p>2、而且这里课件的图也看不太清</p><p>3、读者可以将我写的零拷贝和尚硅谷这里讲的零拷贝对照着看，取长补短</p></blockquote><h3 id="零拷贝基本介绍"><a href="#零拷贝基本介绍" class="headerlink" title="零拷贝基本介绍"></a>零拷贝基本介绍</h3><ol><li>零拷贝是网络编程的关键，很多性能优化都离不开。</li><li>在 <code>Java</code> 程序中，常用的零拷贝有 <code>mmap</code>（内存映射）和 <code>sendFile</code>。那么，他们在 <code>OS</code> 里，到底是怎么样的一个的设计？我们分析 <code>mmap</code> 和 <code>sendFile</code> 这两个零拷贝</li><li>另外我们看下 <code>NIO</code> 中如何使用零拷贝</li></ol><h3 id="传统-IO-数据读写"><a href="#传统-IO-数据读写" class="headerlink" title="传统 IO 数据读写"></a>传统 IO 数据读写</h3><p><code>Java</code> 传统 <code>IO</code> 和网络编程的一段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line"><span class="type">RandomAccessFile</span> <span class="variable">raf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(file, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">byte</span>[] arr = <span class="keyword">new</span> <span class="title class_">byte</span>[(<span class="type">int</span>) file.length()];</span><br><span class="line">raf.read(arr);</span><br><span class="line"></span><br><span class="line"><span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8080</span>).accept();</span><br><span class="line">socket.getOutputStream().write(arr);</span><br></pre></td></tr></table></figure><h3 id="传统-IO-模型"><a href="#传统-IO-模型" class="headerlink" title="传统 IO 模型"></a>传统 IO 模型</h3><img src="https://npm.elemecdn.com/youthlql@1.0.0/netty/introduction/chapter_001/0024.png"/><p><strong>DMA</strong>：<code>direct memory access</code> 直接内存拷贝（不使用 <code>CPU</code>）</p><h3 id="mmap-优化"><a href="#mmap-优化" class="headerlink" title="mmap 优化"></a>mmap 优化</h3><ol><li><code>mmap</code> 通过内存映射，将文件映射到内核缓冲区，同时，用户空间可以共享内核空间的数据。这样，在进行网络传输时，就可以减少内核空间到用户空间的拷贝次数。如下图</li><li><code>mmap</code> 示意图</li></ol><img src="https://npm.elemecdn.com/youthlql@1.0.0/netty/introduction/chapter_001/0025.png"/><h3 id="sendFile-优化"><a href="#sendFile-优化" class="headerlink" title="sendFile 优化"></a>sendFile 优化</h3><ol><li><code>Linux2.1</code> 版本提供了 <code>sendFile</code> 函数，其基本原理如下：数据根本不经过用户态，直接从内核缓冲区进入到 <code>SocketBuffer</code>，同时，由于和用户态完全无关，就减少了一次上下文切换</li><li>示意图和小结</li></ol><img src="https://npm.elemecdn.com/youthlql@1.0.0/netty/introduction/chapter_001/0026.png"/><ol start="3"><li>提示：零拷贝从操作系统角度，是没有 <code>cpu</code> 拷贝</li><li><code>Linux在2.4</code> 版本中，做了一些修改，避免了从内核缓冲区拷贝到 <code>Socketbuffer</code> 的操作，直接拷贝到协议栈，从而再一次减少了数据拷贝。具体如下图和小结：</li></ol><img src="https://npm.elemecdn.com/youthlql@1.0.0/netty/introduction/chapter_001/0027.png"/><ol start="5"><li>这里其实有一次 <code>cpu</code> 拷贝 <code>kernel buffer</code> -&gt; <code>socket buffer</code> 但是，拷贝的信息很少，比如 <code>lenght</code>、<code>offset</code> 消耗低，可以忽略</li></ol><h3 id="零拷贝的再次理解"><a href="#零拷贝的再次理解" class="headerlink" title="零拷贝的再次理解"></a>零拷贝的再次理解</h3><ol><li>我们说零拷贝，是从操作系统的角度来说的。因为内核缓冲区之间，没有数据是重复的（只有 <code>kernel buffer</code> 有一份数据）。</li><li>零拷贝不仅仅带来更少的数据复制，还能带来其他的性能优势，例如更少的上下文切换，更少的 <code>CPU</code> 缓存伪共享以及无 <code>CPU</code> 校验和计算。</li></ol><h3 id="mmap-和-sendFile-的区别"><a href="#mmap-和-sendFile-的区别" class="headerlink" title="mmap 和 sendFile 的区别"></a>mmap 和 sendFile 的区别</h3><ol><li><code>mmap</code> 适合小数据量读写，<code>sendFile</code> 适合大文件传输。</li><li><code>mmap</code> 需要 <code>4</code> 次上下文切换，<code>3</code> 次数据拷贝；<code>sendFile</code> 需要 <code>3</code> 次上下文切换，最少 <code>2</code> 次数据拷贝。</li><li><code>sendFile</code> 可以利用 <code>DMA</code> 方式，减少 <code>CPU</code> 拷贝，<code>mmap</code> 则不能（必须从内核拷贝到 <code>Socket</code>缓冲区）。</li></ol><h3 id="NIO-零拷贝案例"><a href="#NIO-零拷贝案例" class="headerlink" title="NIO 零拷贝案例"></a>NIO 零拷贝案例</h3><p>案例要求：</p><ol><li>使用传统的 <code>IO</code> 方法传递一个大文件</li><li>使用 <code>NIO</code> 零拷贝方式传递（<code>transferTo</code>）一个大文件</li><li>看看两种传递方式耗时时间分别是多少</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">NewIOServer.java</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.atguigu.nio.zerocopy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NewIOServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">InetSocketAddress</span> <span class="variable">address</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">7001</span>);</span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">serverSocketChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> serverSocketChannel.socket();</span><br><span class="line">        serverSocket.bind(address);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建buffer</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">4096</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> serverSocketChannel.accept();</span><br><span class="line">            <span class="type">int</span> <span class="variable">readcount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (-<span class="number">1</span> != readcount) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    readcount = socketChannel.read(byteBuffer);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                    <span class="comment">// ex.printStackTrace();</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                byteBuffer.rewind(); <span class="comment">//倒带 position = 0 mark 作废</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NewIOClient.java</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.atguigu.nio.zerocopy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NewIOClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> SocketChannel.open();</span><br><span class="line">        socketChannel.connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">7001</span>));</span><br><span class="line">        <span class="type">String</span> <span class="variable">filename</span> <span class="operator">=</span> <span class="string">&quot;protoc-3.6.1-win32.zip&quot;</span>;</span><br><span class="line">        <span class="comment">//得到一个文件channel</span></span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">fileChannel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filename).getChannel();</span><br><span class="line">        <span class="comment">//准备发送</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//在 linux 下一个 transferTo 方法就可以完成传输</span></span><br><span class="line">        <span class="comment">//在 windows 下一次调用 transferTo 只能发送 8m, 就需要分段传输文件,而且要主要</span></span><br><span class="line">        <span class="comment">//传输时的位置=》课后思考...</span></span><br><span class="line">        <span class="comment">//transferTo 底层使用到零拷贝</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">transferCount</span> <span class="operator">=</span> fileChannel.transferTo(<span class="number">0</span>, fileChannel.size(), socketChannel);</span><br><span class="line">        System.out.println(<span class="string">&quot;发送的总的字节数 = &quot;</span> + transferCount + <span class="string">&quot; 耗时: &quot;</span> + (System.currentTimeMillis() - startTime));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭</span></span><br><span class="line">        fileChannel.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Java-AIO-基本介绍"><a href="#Java-AIO-基本介绍" class="headerlink" title="Java AIO 基本介绍"></a>Java AIO 基本介绍</h2><ol><li><code>JDK7</code> 引入了 <code>AsynchronousI/O</code>，即 <code>AIO</code>。在进行 <code>I/O</code> 编程中，常用到两种模式：<code>Reactor</code> 和 <code>Proactor</code>。<code>Java</code> 的 <code>NIO</code> 就是 <code>Reactor</code>，当有事件触发时，服务器端得到通知，进行相应的处理</li><li><code>AIO</code> 即 <code>NIO2.0</code>，叫做异步不阻塞的 <code>IO</code>。<code>AIO</code> 引入异步通道的概念，采用了 <code>Proactor</code> 模式，简化了程序编写，有效的请求才启动线程，它的特点是先由操作系统完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时间较长的应用</li><li>目前 <code>AIO</code> 还没有广泛应用，<code>Netty</code> 也是基于 <code>NIO</code>，而不是 <code>AIO</code>，因此我们就不详解 <code>AIO</code> 了，有兴趣的同学可以参考<a href="http://www.52im.net/thread-306-1-1.html">《Java新一代网络编程模型AIO原理及Linux系统AIO介绍》</a></li></ol><h2 id="BIO、NIO、AIO-对比表"><a href="#BIO、NIO、AIO-对比表" class="headerlink" title="BIO、NIO、AIO 对比表"></a>BIO、NIO、AIO 对比表</h2><table><thead><tr><th align="center"></th><th align="center">BIO</th><th align="center">NIO</th><th align="center">AIO</th></tr></thead><tbody><tr><td align="center">IO模型</td><td align="center">同步阻塞</td><td align="center">同步非阻塞（多路复用）</td><td align="center">异步非阻塞</td></tr><tr><td align="center">编程难度</td><td align="center">简单</td><td align="center">复杂</td><td align="center">复杂</td></tr><tr><td align="center">可靠性</td><td align="center">差</td><td align="center">好</td><td align="center">好</td></tr><tr><td align="center">吞吐量</td><td align="center">低</td><td align="center">高</td><td align="center">高</td></tr></tbody></table><p><strong>举例说明</strong> </p><ol><li>同步阻塞：到理发店理发，就一直等理发师，直到轮到自己理发。</li><li>同步非阻塞：到理发店理发，发现前面有其它人理发，给理发师说下，先干其他事情，一会过来看是否轮到自己.</li><li>异步非阻塞：给理发师打电话，让理发师上门服务，自己干其它事情，理发师自己来家给你理发</li></ol>]]></content>
      
      
      <categories>
          
          <category> Netty </category>
          
          <category> 入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GO语言--上</title>
      <link href="/archives/83619254.html"/>
      <url>/archives/83619254.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="go语言了解-上"><a href="#go语言了解-上" class="headerlink" title="go语言了解-上"></a>go语言了解-上</h2><h4 id="1-Go-语言的基础组成有以下几个部分："><a href="#1-Go-语言的基础组成有以下几个部分：" class="headerlink" title="1.Go 语言的基础组成有以下几个部分："></a>1.Go 语言的基础组成有以下几个部分：</h4><ul><li>包声明</li><li>引入包</li><li>函数</li><li>变量</li><li>语句 &amp; 表达式</li><li>注释</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">/** 这是我的第一个go程序 */</span></span><br><span class="line">fmt.Print(<span class="string">&quot;Hello World!!!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1). package main 代表此文件为一个可以单独执行的文件<br>2). 第二行的import “fmt” 代表引入一个fmt包，此包可以进行io输入出<br>3). 第三行的func main() 通常为单个可执行文件的第一行 有init先执行这个，相当于Java中main方法，init相当于静态初始化</p><h4 id="2-GO-语言程序的执行"><a href="#2-GO-语言程序的执行" class="headerlink" title="2.GO 语言程序的执行"></a>2.GO 语言程序的执行</h4><h5 id="1-go-run-hello-go"><a href="#1-go-run-hello-go" class="headerlink" title="1). go run hello.go"></a>1). go run hello.go</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>). <span class="keyword">go</span> build hello.<span class="keyword">go</span>  ./hello</span><br></pre></td></tr></table></figure><h4 id="3-语法基础"><a href="#3-语法基础" class="headerlink" title="3.语法基础"></a>3.语法基础</h4><h5 id="1-go标记"><a href="#1-go标记" class="headerlink" title="1). go标记"></a>1). go标记</h5><p>Go 程序可以由多个标记组成，可以是关键字，标识符，常量，字符串，符号。如以下 GO 语句由 6 个标记组成：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="string">&quot;Hello, World!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">6</span> 个标记是(每行一个)：</span><br><span class="line"><span class="number">1.</span> fmt</span><br><span class="line"><span class="number">2.</span> .</span><br><span class="line"><span class="number">3.</span> Println</span><br><span class="line"><span class="number">4.</span> (</span><br><span class="line"><span class="number">5.</span> <span class="string">&quot;Hello, World!&quot;</span></span><br><span class="line"><span class="number">6.</span> )</span><br></pre></td></tr></table></figure><h5 id="2-行分隔符"><a href="#2-行分隔符" class="headerlink" title="2). 行分隔符"></a>2). 行分隔符</h5><p>每一行为一条语句 不必使用分号分割</p><h5 id="3-注释"><a href="#3-注释" class="headerlink" title="3). 注释"></a>3). 注释</h5><p>注释这个基本上大同小异 &#x2F;&#x2F;  &#x2F;** *&#x2F;</p><h5 id="4-标识符"><a href="#4-标识符" class="headerlink" title="4). 标识符"></a>4). 标识符</h5><p>也基本上大同小异</p><h5 id="5-字符串连接"><a href="#5-字符串连接" class="headerlink" title="5). 字符串连接"></a>5). 字符串连接</h5><p>使用+连接</p><h5 id="6-关键字"><a href="#6-关键字" class="headerlink" title="6). 关键字"></a>6). 关键字</h5><table><thead><tr><th>关键字</th><th align="right">关键字</th><th align="center">关键字</th><th align="center">关键字</th><th align="center">关键字</th></tr></thead><tbody><tr><td>break</td><td align="right">default</td><td align="center">func</td><td align="center">interface</td><td align="center">select</td></tr><tr><td>case</td><td align="right">defer</td><td align="center">go</td><td align="center">map</td><td align="center">struct</td></tr><tr><td>chan</td><td align="right">else</td><td align="center">goto</td><td align="center">package</td><td align="center">switch</td></tr><tr><td>const</td><td align="right">fallthrough</td><td align="center">if</td><td align="center">range</td><td align="center">type</td></tr><tr><td>continue</td><td align="right">for</td><td align="center">import</td><td align="center">return</td><td align="center">var</td></tr></tbody></table><h5 id="7-Go-语言的空格"><a href="#7-Go-语言的空格" class="headerlink" title="7). Go 语言的空格"></a>7). Go 语言的空格</h5><p>合理使用空格让代码变得更加优雅哦</p><h5 id="8-格式化字符串"><a href="#8-格式化字符串" class="headerlink" title="8). 格式化字符串"></a>8). 格式化字符串</h5><p>Go 语言中使用 fmt.Sprintf 或 fmt.Printf 格式化字符串并赋值给新串</p><ul><li>Sprintf 根据格式化参数生成格式化的字符串并返回该字符串。</li><li>Printf 根据格式化参数生成格式化的字符串并写入标准输出。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// d%表示整型数字， s%表示字符串</span></span><br><span class="line"><span class="keyword">var</span> fmtNums = <span class="number">123</span></span><br><span class="line"><span class="keyword">var</span> fmtDate = <span class="string">&quot;2022-12-12&quot;</span></span><br><span class="line"><span class="keyword">var</span> fmtStr = <span class="string">&quot;fmtStr=%d&amp;&amp;date=%s&quot;</span></span><br><span class="line">fmtStr = fmt.Sprintf(fmtStr, fmtNums, fmtDate)</span><br><span class="line">fmt.Println(fmtStr)</span><br></pre></td></tr></table></figure><h4 id="4-语言类型"><a href="#4-语言类型" class="headerlink" title="4. 语言类型"></a>4. 语言类型</h4><table><thead><tr><th>序号</th><th align="center">类型和描述</th></tr></thead><tbody><tr><td>1</td><td align="center">布尔型布尔型的值只可以是常量 true 或者 false。一个简单的例子：var b bool &#x3D; true。</td></tr><tr><td>2</td><td align="center">数字类型整型 int 和浮点型float32、float64，Go语言支持整型和浮点型数字，并且支持复数，其中位的运算采用补码。</td></tr><tr><td>3</td><td align="center">字符串类型:字符串就是一串固定长度的字符连接起来的字符序列。Go的字符串是由单个字节连接起来的。Go 语言的字符串的字节使用 UTF-8 编码标识 Unicode 文本。</td></tr><tr><td>4</td><td align="center">派生类型:包括：(a) 指针类型（Pointer）(b) 数组类型(c) 结构化类型(struct)(d) Channel 类型(e) 函数类型(f) 切片类型(g) 接口类型（interface）(h) Map 类型</td></tr></tbody></table><h5 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h5><table><thead><tr><th>序号</th><th align="center">类型和描述</th></tr></thead><tbody><tr><td>1</td><td align="center">uint8无符号 8 位整型 (0 到 255)</td></tr><tr><td>2</td><td align="center">uint16无符号 16 位整型 (0 到 65535)</td></tr><tr><td>3</td><td align="center">uint32无符号 32 位整型 (0 到 4294967295)</td></tr><tr><td>4</td><td align="center">uint64无符号 64 位整型 (0 到 18446744073709551615)</td></tr><tr><td>5</td><td align="center">int8有符号 8 位整型 (-128 到 127)</td></tr><tr><td>6</td><td align="center">int16有符号 16 位整型 (-32768 到 32767)</td></tr><tr><td>7</td><td align="center">int32有符号 32 位整型 (-2147483648 到 2147483647)</td></tr><tr><td>8</td><td align="center">int64有符号 64 位整型 (-9223372036854775808 到 9223372036854775807)</td></tr></tbody></table><h6 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h6><table><thead><tr><th>序号</th><th align="center">类型和描述</th></tr></thead><tbody><tr><td>1</td><td align="center">float32 IEEE-754 32位浮点型数</td></tr><tr><td>2</td><td align="center">float64 IEEE-754 64位浮点型数</td></tr><tr><td>3</td><td align="center">complex64 32 位实数和虚数</td></tr><tr><td>4</td><td align="center">complex128 64 位实数和虚数</td></tr></tbody></table><h4 id="5-GO语言变量"><a href="#5-GO语言变量" class="headerlink" title="5.GO语言变量"></a>5.GO语言变量</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> identifier <span class="keyword">type</span>    单变量声明  </span><br><span class="line"><span class="keyword">var</span> identifier1, identifier2 <span class="keyword">type</span>  多变量声明</span><br></pre></td></tr></table></figure><p>如果变量已经使用 var 声明过了，再使用 :&#x3D; 声明变量，就产生编译错误，格式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> intVal <span class="type">int</span> </span><br><span class="line">intVal :=<span class="number">1</span> <span class="comment">// 这时候会产生编译错误，因为 intVal 已经声明，不需要重新声明</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">intVal := <span class="number">1</span> 相等于：</span><br><span class="line"><span class="keyword">var</span> intVal <span class="type">int</span> </span><br><span class="line">intVal =<span class="number">1</span> </span><br></pre></td></tr></table></figure><p>可以将 var f string &#x3D; “Runoob” 简写为 f :&#x3D; “Runoob”：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">实例</span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f := <span class="string">&quot;Runoob&quot;</span> <span class="comment">// var f string = &quot;Runoob&quot;</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多变量声明</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类型相同多个变量, 非全局变量</span></span><br><span class="line"><span class="keyword">var</span> vname1, vname2, vname3 <span class="keyword">type</span></span><br><span class="line">vname1, vname2, vname3 = v1, v2, v3</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> vname1, vname2, vname3 = v1, v2, v3 <span class="comment">// 和 python 很像,不需要显示声明类型，自动推断</span></span><br><span class="line"></span><br><span class="line">vname1, vname2, vname3 := v1, v2, v3 <span class="comment">// 出现在 := 左侧的变量不应该是已经被声明过的，否则会导致编译错误</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这种因式分解关键字的写法一般用于声明全局变量</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    vname1 v_type1</span><br><span class="line">    vname2 v_type2</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h5 id="值类型和引用类型"><a href="#值类型和引用类型" class="headerlink" title="值类型和引用类型"></a>值类型和引用类型</h5><p>所有像 int、float、bool 和 string 这些基本类型都属于值类型，使用这些类型的变量直接指向存在内存中的值：</p><p>当使用等号 &#x3D; 将一个变量的值赋值给另一个变量时，如：j &#x3D; i，实际上是在内存中将 i 的值进行了拷贝：</p><p>你可以通过 &amp;i 来获取变量 i 的内存地址，例如：0xf840000040（每次的地址都可能不一样）。</p><p>值类型变量的值存储在堆中。</p><p>内存地址会根据机器的不同而有所不同，甚至相同的程序在不同的机器上执行后也会有不同的内存地址。因为每台机器可能有不同的存储器布局，并且位置分配也可能不同。</p><p>更复杂的数据通常会需要使用多个字，这些数据一般使用引用类型保存。</p><p>一个引用类型的变量 r1 存储的是 r1 的值所在的内存地址（数字），或内存地址中第一个字所在的位置。</p><p>这个内存地址称之为指针，这个指针实际上也被存在另外的某一个值中。</p><p>同一个引用类型的指针指向的多个字可以是在连续的内存地址中（内存布局是连续的），这也是计算效率最高的一种存储形式；也可以将这些字分散存放在内存中，每个字都指示了下一个字所在的内存地址。</p><p>当使用赋值语句 r2 &#x3D; r1 时，只有引用（地址）被复制。</p><p>如果 r1 的值被改变了，那么这个值的所有引用都会指向被修改后的内容，在这个例子中，r2 也会受到影响。</p><h5 id="简短形式，使用-x3D-赋值操作符"><a href="#简短形式，使用-x3D-赋值操作符" class="headerlink" title="简短形式，使用 :&#x3D; 赋值操作符"></a>简短形式，使用 :&#x3D; 赋值操作符</h5><p>我们知道可以在变量的初始化时省略变量的类型而由系统自动推断，声明语句写上 var 关键字其实是显得有些多余了，因此我们可以将它们简写为 a :&#x3D; 50 或 b :&#x3D; false。</p><p>a 和 b 的类型（int 和 bool）将由编译器自动推断。</p><p>这是使用变量的首选形式，但是它只能被用在函数体内，而不可以用于全局变量的声明与赋值。使用操作符 :&#x3D; 可以高效地创建一个新的变量，称之为初始化声明。</p><h6 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h6><p>如果在相同的代码块中，我们不可以再次对于相同名称的变量使用初始化声明，例如：a :&#x3D; 20 就是不被允许的，编译器会提示错误 no new variables on left side of :&#x3D;，但是 a &#x3D; 20 是可以的，因为这是给相同的变量赋予一个新的值。</p><p>如果你在定义变量 a 之前使用它，则会得到编译错误 undefined: a。</p><p>如果你声明了一个局部变量却没有在相同的代码块中使用它，同样会得到编译错误，例如下面这个例子当中的变量 a：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">实例</span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> a <span class="type">string</span> = <span class="string">&quot;abc&quot;</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;hello, world&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尝试编译这段代码将得到错误 a declared but not used。</p><p>此外，单纯地给 a 赋值也是不够的，这个值必须被使用，所以使用</p><p>fmt.Println(“hello, world”, a)<br>会移除错误。</p><p>但是全局变量是允许声明但不使用的。 同一类型的多个变量可以声明在同一行，如：</p><p>var a, b, c int<br>多变量可以在同一行进行赋值，如：</p><p>var a, b int<br>var c string<br>a, b, c &#x3D; 5, 7, “abc”<br>上面这行假设了变量 a，b 和 c 都已经被声明，否则的话应该这样使用：</p><p>a, b, c :&#x3D; 5, 7, “abc”<br>右边的这些值以相同的顺序赋值给左边的变量，所以 a 的值是 5， b 的值是 7，c 的值是 “abc”。</p><p>这被称为 并行 或 同时 赋值。</p><p>如果你想要交换两个变量的值，则可以简单地使用 a, b &#x3D; b, a，两个变量的类型必须是相同。</p><p>空白标识符 _ 也被用于抛弃值，如值 5 在：_, b &#x3D; 5, 7 中被抛弃。</p><p>_ 实际上是一个只写变量，你不能得到它的值。这样做是因为 Go 语言中你必须使用所有被声明的变量，但有时你并不需要使用从一个函数得到的所有返回值。</p><p>并行赋值也被用于当一个函数返回多个返回值时，比如这里的 val 和错误 err 是通过调用 Func1 函数同时得到：val, err &#x3D; Func1(var1)。</p><h4 id="6-Go-语言常量"><a href="#6-Go-语言常量" class="headerlink" title="6. Go 语言常量"></a>6. Go 语言常量</h4><p>定义格式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> identifier [<span class="keyword">type</span>] = value</span><br></pre></td></tr></table></figure><ul><li>显式类型定义： const b string &#x3D; “abc”</li><li>隐式类型定义： const b &#x3D; “abc”</li></ul><p>常量还可以用作枚举：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Unknown = <span class="number">0</span></span><br><span class="line">    Female = <span class="number">1</span></span><br><span class="line">    Male = <span class="number">2</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>常量可以用len(), cap(), unsafe.Sizeof()函数计算表达式的值。常量表达式中，函数必须是内置函数，否则编译不过</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;unsafe&quot;</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    a = <span class="string">&quot;abc&quot;</span></span><br><span class="line">    b = <span class="built_in">len</span>(a)</span><br><span class="line">    c = unsafe.Sizeof(a)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">println</span>(a, b, c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="iota-用法"><a href="#iota-用法" class="headerlink" title="iota 用法"></a>iota 用法</h6><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">实例</span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">const</span> (</span><br><span class="line">            a = <span class="literal">iota</span>   <span class="comment">//0</span></span><br><span class="line">            b          <span class="comment">//1</span></span><br><span class="line">            c          <span class="comment">//2</span></span><br><span class="line">            d = <span class="string">&quot;ha&quot;</span>   <span class="comment">//独立值，iota += 1</span></span><br><span class="line">            e          <span class="comment">//&quot;ha&quot;   iota += 1</span></span><br><span class="line">            f = <span class="number">100</span>    <span class="comment">//iota +=1</span></span><br><span class="line">            g          <span class="comment">//100  iota +=1</span></span><br><span class="line">            h = <span class="literal">iota</span>   <span class="comment">//7,恢复计数</span></span><br><span class="line">            i          <span class="comment">//8</span></span><br><span class="line">    )</span><br><span class="line">    fmt.Println(a,b,c,d,e,f,g,h,i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">以上实例运行结果为：</span><br><span class="line"></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> ha ha <span class="number">100</span> <span class="number">100</span> <span class="number">7</span> <span class="number">8</span></span><br></pre></td></tr></table></figure><p>再看个有趣的的 iota 实例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">实例</span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    i=<span class="number">1</span>&lt;&lt;<span class="literal">iota</span></span><br><span class="line">    j=<span class="number">3</span>&lt;&lt;<span class="literal">iota</span></span><br><span class="line">    k</span><br><span class="line">    l</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;i=&quot;</span>,i)</span><br><span class="line">    fmt.Println(<span class="string">&quot;j=&quot;</span>,j)</span><br><span class="line">    fmt.Println(<span class="string">&quot;k=&quot;</span>,k)</span><br><span class="line">    fmt.Println(<span class="string">&quot;l=&quot;</span>,l)</span><br><span class="line">&#125;</span><br><span class="line">以上实例运行结果为：</span><br><span class="line"></span><br><span class="line">i= <span class="number">1</span></span><br><span class="line">j= <span class="number">6</span></span><br><span class="line">k= <span class="number">12</span></span><br><span class="line">l= <span class="number">24</span></span><br></pre></td></tr></table></figure><p>iota 表示从 0 开始自动加 1，所以 i&#x3D;1&lt;&lt;0, j&#x3D;3&lt;&lt;1（&lt;&lt; 表示左移的意思），即：i&#x3D;1, j&#x3D;6，这没问题，关键在 k 和 l，从输出结果看 k&#x3D;3&lt;&lt;2，l&#x3D;3&lt;&lt;3。</p><p>简单表述:</p><p>i&#x3D;1：左移 0 位，不变仍为 1。<br>j&#x3D;3：左移 1 位，变为二进制 110，即 6。<br>k&#x3D;3：左移 2 位，变为二进制 1100，即 12。<br>l&#x3D;3：左移 3 位，变为二进制 11000，即 24。<br>注：&lt;&lt;n&#x3D;&#x3D;*(2^n)。</p><h4 id="7-Go语言运算符"><a href="#7-Go语言运算符" class="headerlink" title="7. Go语言运算符"></a>7. Go语言运算符</h4><p>算术运算符  关系运算符  逻辑运算符 基本一致不过多赘诉</p><h6 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h6><table><thead><tr><th>运算符</th><th align="center">描述</th><th>实例</th></tr></thead><tbody><tr><td>&amp;</td><td align="center">按位与运算符”&amp;”是双目运算符。 其功能是参与运算的两数各对应的二进位相与。</td><td>(A &amp; B) 结果为 12, 二进制为 0000 1100</td></tr><tr><td>|</td><td align="center">按位或运算符”|”是双目运算符。 其功能是参与运算的两数各对应的二进位相或</td><td>(A | B) 结果为 61, 二进制为 0011 1101</td></tr><tr><td>^</td><td align="center">按位异或运算符”^”是双目运算符。 其功能是参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1。</td><td>(A ^ B) 结果为 49, 二进制为 0011 0001</td></tr><tr><td>&lt;&lt;</td><td align="center">左移运算符”&lt;&lt;”是双目运算符。左移n位就是乘以2的n次方。 其功能把”&lt;&lt;”左边的运算数的各二进位全部左移若干位，由”&lt;&lt;”右边的数指定移动的位数，高位丢弃，低位补0。</td><td>A &lt;&lt; 2 结果为 240 ，二进制为 1111 0000</td></tr><tr><td>&gt;&gt;</td><td align="center">右移运算符”&gt;&gt;”是双目运算符。右移n位就是除以2的n次方。 其功能是把”&gt;&gt;”左边的运算数的各二进位全部右移若干位，”&gt;&gt;”右边的数指定移动的位数。</td><td>A &gt;&gt; 2 结果为 15 ，二进制为 0000 1111</td></tr></tbody></table><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">实例</span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> a <span class="type">uint</span> = <span class="number">60</span>      <span class="comment">/* 60 = 0011 1100 */</span>  </span><br><span class="line">   <span class="keyword">var</span> b <span class="type">uint</span> = <span class="number">13</span>      <span class="comment">/* 13 = 0000 1101 */</span></span><br><span class="line">   <span class="keyword">var</span> c <span class="type">uint</span> = <span class="number">0</span>          </span><br><span class="line"></span><br><span class="line">   c = a &amp; b       <span class="comment">/* 12 = 0000 1100 */</span></span><br><span class="line">   fmt.Printf(<span class="string">&quot;第一行 - c 的值为 %d\n&quot;</span>, c )</span><br><span class="line"></span><br><span class="line">   c = a | b       <span class="comment">/* 61 = 0011 1101 */</span></span><br><span class="line">   fmt.Printf(<span class="string">&quot;第二行 - c 的值为 %d\n&quot;</span>, c )</span><br><span class="line"></span><br><span class="line">   c = a ^ b       <span class="comment">/* 49 = 0011 0001 */</span></span><br><span class="line">   fmt.Printf(<span class="string">&quot;第三行 - c 的值为 %d\n&quot;</span>, c )</span><br><span class="line"></span><br><span class="line">   c = a &lt;&lt; <span class="number">2</span>     <span class="comment">/* 240 = 1111 0000 */</span></span><br><span class="line">   fmt.Printf(<span class="string">&quot;第四行 - c 的值为 %d\n&quot;</span>, c )</span><br><span class="line"></span><br><span class="line">   c = a &gt;&gt; <span class="number">2</span>     <span class="comment">/* 15 = 0000 1111 */</span></span><br><span class="line">   fmt.Printf(<span class="string">&quot;第五行 - c 的值为 %d\n&quot;</span>, c )</span><br><span class="line">&#125;</span><br><span class="line">以上实例运行结果：</span><br><span class="line"></span><br><span class="line">第一行 - c 的值为 <span class="number">12</span></span><br><span class="line">第二行 - c 的值为 <span class="number">61</span></span><br><span class="line">第三行 - c 的值为 <span class="number">49</span></span><br><span class="line">第四行 - c 的值为 <span class="number">240</span></span><br><span class="line">第五行 - c 的值为 <span class="number">15</span></span><br></pre></td></tr></table></figure><h6 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h6><table><thead><tr><th align="center">运算符</th><th align="center">描述</th><th align="center">实例</th></tr></thead><tbody><tr><td align="center">&#x3D;</td><td align="center">简单的赋值运算符，将一个表达式的值赋给一个左值</td><td align="center">C &#x3D; A + B 将 A + B  表达式结果赋值给 C</td></tr><tr><td align="center">+&#x3D;</td><td align="center">相加后再赋值</td><td align="center">C +&#x3D; A 等于 C &#x3D; C + A</td></tr><tr><td align="center">-&#x3D;</td><td align="center">相减后再赋值</td><td align="center">C -&#x3D; A 等于 C &#x3D; C - A</td></tr><tr><td align="center">*&#x3D;</td><td align="center">相乘后再赋值</td><td align="center">C *&#x3D; A 等于 C &#x3D; C * A</td></tr><tr><td align="center">&#x2F;&#x3D;</td><td align="center">相除后再赋值</td><td align="center">C &#x2F;&#x3D; A 等于 C &#x3D; C &#x2F; A</td></tr><tr><td align="center">%&#x3D;</td><td align="center">求余后再赋值</td><td align="center">C %&#x3D; A 等于 C &#x3D; C % A</td></tr><tr><td align="center">&lt;&lt;&#x3D;</td><td align="center">左移后赋值</td><td align="center">C &lt;&lt;&#x3D; 2 等于 C &#x3D; C &lt;&lt; 2</td></tr><tr><td align="center">&gt;&gt;&#x3D;</td><td align="center">右移后赋值</td><td align="center">C &gt;&gt;&#x3D; 2 等于 C &#x3D; C &gt;&gt; 2</td></tr><tr><td align="center">&amp;&#x3D;</td><td align="center">按位与后赋值</td><td align="center">C &amp;&#x3D; 2 等于 C &#x3D; C &amp; 2</td></tr><tr><td align="center">^&#x3D;</td><td align="center">按位异或后赋值</td><td align="center">C ^&#x3D; 2 等于 C &#x3D; C ^ 2</td></tr><tr><td align="center">|&#x3D;</td><td align="center">按位或后赋值</td><td align="center">C |&#x3D; 2 等于 C &#x3D; C | 2</td></tr></tbody></table><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">实例</span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> a <span class="type">int</span> = <span class="number">21</span></span><br><span class="line">   <span class="keyword">var</span> c <span class="type">int</span></span><br><span class="line"></span><br><span class="line">   c =  a</span><br><span class="line">   fmt.Printf(<span class="string">&quot;第 1 行 - =  运算符实例，c 值为 = %d\n&quot;</span>, c )</span><br><span class="line"></span><br><span class="line">   c +=  a</span><br><span class="line">   fmt.Printf(<span class="string">&quot;第 2 行 - += 运算符实例，c 值为 = %d\n&quot;</span>, c )</span><br><span class="line"></span><br><span class="line">   c -=  a</span><br><span class="line">   fmt.Printf(<span class="string">&quot;第 3 行 - -= 运算符实例，c 值为 = %d\n&quot;</span>, c )</span><br><span class="line"></span><br><span class="line">   c *=  a</span><br><span class="line">   fmt.Printf(<span class="string">&quot;第 4 行 - *= 运算符实例，c 值为 = %d\n&quot;</span>, c )</span><br><span class="line"></span><br><span class="line">   c /=  a</span><br><span class="line">   fmt.Printf(<span class="string">&quot;第 5 行 - /= 运算符实例，c 值为 = %d\n&quot;</span>, c )</span><br><span class="line"></span><br><span class="line">   c  = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">   c &lt;&lt;=  <span class="number">2</span></span><br><span class="line">   fmt.Printf(<span class="string">&quot;第 6行  - &lt;&lt;= 运算符实例，c 值为 = %d\n&quot;</span>, c )</span><br><span class="line"></span><br><span class="line">   c &gt;&gt;=  <span class="number">2</span></span><br><span class="line">   fmt.Printf(<span class="string">&quot;第 7 行 - &gt;&gt;= 运算符实例，c 值为 = %d\n&quot;</span>, c )</span><br><span class="line"></span><br><span class="line">   c &amp;=  <span class="number">2</span></span><br><span class="line">   fmt.Printf(<span class="string">&quot;第 8 行 - &amp;= 运算符实例，c 值为 = %d\n&quot;</span>, c )</span><br><span class="line"></span><br><span class="line">   c ^=  <span class="number">2</span></span><br><span class="line">   fmt.Printf(<span class="string">&quot;第 9 行 - ^= 运算符实例，c 值为 = %d\n&quot;</span>, c )</span><br><span class="line"></span><br><span class="line">   c |=  <span class="number">2</span></span><br><span class="line">   fmt.Printf(<span class="string">&quot;第 10 行 - |= 运算符实例，c 值为 = %d\n&quot;</span>, c )</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">以上实例运行结果：</span><br><span class="line"></span><br><span class="line">第 <span class="number">1</span> 行 - =  运算符实例，c 值为 = <span class="number">21</span></span><br><span class="line">第 <span class="number">2</span> 行 - += 运算符实例，c 值为 = <span class="number">42</span></span><br><span class="line">第 <span class="number">3</span> 行 - -= 运算符实例，c 值为 = <span class="number">21</span></span><br><span class="line">第 <span class="number">4</span> 行 - *= 运算符实例，c 值为 = <span class="number">441</span></span><br><span class="line">第 <span class="number">5</span> 行 - /= 运算符实例，c 值为 = <span class="number">21</span></span><br><span class="line">第 <span class="number">6</span>行  - &lt;&lt;= 运算符实例，c 值为 = <span class="number">800</span></span><br><span class="line">第 <span class="number">7</span> 行 - &gt;&gt;= 运算符实例，c 值为 = <span class="number">200</span></span><br><span class="line">第 <span class="number">8</span> 行 - &amp;= 运算符实例，c 值为 = <span class="number">0</span></span><br><span class="line">第 <span class="number">9</span> 行 - ^= 运算符实例，c 值为 = <span class="number">2</span></span><br><span class="line">第 <span class="number">10</span> 行 - |= 运算符实例，c 值为 = <span class="number">2</span></span><br></pre></td></tr></table></figure><h6 id="其他运算符"><a href="#其他运算符" class="headerlink" title="其他运算符"></a>其他运算符</h6><table><thead><tr><th align="center">运算符</th><th align="center">描述</th><th align="center">实例</th></tr></thead><tbody><tr><td align="center">&amp;</td><td align="center">返回变量存储地址</td><td align="center">&amp;a; 将给出变量的实际地址。</td></tr><tr><td align="center">*</td><td align="center">指针变量。</td><td align="center">*a; 是一个指针变量</td></tr></tbody></table><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">实例</span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> a <span class="type">int</span> = <span class="number">4</span></span><br><span class="line">   <span class="keyword">var</span> b <span class="type">int32</span></span><br><span class="line">   <span class="keyword">var</span> c <span class="type">float32</span></span><br><span class="line">   <span class="keyword">var</span> ptr *<span class="type">int</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 运算符实例 */</span></span><br><span class="line">   fmt.Printf(<span class="string">&quot;第 1 行 - a 变量类型为 = %T\n&quot;</span>, a );</span><br><span class="line">   fmt.Printf(<span class="string">&quot;第 2 行 - b 变量类型为 = %T\n&quot;</span>, b );</span><br><span class="line">   fmt.Printf(<span class="string">&quot;第 3 行 - c 变量类型为 = %T\n&quot;</span>, c );</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*  &amp; 和 * 运算符实例 */</span></span><br><span class="line">   ptr = &amp;a     <span class="comment">/* &#x27;ptr&#x27; 包含了 &#x27;a&#x27; 变量的地址 */</span></span><br><span class="line">   fmt.Printf(<span class="string">&quot;a 的值为  %d\n&quot;</span>, a);</span><br><span class="line">   fmt.Printf(<span class="string">&quot;*ptr 为 %d\n&quot;</span>, *ptr);</span><br><span class="line">&#125;</span><br><span class="line">以上实例运行结果：</span><br><span class="line"></span><br><span class="line">第 <span class="number">1</span> 行 - a 变量类型为 = <span class="type">int</span></span><br><span class="line">第 <span class="number">2</span> 行 - b 变量类型为 = <span class="type">int32</span></span><br><span class="line">第 <span class="number">3</span> 行 - c 变量类型为 = <span class="type">float32</span></span><br><span class="line">a 的值为  <span class="number">4</span></span><br><span class="line">*ptr 为 <span class="number">4</span></span><br></pre></td></tr></table></figure><h6 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h6><table><thead><tr><th align="center">优先级</th><th align="center">运算符</th></tr></thead><tbody><tr><td align="center">5</td><td align="center">* &#x2F; % &lt;&lt; &gt;&gt; &amp; &amp;^</td></tr><tr><td align="center">4</td><td align="center">+ - | ^</td></tr><tr><td align="center">3</td><td align="center">&#x3D;&#x3D; !&#x3D; &lt; &lt;&#x3D; &gt; &gt;&#x3D;</td></tr><tr><td align="center">2</td><td align="center">&amp;&amp;</td></tr><tr><td align="center">1</td><td align="center">||</td></tr></tbody></table><h4 id="8-Go-语言条件语句"><a href="#8-Go-语言条件语句" class="headerlink" title="8. Go 语言条件语句"></a>8. Go 语言条件语句</h4><p>和其他语言的条件控制基本一致，讲讲不一致的<br>1.Switch 的fallthrough<br>使用 fallthrough 会强制执行后面的 case 语句，fallthrough 不会判断下一条 case 的表达式结果是否为 true。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="literal">false</span>:</span><br><span class="line">            fmt.Println(<span class="string">&quot;1、case 条件语句为 false&quot;</span>)</span><br><span class="line">            <span class="keyword">fallthrough</span></span><br><span class="line">    <span class="keyword">case</span> <span class="literal">true</span>:</span><br><span class="line">            fmt.Println(<span class="string">&quot;2、case 条件语句为 true&quot;</span>)</span><br><span class="line">            <span class="keyword">fallthrough</span></span><br><span class="line">    <span class="keyword">case</span> <span class="literal">false</span>:</span><br><span class="line">            fmt.Println(<span class="string">&quot;3、case 条件语句为 false&quot;</span>)</span><br><span class="line">            <span class="keyword">fallthrough</span></span><br><span class="line">    <span class="keyword">case</span> <span class="literal">true</span>:</span><br><span class="line">            fmt.Println(<span class="string">&quot;4、case 条件语句为 true&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="literal">false</span>:</span><br><span class="line">            fmt.Println(<span class="string">&quot;5、case 条件语句为 false&quot;</span>)</span><br><span class="line">            <span class="keyword">fallthrough</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">            fmt.Println(<span class="string">&quot;6、默认 case&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">结果：</span><br><span class="line"><span class="number">2</span>、<span class="keyword">case</span> 条件语句为 <span class="literal">true</span></span><br><span class="line"><span class="number">3</span>、<span class="keyword">case</span> 条件语句为 <span class="literal">false</span></span><br><span class="line"><span class="number">4</span>、<span class="keyword">case</span> 条件语句为 <span class="literal">true</span></span><br></pre></td></tr></table></figure><ol><li>select 语句<br>select 是 Go 中的一个控制结构，类似于用于通信的 switch 语句。每个 case 必须是一个通信操作，要么是发送要么是接收。<br>select 随机执行一个可运行的 case。如果没有 case 可运行，它将阻塞，直到有 case 可运行。一个默认的子句应该总是可运行的。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> communication clause  :</span><br><span class="line">       statement(s);      </span><br><span class="line">    <span class="keyword">case</span> communication clause  :</span><br><span class="line">       statement(s);</span><br><span class="line">    <span class="comment">/* 你可以定义任意数量的 case */</span></span><br><span class="line">    <span class="keyword">default</span> : <span class="comment">/* 可选 */</span></span><br><span class="line">       statement(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>每个 case 都必须是一个通信</li><li>所有 channel 表达式都会被求值</li><li>所有被发送的表达式都会被求值</li><li>如果任意某个通信可以进行，它就执行，其他被忽略。</li><li>如果有多个 case 都可以运行，Select 会随机公平地选出一个执行。其他不会执行。<br>否则：<ul><li>如果有 default 子句，则执行该语句。</li><li>如果没有 default 子句，select 将阻塞，直到某个通信可以运行；Go 不会重新对 channel 或值进行求值。</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">实例</span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> c1, c2, c3 <span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line">   <span class="keyword">var</span> i1, i2 <span class="type">int</span></span><br><span class="line">   <span class="keyword">select</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> i1 = &lt;-c1:</span><br><span class="line">         fmt.Printf(<span class="string">&quot;received &quot;</span>, i1, <span class="string">&quot; from c1\n&quot;</span>)</span><br><span class="line">      <span class="keyword">case</span> c2 &lt;- i2:</span><br><span class="line">         fmt.Printf(<span class="string">&quot;sent &quot;</span>, i2, <span class="string">&quot; to c2\n&quot;</span>)</span><br><span class="line">      <span class="keyword">case</span> i3, ok := (&lt;-c3):  <span class="comment">// same as: i3, ok := &lt;-c3</span></span><br><span class="line">         <span class="keyword">if</span> ok &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;received &quot;</span>, i3, <span class="string">&quot; from c3\n&quot;</span>)</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;c3 is closed\n&quot;</span>)</span><br><span class="line">         &#125;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">         fmt.Printf(<span class="string">&quot;no communication\n&quot;</span>)</span><br><span class="line">   &#125;    </span><br><span class="line">&#125;</span><br><span class="line">以上代码执行结果为：</span><br><span class="line"></span><br><span class="line">no communication</span><br></pre></td></tr></table></figure><h4 id="9-Go-语言循环语句"><a href="#9-Go-语言循环语句" class="headerlink" title="9. Go 语言循环语句"></a>9. Go 语言循环语句</h4><h6 id="1-for"><a href="#1-for" class="headerlink" title="1.for"></a>1.for</h6><p>和 C 语言的 for 一样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> init; condition; post &#123; &#125;</span><br></pre></td></tr></table></figure><p>和 C 的 while 一样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> condition &#123; &#125;</span><br></pre></td></tr></table></figure><p>和 C 的 for(;;) 一样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123; &#125;</span><br></pre></td></tr></table></figure><ul><li>init： 一般为赋值表达式，给控制变量赋初值；</li><li>condition： 关系表达式或逻辑表达式，循环控制条件；</li><li>post： 一般为赋值表达式，给控制变量增量或减量。</li></ul><p>for语句执行过程如下：</p><p>1、先对表达式 1 赋初值；</p><p>2、判别赋值表达式 init 是否满足给定条件，若其值为真，满足循环条件，则执行循环体内语句，然后执行 post，进入第二次循环，再判别 condition；否则判断 condition 的值为假，不满足条件，就终止for循环，执行循环体外语句。</p><p>for 循环的 range 格式可以对 slice、map、数组、字符串等进行迭代循环。格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> oldMap &#123;</span><br><span class="line">    newMap[key] = value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码中的 key 和 value 是可以省略。</p><p>如果只想读取 key，格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> key := <span class="keyword">range</span> oldMap</span><br><span class="line">或者这样：</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key, _ := <span class="keyword">range</span> oldMap</span><br><span class="line"></span><br><span class="line">如果只想读取 value，格式如下：</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, value := <span class="keyword">range</span> oldMap</span><br></pre></td></tr></table></figure><p>计算 1 到 10 的数字之和：</p><p>实例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   sum := <span class="number">0</span></span><br><span class="line">      <span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= <span class="number">10</span>; i++ &#123;</span><br><span class="line">         sum += i</span><br><span class="line">      &#125;</span><br><span class="line">   fmt.Println(sum)</span><br><span class="line">&#125;</span><br><span class="line">输出结果为：</span><br><span class="line"></span><br><span class="line"><span class="number">55</span></span><br></pre></td></tr></table></figure><p>init 和 post 参数是可选的，我们可以直接省略它，类似 While 语句。</p><p>以下实例在 sum 小于 10 的时候计算 sum 自相加后的值：</p><p>实例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   sum := <span class="number">1</span></span><br><span class="line">   <span class="keyword">for</span> ; sum &lt;= <span class="number">10</span>; &#123;</span><br><span class="line">      sum += sum</span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Println(sum)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 这样写也可以，更像 While 语句形式</span></span><br><span class="line">   <span class="keyword">for</span> sum &lt;= <span class="number">10</span>&#123;</span><br><span class="line">      sum += sum</span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Println(sum)</span><br><span class="line">&#125;</span><br><span class="line">输出结果为：</span><br><span class="line"></span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">16</span></span><br></pre></td></tr></table></figure><p>无限循环:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">实例</span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   sum := <span class="number">0</span></span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      sum++ <span class="comment">// 无限循环下去</span></span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Println(sum) <span class="comment">// 无法输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>For-each range 循环</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">这种格式的循环可以对字符串、数组、切片等进行迭代输出元素。</span><br><span class="line"></span><br><span class="line">实例</span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   strings := []<span class="type">string</span>&#123;<span class="string">&quot;google&quot;</span>, <span class="string">&quot;runoob&quot;</span>&#125;</span><br><span class="line">   <span class="keyword">for</span> i, s := <span class="keyword">range</span> strings &#123;</span><br><span class="line">      fmt.Println(i, s)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   numbers := [<span class="number">6</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;</span><br><span class="line">   <span class="keyword">for</span> i,x:= <span class="keyword">range</span> numbers &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;第 %d 位 x 的值 = %d\n&quot;</span>, i,x)</span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br><span class="line">以上实例运行输出结果为:</span><br><span class="line"></span><br><span class="line"><span class="number">0</span> google</span><br><span class="line"><span class="number">1</span> runoob</span><br><span class="line">第 <span class="number">0</span> 位 x 的值 = <span class="number">1</span></span><br><span class="line">第 <span class="number">1</span> 位 x 的值 = <span class="number">2</span></span><br><span class="line">第 <span class="number">2</span> 位 x 的值 = <span class="number">3</span></span><br><span class="line">第 <span class="number">3</span> 位 x 的值 = <span class="number">5</span></span><br><span class="line">第 <span class="number">4</span> 位 x 的值 = <span class="number">0</span></span><br><span class="line">第 <span class="number">5</span> 位 x 的值 = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>for 循环的 range 格式可以省略 key 和 value，如下实例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">实例</span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    map1 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">float32</span>)</span><br><span class="line">    map1[<span class="number">1</span>] = <span class="number">1.0</span></span><br><span class="line">    map1[<span class="number">2</span>] = <span class="number">2.0</span></span><br><span class="line">    map1[<span class="number">3</span>] = <span class="number">3.0</span></span><br><span class="line">    map1[<span class="number">4</span>] = <span class="number">4.0</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 读取 key 和 value</span></span><br><span class="line">    <span class="keyword">for</span> key, value := <span class="keyword">range</span> map1 &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;key is: %d - value is: %f\n&quot;</span>, key, value)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取 key</span></span><br><span class="line">    <span class="keyword">for</span> key := <span class="keyword">range</span> map1 &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;key is: %d\n&quot;</span>, key)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取 value</span></span><br><span class="line">    <span class="keyword">for</span> _, value := <span class="keyword">range</span> map1 &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;value is: %f\n&quot;</span>, value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">以上实例运行输出结果为:</span><br><span class="line"></span><br><span class="line">key is: <span class="number">4</span> - value is: <span class="number">4.000000</span></span><br><span class="line">key is: <span class="number">1</span> - value is: <span class="number">1.000000</span></span><br><span class="line">key is: <span class="number">2</span> - value is: <span class="number">2.000000</span></span><br><span class="line">key is: <span class="number">3</span> - value is: <span class="number">3.000000</span></span><br><span class="line">key is: <span class="number">1</span></span><br><span class="line">key is: <span class="number">2</span></span><br><span class="line">key is: <span class="number">3</span></span><br><span class="line">key is: <span class="number">4</span></span><br><span class="line">value is: <span class="number">1.000000</span></span><br><span class="line">value is: <span class="number">2.000000</span></span><br><span class="line">value is: <span class="number">3.000000</span></span><br><span class="line">value is: <span class="number">4.000000</span></span><br></pre></td></tr></table></figure><h6 id="嵌套循环"><a href="#嵌套循环" class="headerlink" title="嵌套循环"></a>嵌套循环</h6><p>语法<br>以下为 Go 语言嵌套循环的格式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> [condition |  ( init; condition; increment ) | Range]</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">for</span> [condition |  ( init; condition; increment ) | Range]</span><br><span class="line">   &#123;</span><br><span class="line">      statement(s);</span><br><span class="line">   &#125;</span><br><span class="line">   statement(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">以下实例使用循环嵌套来输出 <span class="number">2</span> 到 <span class="number">100</span> 间的素数：</span><br><span class="line"></span><br><span class="line">实例</span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">/* 定义局部变量 */</span></span><br><span class="line">   <span class="keyword">var</span> i, j <span class="type">int</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> i=<span class="number">2</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">      <span class="keyword">for</span> j=<span class="number">2</span>; j &lt;= (i/j); j++ &#123;</span><br><span class="line">         <span class="keyword">if</span>(i%j==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 如果发现因子，则不是素数</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(j &gt; (i/j)) &#123;</span><br><span class="line">         fmt.Printf(<span class="string">&quot;%d  是素数\n&quot;</span>, i);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br><span class="line">以上实例运行输出结果为:</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>  是素数</span><br><span class="line"><span class="number">3</span>  是素数</span><br><span class="line"><span class="number">5</span>  是素数</span><br><span class="line"><span class="number">7</span>  是素数</span><br><span class="line"><span class="number">11</span>  是素数</span><br><span class="line"><span class="number">13</span>  是素数</span><br><span class="line"><span class="number">17</span>  是素数</span><br><span class="line"><span class="number">19</span>  是素数</span><br><span class="line"><span class="number">23</span>  是素数</span><br><span class="line"><span class="number">29</span>  是素数</span><br><span class="line"><span class="number">31</span>  是素数</span><br><span class="line"><span class="number">37</span>  是素数</span><br><span class="line"><span class="number">41</span>  是素数</span><br><span class="line"><span class="number">43</span>  是素数</span><br><span class="line"><span class="number">47</span>  是素数</span><br><span class="line"><span class="number">53</span>  是素数</span><br><span class="line"><span class="number">59</span>  是素数</span><br><span class="line"><span class="number">61</span>  是素数</span><br><span class="line"><span class="number">67</span>  是素数</span><br><span class="line"><span class="number">71</span>  是素数</span><br><span class="line"><span class="number">73</span>  是素数</span><br><span class="line"><span class="number">79</span>  是素数</span><br><span class="line"><span class="number">83</span>  是素数</span><br><span class="line"><span class="number">89</span>  是素数</span><br><span class="line"><span class="number">97</span>  是素数</span><br></pre></td></tr></table></figure><h6 id="循环控制语句"><a href="#循环控制语句" class="headerlink" title="循环控制语句"></a>循环控制语句</h6><p>1.break</p><ul><li>用于循环语句中跳出循环，并开始执行循环之后的语句。</li><li>break 在 switch（开关语句）中在执行一条 case 后跳出语句的作用。</li><li>在多重循环中，可以用标号 label 标出想 break 的循环。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不使用标记</span></span><br><span class="line">  fmt.Println(<span class="string">&quot;---- break ----&quot;</span>)</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++ &#123;</span><br><span class="line">     fmt.Printf(<span class="string">&quot;i: %d\n&quot;</span>, i)</span><br><span class="line">     <span class="keyword">for</span> i2 := <span class="number">11</span>; i2 &lt;= <span class="number">13</span>; i2++ &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;i2: %d\n&quot;</span>, i2)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用标记</span></span><br><span class="line">  fmt.Println(<span class="string">&quot;---- break label ----&quot;</span>)</span><br><span class="line">  re:</span><br><span class="line">     <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++ &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;i: %d\n&quot;</span>, i)</span><br><span class="line">        <span class="keyword">for</span> i2 := <span class="number">11</span>; i2 &lt;= <span class="number">13</span>; i2++ &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;i2: %d\n&quot;</span>, i2)</span><br><span class="line">        <span class="keyword">break</span> re</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>2.continue</p><ul><li>和break类似 相比Java也有标记label</li></ul><p>3.goto<br>Go 语言的 goto 语句可以无条件地转移到过程中指定的行。</p><p>goto 语句通常与条件语句配合使用。可用来实现条件转移， 构成循环，跳出循环体等功能。</p><p>但是，在结构化程序设计中一般不主张使用 goto 语句， 以免造成程序流程的混乱，使理解和调试程序都产生困难。<br>语法<br>goto 语法格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">goto</span> label;</span><br><span class="line">..</span><br><span class="line">.</span><br><span class="line">label: statement;</span><br></pre></td></tr></table></figure><p>实例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">/* 定义局部变量 */</span></span><br><span class="line">   <span class="keyword">var</span> a <span class="type">int</span> = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 循环 */</span></span><br><span class="line">   LOOP: <span class="keyword">for</span> a &lt; <span class="number">20</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> a == <span class="number">15</span> &#123;</span><br><span class="line">         <span class="comment">/* 跳过迭代 */</span></span><br><span class="line">         a = a + <span class="number">1</span></span><br><span class="line">         <span class="keyword">goto</span> LOOP</span><br><span class="line">      &#125;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;a的值为 : %d\n&quot;</span>, a)</span><br><span class="line">      a++    </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br><span class="line">以上实例执行结果为：</span><br><span class="line"></span><br><span class="line">a的值为 : <span class="number">10</span></span><br><span class="line">a的值为 : <span class="number">11</span></span><br><span class="line">a的值为 : <span class="number">12</span></span><br><span class="line">a的值为 : <span class="number">13</span></span><br><span class="line">a的值为 : <span class="number">14</span></span><br><span class="line">a的值为 : <span class="number">16</span></span><br><span class="line">a的值为 : <span class="number">17</span></span><br><span class="line">a的值为 : <span class="number">18</span></span><br><span class="line">a的值为 : <span class="number">19</span></span><br></pre></td></tr></table></figure><h6 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h6><p>如果循环中条件语句永远不为 false 则会进行无限循环，我们可以通过 for 循环语句中只设置一个条件表达式来执行无限循环：</p><p>实例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="literal">true</span>  &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;这是无限循环。\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-Go-语言函数"><a href="#10-Go-语言函数" class="headerlink" title="10. Go 语言函数"></a>10. Go 语言函数</h4><h6 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h6><p>Go 语言函数定义格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">function_name</span><span class="params">( [parameter list] )</span></span> [return_types] &#123;</span><br><span class="line">   函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>函数定义解析</strong>：</p><ul><li>func：函数由 func 开始声明</li><li>function_name：函数名称，参数列表和返回值类型构成了函数签名。</li><li>parameter list：参数列表，参数就像一个占位符，当函数被调用时，你可以将值传递给参数，这个值被称为实际参数。参数列表指定的是参数类型、顺序、及参数个数。参数是可选的，也就是说函数也可以不包含参数。</li><li>return_types：返回类型，函数返回一列值。return_types 是该列值的数据类型。有些功能不需要返回值，这种情况下 return_types 不是必须的。<br>函数体：函数定义的代码集合。</li></ul><p><strong>实例</strong><br>以下实例为 max() 函数的代码，该函数传入两个整型参数 num1 和 num2，并返回这两个参数的最大值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 函数返回两个数的最大值 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(num1, num2 <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">   <span class="comment">/* 声明局部变量 */</span></span><br><span class="line">   <span class="keyword">var</span> result <span class="type">int</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (num1 &gt; num2) &#123;</span><br><span class="line">      result = num1</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result = num2</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>函数多个返回值</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">实例</span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x, y <span class="type">string</span>)</span></span> (<span class="type">string</span>, <span class="type">string</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> y, x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   a, b := swap(<span class="string">&quot;Google&quot;</span>, <span class="string">&quot;Runoob&quot;</span>)</span><br><span class="line">   fmt.Println(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>函数参数</strong></p><table><thead><tr><th align="center">传递类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">值传递</td><td align="center">值传递是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。</td></tr><tr><td align="center">引用传递</td><td align="center">引用传递是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。</td></tr></tbody></table><p><strong>Go 语言函数闭包</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSequence</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">   i:=<span class="number">0</span></span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">      i+=<span class="number">1</span></span><br><span class="line">     <span class="keyword">return</span> i  </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="comment">/* nextNumber 为一个函数，函数 i 为 0 */</span></span><br><span class="line">   nextNumber := getSequence()  </span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 调用 nextNumber 函数，i 变量自增 1 并返回 */</span></span><br><span class="line">   fmt.Println(nextNumber())</span><br><span class="line">   fmt.Println(nextNumber())</span><br><span class="line">   fmt.Println(nextNumber())</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* 创建新的函数 nextNumber1，并查看结果 */</span></span><br><span class="line">   nextNumber1 := getSequence()  </span><br><span class="line">   fmt.Println(nextNumber1())</span><br><span class="line">   fmt.Println(nextNumber1())</span><br><span class="line">&#125;</span><br><span class="line">执行结果：</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> GO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC并发编程</title>
      <link href="/archives/eb9166f8.html"/>
      <url>/archives/eb9166f8.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="一、线程基础"><a href="#一、线程基础" class="headerlink" title="一、线程基础"></a>一、线程基础</h2><h3 id="1、Java多线程相关概念"><a href="#1、Java多线程相关概念" class="headerlink" title="1、Java多线程相关概念"></a>1、Java多线程相关概念</h3><h4 id="1、进程"><a href="#1、进程" class="headerlink" title="1、进程"></a>1、进程</h4><p>是程序的⼀次执⾏，是系统进⾏资源分配和调度的独⽴单位，每⼀个进程都有它⾃⼰的内存空间和系统资源</p><p>进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。程序是指令、数据及其组织形式的描述，进程是程序的实体。</p><p><strong>进程具有的特征：</strong></p><ul><li><strong>动态性</strong>：进程是程序的一次执行过程，是临时的，有生命期的，是动态产生，动态消亡的</li><li><strong>并发性</strong>：任何进程都可以同其他进行一起并发执行</li><li><strong>独立性</strong>：进程是系统进行资源分配和调度的一个独立单位</li><li><strong>结构性</strong>：进程由程序，数据和进程控制块三部分组成</li></ul><p>我们经常使用windows系统，经常会看见.exe后缀的文件，双击这个.exe文件的时候，这个文件中的指令就会被系统加载，那么我们就能得到一个关于这个.exe程序的进程。进程是<strong>“活”</strong>的，或者说是正在被执行的。</p><h4 id="2、线程"><a href="#2、线程" class="headerlink" title="2、线程"></a>2、线程</h4><p>在同⼀个进程内⼜可以执⾏多个任务，⽽这每⼀个任务我们就可以看做是⼀个线程 ⼀个进程会有1个或多个线程的</p><p>线程是轻量级的进程，是程序执行的最小单元，使用多线程而不是多进程去进行并发程序的设计，是因为线程间的切换和调度的成本远远小于进程。</p><h4 id="3、进程与线程的一个简单解释"><a href="#3、进程与线程的一个简单解释" class="headerlink" title="3、进程与线程的一个简单解释"></a>3、进程与线程的一个简单解释</h4><p>进程（process）和线程（thread）是操作系统的基本概念，但是它们比较抽象，不容易掌握。</p><p>1.计算机的核心是CPU，它承担了所有的计算任务。它就像一座工厂，时刻在运行。</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20220920181500949.png" alt="image-20220920181500949"></p><p>2.假定工厂的电力有限，一次只能供给一个车间使用。也就是说，一个车间开工的时候，其他车间都必须停工。背后的含义就是，单个CPU一次只能运行一个任务。</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/aa874eba-0c27-4924-be97-9c853c009ca9.png" alt="aa874eba-0c27-4924-be97-9c853c009ca9"></p><p>3.进程就好比工厂的车间，它代表CPU所能处理的单个任务。任一时刻，CPU总是运行一个进程，其他进程处于非运行状态。</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/f03b160d-4e18-46a1-9158-913a4afdb2b2.png" alt="f03b160d-4e18-46a1-9158-913a4afdb2b2"></p><p>4.一个车间里，可以有很多工人。他们协同完成一个任务。</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/9985e48b-92bd-434e-8a4e-6f85c95a8dbd.png" alt="9985e48b-92bd-434e-8a4e-6f85c95a8dbd"></p><p>5.线程就好比车间里的工人。一个进程可以包括多个线程。</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/3dc76caa-b3d9-4555-b8c4-c805bb97e03e.png" alt="3dc76caa-b3d9-4555-b8c4-c805bb97e03e"></p><p>6.车间的空间是工人们共享的，比如许多房间是每个工人都可以进出的。这象征一个进程的内存空间是共享的，每个线程都可以使用这些共享内存。</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/b3ef804e-346b-4280-bb8d-809c9bd42853.png" alt="b3ef804e-346b-4280-bb8d-809c9bd42853"></p><p>7.可是，每间房间的大小不同，有些房间最多只能容纳一个人，比如厕所。里面有人的时候，其他人就不能进去了。这代表一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/bea2bf20-2b08-484e-80b7-3e210d0e20df.png" alt="bea2bf20-2b08-484e-80b7-3e210d0e20df"></p><p>8.一个防止他人进入的简单方法，就是门口加一把锁。先到的人锁上门，后到的人看到上锁，就在门口排队，等锁打开再进去。这就叫”互斥锁”（Mutual exclusion，缩写 Mutex），防止多个线程同时读写某一块内存区域。</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/876a4f82-7931-4674-ac6b-a6d04a88a5b1.png" alt="876a4f82-7931-4674-ac6b-a6d04a88a5b1"></p><p>9.还有些房间，可以同时容纳n个人，比如厨房。也就是说，如果人数大于n，多出来的人只能在外面等着。这好比某些内存区域，只能供给固定数目的线程使用。</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/ae960b3a-c0e8-4c3d-bbcb-bfc5ebbecb79.png" alt="ae960b3a-c0e8-4c3d-bbcb-bfc5ebbecb79"></p><p>10.这时的解决方法，就是在门口挂n把钥匙。进去的人就取一把钥匙，出来时再把钥匙挂回原处。后到的人发现钥匙架空了，就知道必须在门口排队等着了。这种做法叫做”信号量”（Semaphore），用来保证多个线程不会互相冲突。</p><p>11.操作系统的设计，因此可以归结为三点：<br>（1）以多进程形式，允许多个任务同时运行；<br>（2）以多线程形式，允许单个任务分成不同的部分运行；<br>（3）提供协调机制，一方面防止进程之间和线程之间产生冲突，另一方面允许进程之间和线程之间共享资源。</p><h4 id="4、管程"><a href="#4、管程" class="headerlink" title="4、管程"></a>4、管程</h4><p>Monitor(监视器)，也就是我们平时所说的锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Monitor其实是一种同步机制，他的义务是保证（同一时间）只有一个线程可以访问被保护的数据和代码。</span></span><br><span class="line"><span class="comment">// JVM中同步是基于进入和退出监视器对象(Monitor,管程对象)来实现的，每个对象实例都会有一个Monitor对象，</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (o)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"><span class="comment">// Monitor对象会和Java对象一同创建并销毁，它底层是由C++语言来实现的。</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210904000040589.png" alt="image-20210904000040589"></p><h4 id="5、线程状态？"><a href="#5、线程状态？" class="headerlink" title="5、线程状态？"></a>5、线程状态？</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thread.State</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    NEW,(新建)</span><br><span class="line">    RUNNABLE,（准备就绪）</span><br><span class="line">    BLOCKED,（阻塞）</span><br><span class="line">    WAITING,（不见不散）</span><br><span class="line">    TIMED_WAITING,（过时不候）</span><br><span class="line">    TERMINATED;(终结)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程几个状态的介绍：</p><ul><li><strong>New</strong>：表示刚刚创建的线程，这种线程还没有开始执行</li><li><strong>RUNNABLE</strong>：运行状态，线程的start()方法调用后，线程会处于这种状态</li><li><strong>BLOCKED</strong>：阻塞状态。当线程在执行的过程中遇到了synchronized同步块，但这个同步块被其他线程已获取还未释放时，当前线程将进入阻塞状态，会暂停执行，直到获取到锁。当线程获取到锁之后，又会进入到运行状态（RUNNABLE）</li><li><strong>WAITING</strong>：等待状态。和TIME_WAITING都表示等待状态，区别是WAITING会进入一个无时间限制的等，而TIME_WAITING会进入一个有限的时间等待，那么等待的线程究竟在等什么呢？一般来说，WAITING的线程正式在等待一些特殊的事件，比如，通过wait()方法等待的线程在等待notify()方法，而通过join()方法等待的线程则会等待目标线程的终止。一旦等到期望的事件，线程就会再次进入RUNNABLE运行状态。</li><li><strong>TERMINATED</strong>：表示结束状态，线程执行完毕之后进入结束状态。</li></ul><p><strong>注意：从NEW状态出发后，线程不能在回到NEW状态，同理，处理TERMINATED状态的线程也不能在回到RUNNABLE状态</strong></p><h4 id="6、wait-x2F-sleep的区别？"><a href="#6、wait-x2F-sleep的区别？" class="headerlink" title="6、wait&#x2F;sleep的区别？"></a>6、wait&#x2F;sleep的区别？</h4><p>功能都是当前线程暂停，有什么区别？</p><p>wait放开手去睡，放开手里的锁</p><p>sleep握紧手去睡，醒了手里还有锁</p><h3 id="2、线程的基本操作"><a href="#2、线程的基本操作" class="headerlink" title="2、线程的基本操作"></a>2、线程的基本操作</h3><h4 id="1、新建线程"><a href="#1、新建线程" class="headerlink" title="1、新建线程"></a>1、新建线程</h4><p>新建线程很简单。只需要使用new关键字创建一个线程对象，然后调用它的start()启动线程即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread1</span>();</span><br><span class="line">t1.start();</span><br></pre></td></tr></table></figure><p>那么线程start()之后，会干什么呢？线程有个run()方法，start()会创建一个新的线程并让这个线程执行run()方法。</p><p>这里需要注意，下面代码也能通过编译，也能正常执行。但是，却不能新建一个线程，而是在当前线程中调用run()方法，将run方法只是作为一个普通的方法调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread1</span>();</span><br><span class="line">thread1.run();</span><br></pre></td></tr></table></figure><p>所以，希望大家注意，调用start方法和直接调用run方法的区别。</p><p><strong>start方法是启动一个线程，run方法只会在垫钱线程中串行的执行run方法中的代码。</strong></p><p>默认情况下， 线程的run方法什么都没有，启动一个线程之后马上就结束了，所以如果你需要线程做点什么，需要把您的代码写到run方法中，所以必须重写run方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread thread1 = new Thread() &#123;            @Override            public void run() &#123;                System.out.println(&quot;hello,我是一个线程!&quot;);            &#125;        &#125;;thread1.start();</span><br></pre></td></tr></table></figure><p>上面是使用匿名内部类实现的，重写了Thread的run方法，并且打印了一条信息。<strong>我们可以通过继承Thread类，然后重写run方法，来自定义一个线程。</strong>但考虑java是单继承的，从扩展性上来说，我们实现一个接口来自定义一个线程更好一些，java中刚好提供了Runnable接口来自定义一个线程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterfacepublic interface Runnable &#123;    public abstract void run();&#125;</span><br></pre></td></tr></table></figure><p>Thread类有一个非常重要的构造方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public Thread(Runnable target)</span><br></pre></td></tr></table></figure><p>我们在看一下Thread的run方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public void run() &#123;        if (target != null) &#123;            target.run();        &#125;    &#125;</span><br></pre></td></tr></table></figure><p>当我们启动线程的start方法之后，线程会执行run方法，run方法中会调用Thread构造方法传入的target的run方法。</p><p><strong>实现Runnable接口是比较常见的做法，也是推荐的做法。</strong></p><h4 id="2、终止线程"><a href="#2、终止线程" class="headerlink" title="2、终止线程"></a>2、终止线程</h4><p>一般来说线程执行完毕就会结束，无需手动关闭。但是如果我们想关闭一个正在运行的线程，有什么方法呢？可以看一下Thread类中提供了一个stop()方法，调用这个方法，就可以立即将一个线程终止，非常方便。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                log.info(<span class="string">&quot;start&quot;</span>);</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">                    ;</span><br><span class="line">                &#125;</span><br><span class="line">                log.info(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        thread1.setName(<span class="string">&quot;thread1&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        <span class="comment">//当前线程休眠1秒</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//关闭线程thread1</span></span><br><span class="line">        thread1.stop();</span><br><span class="line">        <span class="comment">//输出线程thread1的状态</span></span><br><span class="line">        log.info(<span class="string">&quot;&#123;&#125;&quot;</span>, thread1.getState());</span><br><span class="line">        <span class="comment">//当前线程休眠1秒</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//输出线程thread1的状态</span></span><br><span class="line">        log.info(<span class="string">&quot;&#123;&#125;&quot;</span>, thread1.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行代码，输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">18:02:15.312 [thread1] INFO com.itsoku.chat01.Demo01 - start</span><br><span class="line">18:02:16.311 [main] INFO com.itsoku.chat01.Demo01 - RUNNABLE</span><br><span class="line">18:02:17.313 [main] INFO com.itsoku.chat01.Demo01 - TERMINATED</span><br></pre></td></tr></table></figure><p>代码中有个死循环，调用stop方法之后，线程thread1的状态变为TERMINATED（结束状态），线程停止了。</p><p>我们使用idea或者eclipse的时候，会发现这个方法是一个废弃的方法，也就是说，在将来，jdk可能就会移除该方法。</p><p>stop方法为何会被废弃而不推荐使用？stop方法过于暴力，强制把正在执行的方法停止了。</p><p>大家是否遇到过这样的场景：<strong>电力系统需要维修，此时咱们正在写代码，维修人员直接将电源关闭了，代码还没保存的，是不是很崩溃，这种方式就像直接调用线程的stop方法类似。线程正在运行过程中，被强制结束了，可能会导致一些意想不到的后果。可以给大家发送一个通知，告诉大家保存一下手头的工作，将电脑关闭。</strong></p><h4 id="3、线程中断"><a href="#3、线程中断" class="headerlink" title="3、线程中断"></a>3、线程中断</h4><p>在java中，线程中断是一种重要的线程写作机制，从表面上理解，中断就是让目标线程停止执行的意思，实际上并非完全如此。在上面中，我们已经详细讨论了stop方法停止线程的坏处，jdk中提供了更好的中断线程的方法。严格的说，线程中断并不会使线程立即退出，而是给线程发送一个通知，告知目标线程，有人希望你退出了！至于目标线程接收到通知之后如何处理，则完全由目标线程自己决定，这点很重要，如果中断后，线程立即无条件退出，我们又会到stop方法的老问题。</p><p>Thread提供了3个与线程中断有关的方法，这3个方法容易混淆，大家注意下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">interrupt</span><span class="params">()</span> <span class="comment">//中断线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isInterrupted</span><span class="params">()</span> <span class="comment">//判断线程是否被中断</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">interrupted</span><span class="params">()</span>  <span class="comment">//判断线程是否被中断，并清除当前中断状态</span></span><br></pre></td></tr></table></figure><p><strong>interrupt()<strong>方法是一个</strong>实例方法</strong>，它通知目标线程中断，也就是设置中断标志位为true，中断标志位表示当前线程已经被中断了。<strong>isInterrupted()<strong>方法也是一个</strong>实例方法</strong>，它判断当前线程是否被中断（通过检查中断标志位）。最后一个方法<strong>interrupted()<strong>是一个</strong>静态方法</strong>，返回boolean类型，也是用来判断当前线程是否被中断，但是同时会清除当前线程的中断标志位的状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.isInterrupted()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;我要退出了!&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">thread1.setName(<span class="string">&quot;thread1&quot;</span>);</span><br><span class="line">thread1.start();</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">thread1.interrupt();</span><br></pre></td></tr></table></figure><p>上面代码中有个死循环，interrupt()方法被调用之后，线程的中断标志将被置为true，循环体中通过检查线程的中断标志是否为ture（<code>this.isInterrupted()</code>）来判断线程是否需要退出了。</p><p>再看一种中断的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">isStop</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isStop) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;我要退出了!&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    thread1.setName(<span class="string">&quot;thread1&quot;</span>);</span><br><span class="line">    thread1.start();</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    isStop = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>代码中通过一个变量isStop来控制线程是否停止。</p><p>通过变量控制和线程自带的interrupt方法来中断线程有什么区别呢？</p><p>如果一个线程调用了sleep方法，一直处于休眠状态，通过变量控制，还可以中断线程么？大家可以思考一下。</p><p>此时只能使用线程提供的interrupt方法来中断线程了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="comment">//休眠100秒</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;我要退出了!&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    thread1.setName(<span class="string">&quot;thread1&quot;</span>);</span><br><span class="line">    thread1.start();</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    thread1.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用interrupt()方法之后，线程的sleep方法将会抛出<code>InterruptedException</code>异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">//休眠100秒</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.isInterrupted()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;我要退出了!&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>运行上面的代码，发现程序无法终止。为什么？</p><p>代码需要改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">//休眠100秒</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="built_in">this</span>.interrupt();</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.isInterrupted()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;我要退出了!&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码可以终止。</p><p><strong>注意：sleep方法由于中断而抛出异常之后，线程的中断标志会被清除（置为false），所以在异常中需要执行this.interrupt()方法，将中断标志位置为true</strong></p><h4 id="4、等待（wait）和通知（notify）"><a href="#4、等待（wait）和通知（notify）" class="headerlink" title="4、等待（wait）和通知（notify）"></a>4、等待（wait）和通知（notify）</h4><p>为了支持多线程之间的协作，JDK提供了两个非常重要的方法：等待wait()方法和通知notify()方法。这2个方法并不是在Thread类中的，而是在Object类中定义的。这意味着所有的对象都可以调用者两个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>当在一个对象实例上调用wait()方法后，当前线程就会在这个对象上等待。这是什么意思？比如在线程A中，调用了obj.wait()方法，那么线程A就会停止继续执行，转为等待状态。等待到什么时候结束呢？线程A会一直等到其他线程调用obj.notify()方法为止，这时，obj对象成为了多个线程之间的有效通信手段。</p><p>那么wait()方法和notify()方法是如何工作的呢？如图2.5展示了两者的工作过程。如果一个线程调用了object.wait()方法，那么它就会进出object对象的等待队列。这个队列中，可能会有多个线程，因为系统可能运行多个线程同时等待某一个对象。当object.notify()方法被调用时，它就会从这个队列中随机选择一个线程，并将其唤醒。这里希望大家注意一下，这个选择是不公平的，并不是先等待线程就会优先被选择，这个选择完全是随机的。</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/f950f73b-52a6-4ecd-a8cb-5422bcd3a44e.png" alt="f950f73b-52a6-4ecd-a8cb-5422bcd3a44e"></p><p>除notify()方法外，Object独享还有一个nofiyAll()方法，它和notify()方法的功能类似，不同的是，它会唤醒在这个等待队列中所有等待的线程，而不是随机选择一个。</p><p>这里强调一点，Object.wait()方法并不能随便调用。它必须包含在对应的synchronize语句汇总，无论是wait()方法或者notify()方法都需要首先获取目标独享的一个监视器。图2.6显示了wait()方法和nofiy()方法的工作流程细节。其中T1和T2表示两个线程。T1在正确执行wait()方法钱，必须获得object对象的监视器。而wait()方法在执行后，会释放这个监视器。这样做的目的是使其他等待在object对象上的线程不至于因为T1的休眠而全部无法正常执行。</p><p>线程T2在notify()方法调用前，也必须获得object对象的监视器。所幸，此时T1已经释放了这个监视器，因此，T2可以顺利获得object对象的监视器。接着，T2执行了notify()方法尝试唤醒一个等待线程，这里假设唤醒了T1。T1在被唤醒后，要做的第一件事并不是执行后续代码，而是要尝试重新获得object对象的监视器，而这个监视器也正是T1在wait()方法执行前所持有的那个。如果暂时无法获得，则T1还必须等待这个监视器。当监视器顺利获得后，T1才可以在真正意义上继续执行。</p><p>给大家上个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo06</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">T1</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">                System.out.println(System.currentTimeMillis() + <span class="string">&quot;:T1 start!&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(System.currentTimeMillis() + <span class="string">&quot;:T1 wait for object&quot;</span>);</span><br><span class="line">                    object.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(System.currentTimeMillis() + <span class="string">&quot;:T1 end!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">T2</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">                System.out.println(System.currentTimeMillis() + <span class="string">&quot;:T2 start，notify one thread! &quot;</span>);</span><br><span class="line">                object.notify();</span><br><span class="line">                System.out.println(System.currentTimeMillis() + <span class="string">&quot;:T2 end!&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">T1</span>().start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">T2</span>().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1562934497212</span>:T1 start!</span><br><span class="line"><span class="number">1562934497212</span>:T1 wait <span class="keyword">for</span> object</span><br><span class="line"><span class="number">1562934497212</span>:T2 start，notify one thread!</span><br><span class="line"><span class="number">1562934497212</span>:T2 end!</span><br><span class="line"><span class="number">1562934499213</span>:T1 end!</span><br></pre></td></tr></table></figure><p>注意下打印结果，T2调用notify方法之后，T1并不能立即继续执行，而是要等待T2释放objec投递锁之后，T1重新成功获取锁后，才能继续执行。因此最后2行日志相差了2秒（因为T2调用notify方法后休眠了2秒）。</p><p><strong>注意：Object.wait()方法和Thread.sleep()方法都可以让现场等待若干时间。除wait()方法可以被唤醒外，另外一个主要的区别就是wait()方法会释放目标对象的锁，而Thread.sleep()方法不会释放锁。</strong></p><p>再给大家讲解一下wait()，notify()，notifyAll()，加深一下理解：</p><p>可以这么理解，obj对象上有2个队列，如图1，<strong>q1：等待队列，q2：准备获取锁的队列</strong>；两个队列都为空。</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/5f1e0099-c802-4e79-803a-a5117e6666ff.png" alt="5f1e0099-c802-4e79-803a-a5117e6666ff"></p><p><strong>obj.wait()过程：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">synchronize(obj)&#123;</span><br><span class="line">    obj.wait();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假如有3个线程，t1、t2、t3同时执行上面代码，t1、t2、t3会进入q2队列，如图2，进入q2的队列的这些线程才有资格去争抢obj的锁，假设t1争抢到了，那么t2、t3机型在q2中等待着获取锁，t1进入代码块执行wait()方法，此时t1会进入q1队列，然后系统会通知q2队列中的t2、t3去争抢obj的锁，抢到之后过程如t1的过程。最后t1、t2、t3都进入了q1队列，如图3。</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/6c5eec72-3303-40a5-b70d-6e24ba12d2de.png" alt="6c5eec72-3303-40a5-b70d-6e24ba12d2de"></p><p><img src="/images/1.JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/45fd3950-b371-4d46-a5df-2ce1c8303707.png" alt="45fd3950-b371-4d46-a5df-2ce1c8303707"></p><p>上面过程之后，又来了线程t4执行了notify()方法，如下：**</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">synchronize(obj)&#123;</span><br><span class="line">    obj.notify();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>t4会获取到obj的锁，然后执行notify()方法，系统会从q1队列中随机取一个线程，将其加入到q2队列，假如t2运气比较好，被随机到了，然后t2进入了q2队列，如图4，进入q2的队列的锁才有资格争抢obj的锁，t4线程执行完毕之后，会释放obj的锁，此时队列q2中的t2会获取到obj的锁，然后继续执行，执行完毕之后，q1中包含t1、t3，q2队列为空，如图5</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/fbf3b798-65f7-4b90-a614-66854fcce5fa.png" alt="fbf3b798-65f7-4b90-a614-66854fcce5fa"></p><p><img src="/images/1.JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/b3868bc9-3da0-474b-a48e-20f90c1335ee.png" alt="b3868bc9-3da0-474b-a48e-20f90c1335ee"></p><p><strong>接着又来了个t5队列，执行了notifyAll()方法，如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">synchronize(obj)&#123;</span><br><span class="line">    obj.notifyAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.调用obj.wait()方法，当前线程会加入队列queue1，然后会释放obj对象的锁</p><p>t5会获取到obj的锁，然后执行notifyAll()方法，系统会将队列q1中的线程都移到q2中，如图6，t5线程执行完毕之后，会释放obj的锁，此时队列q2中的t1、t3会争抢obj的锁，争抢到的继续执行，未增强到的带锁释放之后，系统会通知q2中的线程继续争抢索，然后继续执行，最后两个队列中都为空了。</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/9e648015-c445-4e84-bd8c-a53a380cbd7f.png" alt="9e648015-c445-4e84-bd8c-a53a380cbd7f"></p><h4 id="5、挂起（suspend）和继续执行（resume）线程"><a href="#5、挂起（suspend）和继续执行（resume）线程" class="headerlink" title="5、挂起（suspend）和继续执行（resume）线程"></a>5、挂起（suspend）和继续执行（resume）线程</h4><p>Thread类中还有2个方法，即**线程挂起(suspend)<strong>和</strong>继续执行(resume)**，这2个操作是一对相反的操作，被挂起的线程，必须要等到resume()方法操作后，才能继续执行。系统中已经标注着2个方法过时了，不推荐使用。</p><p>系统不推荐使用suspend()方法去挂起线程是因为suspend()方法导致线程暂停的同时，并不会释放任何锁资源。此时，其他任何线程想要访问被它占用的锁时，都会被牵连，导致无法正常运行（如图2.7所示）。直到在对应的线程上进行了resume()方法操作，被挂起的线程才能继续，从而其他所有阻塞在相关锁上的线程也可以继续执行。但是，如果resume()方法操作意外地在suspend()方法前就被执行了，那么被挂起的线程可能很难有机会被继续执行了。并且，更严重的是：它所占用的锁不会被释放，因此可能会导致整个系统工作不正常。而且，对于被挂起的线程，从它线程的状态上看，居然还是<strong>Runnable</strong>状态，这也会影响我们队系统当前状态的判断。</p><p>上个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo07</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">T1</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">T1</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;in &quot;</span> + <span class="built_in">this</span>.getName());</span><br><span class="line">                Thread.currentThread().suspend();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">T1</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T1</span>(<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        <span class="type">T1</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T1</span>(<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.resume();</span><br><span class="line">        t2.resume();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行代码输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">in t1</span><br><span class="line">in t2</span><br></pre></td></tr></table></figure><p>我们会发现程序不会结束，线程t2被挂起了，导致程序无法结束，使用jstack命令查看线程堆栈信息可以看到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;t2&quot;</span> #<span class="number">13</span> prio=<span class="number">5</span> os_prio=<span class="number">0</span> tid=<span class="number">0x000000002796c000</span> nid=<span class="number">0xa3c</span> runnable [<span class="number">0x000000002867f000</span>]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">        at java.lang.Thread.suspend0(Native Method)</span><br><span class="line">        at java.lang.Thread.suspend(Thread.java:<span class="number">1029</span>)</span><br><span class="line">        at com.itsoku.chat01.Demo07$T1.run(Demo07.java:<span class="number">20</span>)</span><br><span class="line">        - locked &lt;<span class="number">0x0000000717372fc0</span>&gt; (a java.lang.Object)</span><br></pre></td></tr></table></figure><p>发现t2线程在<strong>suspend0</strong>处被挂起了，t2的状态竟然还是RUNNABLE状态，线程明明被挂起了，状态还是运行中容易导致我们队当前系统进行误判，代码中已经调用resume()方法了，但是由于时间先后顺序的缘故，resume并没有生效，这导致了t2永远滴被挂起了，并且永远占用了object的锁，这对于系统来说可能是致命的。</p><h4 id="6、等待线程结束（join）和谦让（yeild）"><a href="#6、等待线程结束（join）和谦让（yeild）" class="headerlink" title="6、等待线程结束（join）和谦让（yeild）"></a>6、等待线程结束（join）和谦让（yeild）</h4><p>很多时候，一个线程的输入可能非常依赖于另外一个或者多个线程的输出，此时，这个线程就需要等待依赖的线程执行完毕，才能继续执行。jdk提供了join()操作来实现这个功能。如下所示，显示了2个join()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">(<span class="type">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException;</span><br></pre></td></tr></table></figure><p>第1个方法表示无限等待，它会一直只是当前线程。知道目标线程执行完毕。</p><p>第2个方法有个参数，用于指定等待时间，如果超过了给定的时间目标线程还在执行，当前线程也会停止等待，而继续往下执行。</p><p>比如：线程T1需要等待T2、T3完成之后才能继续执行，那么在T1线程中需要分别调用T2和T3的join()方法。</p><p>上个示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo08</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">T1</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">T1</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(System.currentTimeMillis() + <span class="string">&quot;,start &quot;</span> + <span class="built_in">this</span>.getName());</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                num++;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">200</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(System.currentTimeMillis() + <span class="string">&quot;,end &quot;</span> + <span class="built_in">this</span>.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">T1</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T1</span>(<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        System.out.println(System.currentTimeMillis() + <span class="string">&quot;,num = &quot;</span> + num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1562939889129</span>,start t1</span><br><span class="line"><span class="number">1562939891134</span>,end t1</span><br><span class="line"><span class="number">1562939891134</span>,num = <span class="number">10</span></span><br></pre></td></tr></table></figure><p>num的结果为10，1、3行的时间戳相差2秒左右，说明主线程等待t1完成之后才继续执行的。</p><p>看一下jdk1.8中Thread.join()方法的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">(<span class="type">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">base</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            wait(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">delay</span> <span class="operator">=</span> millis - now;</span><br><span class="line">            <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            wait(delay);</span><br><span class="line">            now = System.currentTimeMillis() - base;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从join的代码中可以看出，在被等待的线程上使用了synchronize，调用了它的wait()方法，线程最后执行完毕之后，<strong>系统会自动调用它的notifyAll()方法</strong>，唤醒所有在此线程上等待的其他线程。</p><p><strong>注意：被等待的线程执行完毕之后，系统自动会调用该线程的notifyAll()方法。所以一般情况下，我们不要去在线程对象上使用wait()、notify()、notifyAll()方法。</strong></p><p>另外一个方法是**Thread.yield()**，他的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">yield</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>yield是谦让的意思，这是一个静态方法，一旦执行，它会让当前线程出让CPU，但需要注意的是，出让CPU并不是说不让当前线程执行了，当前线程在出让CPU后，还会进行CPU资源的争夺，但是能否再抢到CPU的执行权就不一定了。因此，对Thread.yield()方法的调用好像就是在说：我已经完成了一些主要的工作，我可以休息一下了，可以让CPU给其他线程一些工作机会了。</p><p>如果觉得一个线程不太重要，或者优先级比较低，而又担心此线程会过多的占用CPU资源，那么可以在适当的时候调用一下Thread.yield()方法，给与其他线程更多的机会。</p><h4 id="7、总结"><a href="#7、总结" class="headerlink" title="7、总结"></a>7、总结</h4><ol><li>创建线程的2中方式：继承Thread类；实现Runnable接口</li><li>启动线程：调用线程的start()方法</li><li>终止线程：调用线程的stop()方法，方法已过时，建议不要使用</li><li>线程中断相关的方法：调用线程<strong>实例interrupt()方法</strong>将中断标志置为true；使用**线程实例方法isInterrupted()<strong>获取中断标志；调用</strong>Thread的静态方法interrupted()**获取线程是否被中断，此方法调用之后会清除中断标志（将中断标志置为false了）</li><li>wait、notify、notifyAll方法，这块比较难理解，可以回过头去再理理</li><li>线程挂起使用**线程实例方法suspend()<strong>，恢复线程使用</strong>线程实例方法resume()**，这2个方法都过时了，不建议使用</li><li>等待线程结束：调用<strong>线程实例方法join()</strong></li><li>出让cpu资源：调用<strong>线程静态方法yeild()</strong></li></ol><h3 id="2、为什么多线程极其重要？？？"><a href="#2、为什么多线程极其重要？？？" class="headerlink" title="2、为什么多线程极其重要？？？"></a>2、为什么多线程极其重要？？？</h3><ol><li>硬件方面 - 摩尔定律失效</li></ol><p>摩尔定律：<br>它是由英特尔创始人之一Gordon Moore(戈登·摩尔)提出来的。其内容为：<br>当价格不变时，集成电路上可容纳的元器件的数目约每隔18-24个月便会增加一倍，性能也将提升一倍。<br>换言之，每一美元所能买到的电脑性能，将每隔18-24个月翻一倍以上。这一定律揭示了信息技术进步的速度。</p><p>可是从2003年开始CPU主频已经不再翻倍，而是采用多核而不是更快的主频。</p><p>摩尔定律失效。</p><p>在主频不再提高且核数在不断增加的情况下，要想让程序更快就要用到并行或并发编程。</p><ol start="2"><li>软件方面</li></ol><p>高并发系统，异步+回调等生产需求</p><h3 id="3、从start一个线程说起"><a href="#3、从start一个线程说起" class="headerlink" title="3、从start一个线程说起"></a>3、从start一个线程说起</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java线程理解以及openjdk中的实现</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">start0</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// Java语言本身底层就是C++语言</span></span><br></pre></td></tr></table></figure><blockquote><p>OpenJDK源码网址:<a href="http://openjdk.java.net/">http://openjdk.java.net/</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openjdk8\hotspot\src\share\vm\runtime</span><br></pre></td></tr></table></figure><p><strong>更加底层的C++源码解读</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">openjdk8\jdk\src\share\<span class="keyword">native</span>\java\lang   thread.c</span><br><span class="line">java线程是通过start的方法启动执行的，主要内容在<span class="keyword">native</span>方法start0中，Openjdk的写JNI一般是一一对应的，Thread.java对应的就是Thread.c start0其实就是JVM_StartThread。此时查看源代码可以看到在jvm.h中找到了声明，jvm.cpp中有实现。    </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210903235656449.png" alt="image-20210903235656449"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openjdk8\hotspot\src\share\vm\prims  jvm.cpp</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210903235812379.png" alt="image-20210903235812379"></p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210903235817486.png" alt="image-20210903235817486"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openjdk8\hotspot\src\share\vm\runtime  thread.cpp</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210903235840971.png" alt="image-20210903235840971"></p><h3 id="4、用户线程和守护线程"><a href="#4、用户线程和守护线程" class="headerlink" title="4、用户线程和守护线程"></a>4、用户线程和守护线程</h3><p>Java线程分为用户线程和守护线程，线程的daemon属性为true表示是守护线程，false表示是用户线程</p><h4 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h4><p>是一种特殊的线程，在后台默默地完成一些系统性的服务，比如垃圾回收线程</p><h4 id="用户线程"><a href="#用户线程" class="headerlink" title="用户线程"></a>用户线程</h4><p>是系统的工作线程，它会完成这个程序需要完成的业务操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DaemonDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 开始运行，&quot;</span> + (Thread.currentThread().isDaemon() ? <span class="string">&quot;守护线程&quot;</span> : <span class="string">&quot;用户线程&quot;</span>));</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//线程的daemon属性为true表示是守护线程，false表示是用户线程</span></span><br><span class="line">        t1.setDaemon(<span class="literal">true</span>);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3秒钟后主线程再运行</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;----------main线程运行完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h4><p>当程序中所有用户线程执行完毕之后，不管守护线程是否结束，系统都会自动退出</p><p>如果用户线程全部结束了，意味着程序需要完成的业务操作已经结束了，系统可以退出了。所以当系统只剩下守护进程的时候，java虚拟机会自动退出</p><p>设置守护线程，需要在<strong>start()<strong>方法</strong>之前</strong>进行</p><h3 id="5、获得多线程的方法几种？"><a href="#5、获得多线程的方法几种？" class="headerlink" title="5、获得多线程的方法几种？"></a>5、获得多线程的方法几种？</h3><ul><li><p>传统的是</p><ul><li>继承thread类</li><li>实现runnable接口，</li></ul></li><li><p>java5以后</p><ul><li>实现callable接口</li><li>java的线程池获得</li></ul></li></ul><h3 id="6、Callable接口"><a href="#6、Callable接口" class="headerlink" title="6、Callable接口"></a>6、Callable接口</h3><h4 id="1、与runnable对比"><a href="#1、与runnable对比" class="headerlink" title="1、与runnable对比"></a>1、与runnable对比</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建新类MyThread实现runnable接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"> </span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 新类MyThread2实现callable接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread2</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt;&#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">200</span>;</span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 面试题:callable接口与runnable接口的区别？</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 答：（1）是否有返回值</span></span><br><span class="line"><span class="comment">//     （2）是否抛异常</span></span><br><span class="line"><span class="comment">//    （3）落地方法不一样，一个是run，一个是call</span></span><br></pre></td></tr></table></figure><h4 id="2、怎么用"><a href="#2、怎么用" class="headerlink" title="2、怎么用"></a>2、怎么用</h4><p>直接替换runnable是否可行？</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/1614161513991-ca4fa075-8d4d-4c45-b1c8-cf6f3d83c6e4.png" alt="image"></p><p>不可行，因为：thread类的构造方法根本没有Callable</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/1614161519289-57011bee-6de0-4002-b81e-433cede8c7a0.png" alt="image"></p><p>认识不同的人找中间人</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/1614161525949-6b3bf259-23a9-421e-8877-ae7f7de4f3d8.png" alt="image"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">  <span class="type">FutureTask</span> <span class="variable">futureTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>(<span class="keyword">new</span> <span class="title class_">MyThread2</span>());</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask,<span class="string">&quot;AA&quot;</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行成功后如何获得返回值？</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/1614161535188-cd8c298a-b466-41da-bee3-8ee572236b1f.png" alt="image"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">  <span class="type">FutureTask</span> <span class="variable">futureTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>(<span class="keyword">new</span> <span class="title class_">MyThread2</span>());</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask,<span class="string">&quot;AA&quot;</span>).start();</span><br><span class="line">  System.out.println(futureTask.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、线程池"><a href="#二、线程池" class="headerlink" title="二、线程池"></a>二、线程池</h2><h3 id="1、什么是线程池"><a href="#1、什么是线程池" class="headerlink" title="1、什么是线程池"></a>1、什么是线程池</h3><p>大家用jdbc操作过数据库应该知道，操作数据库需要和数据库建立连接，拿到连接之后才能操作数据库，用完之后销毁。数据库连接的创建和销毁其实是比较耗时的，真正和业务相关的操作耗时是比较短的。每个数据库操作之前都需要创建连接，为了提升系统性能，后来出现了数据库连接池，系统启动的时候，先创建很多连接放在池子里面，使用的时候，直接从连接池中获取一个，使用完毕之后返回到池子里面，继续给其他需要者使用，这其中就省去创建连接的时间，从而提升了系统整体的性能。</p><p>线程池和数据库连接池的原理也差不多，创建线程去处理业务，可能创建线程的时间比处理业务的时间还长一些，如果系统能够提前为我们创建好线程，我们需要的时候直接拿来使用，用完之后不是直接将其关闭，而是将其返回到线程中中，给其他需要这使用，这样直接节省了创建和销毁的时间，提升了系统的性能。</p><p>简单的说，在使用了线程池之后，创建线程变成了从线程池中获取一个空闲的线程，然后使用，关闭线程变成了将线程归还到线程池。</p><h3 id="2、为什么用线程池"><a href="#2、为什么用线程池" class="headerlink" title="2、为什么用线程池"></a>2、为什么用线程池</h3><p>线程池的优势：</p><p>​线程池做的工作主要是控制运行的线程数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果线程数量超过了最大数量，超出数量的线程排队等候，等其他线程执行完毕，再从队列中取出任务来执行。</p><p>它的主要特点为：<strong>线程复用;控制最大并发数;管理线程。</strong></p><p>第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的销耗。</p><p>第二：提高响应速度。当任务到达时，任务可以不需要等待线程创建就能立即执行。</p><p>第三：提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会销耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控</p><h3 id="3、线程池的使用"><a href="#3、线程池的使用" class="headerlink" title="3、线程池的使用"></a>3、线程池的使用</h3><h4 id="1、Executors-newFixedThreadPool-int"><a href="#1、Executors-newFixedThreadPool-int" class="headerlink" title="1、Executors.newFixedThreadPool(int)"></a>1、Executors.newFixedThreadPool(int)</h4><p>​newFixedThreadPool创建的线程池corePoolSize和maximumPoolSize值是相等的，它使用的是LinkedBlockingQueue执行长期任务性能好，创建一个线程池，一池有N个固定的线程，有固定线程数的线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、Executors-newSingleThreadExecutor"><a href="#2、Executors-newSingleThreadExecutor" class="headerlink" title="2、Executors.newSingleThreadExecutor()"></a>2、Executors.newSingleThreadExecutor()</h4><p>​newSingleThreadExecutor 创建的线程池corePoolSize和maximumPoolSize值都是1，它使用的是LinkedBlockingQueue一个任务一个任务的执行，一池一线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">        (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、Executors-newCachedThreadPool"><a href="#3、Executors-newCachedThreadPool" class="headerlink" title="3、Executors.newCachedThreadPool()"></a>3、Executors.newCachedThreadPool()</h4><p>​newCachedThreadPool创建的线程池将corePoolSize设置为0，将maximumPoolSize设置为Integer.MAX_VALUE，它使用的是SynchronousQueue，也就是说来了任务就创建线程运行，当线程空闲超过60秒，就销毁线程。</p><p>执行很多短期异步任务，线程池根据需要创建新线程，但在先前构建的线程可用时将重用它们。可扩容，遇强则强</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程池</span></span><br><span class="line"><span class="comment"> * Arrays</span></span><br><span class="line"><span class="comment"> * Collections</span></span><br><span class="line"><span class="comment"> * Executors</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThreadPoolDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//List list = new ArrayList();</span></span><br><span class="line">        <span class="comment">//List list = Arrays.asList(&quot;a&quot;,&quot;b&quot;);</span></span><br><span class="line">        <span class="comment">//固定数的线程池，一池五线程</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//       ExecutorService threadPool =  Executors.newFixedThreadPool(5); //一个银行网点，5个受理业务的窗口</span></span><br><span class="line"><span class="comment">//       ExecutorService threadPool =  Executors.newSingleThreadExecutor(); //一个银行网点，1个受理业务的窗口</span></span><br><span class="line">       <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span>  Executors.newCachedThreadPool(); <span class="comment">//一个银行网点，可扩展受理业务的窗口</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//10个顾客请求</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">10</span>; i++) &#123;</span><br><span class="line">                threadPool.execute(()-&gt;&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t 办理业务&quot;</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、ThreadPoolExecutor底层原理"><a href="#4、ThreadPoolExecutor底层原理" class="headerlink" title="4、ThreadPoolExecutor底层原理"></a>4、ThreadPoolExecutor底层原理</h3><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/fdae3766-9607-424f-8f77-ba9a14583e8e.png" alt="fdae3766-9607-424f-8f77-ba9a14583e8e"></p><p><strong>举个例子，加深理解：</strong></p><p>咱们作为开发者，上面都有开发主管，主管下面带领几个小弟干活，CTO给主管授权说，你可以招聘5个小弟干活，新来任务，如果小弟还不到吴哥，立即去招聘一个来干这个新来的任务，当5个小弟都招来了，再来任务之后，将任务记录到一个表格中，表格中最多记录100个，小弟们会主动去表格中获取任务执行，如果5个小弟都在干活，并且表格中也记录满了，那你可以将小弟扩充到20个，如果20个小弟都在干活，并且存放任务的表也满了，产品经理再来任务后，是直接拒绝，还是让产品自己干，这个由你自己决定，小弟们都尽心尽力在干活，任务都被处理完了，突然公司业绩下滑，几个员工没事干，打酱油，为了节约成本，CTO主管把小弟控制到5人，其他15个人直接被干掉了。所以作为小弟们，别让自己闲着，多干活。</p><p><strong>原理：</strong>先找几个人干活，大家都忙于干活，任务太多可以排期，排期的任务太多了，再招一些人来干活，最后干活的和排期都达到上层领导要求的上限了，那需要采取一些其他策略进行处理了。对于长时间不干活的人，考虑将其开掉，节约资源和成本。</p><p><img src="/images/1.JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/1614161583621-6ff005f3-9806-4c18-a497-e655aec5a2d0.png" alt="image"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                          TimeUnit unit,</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="literal">null</span> || threadFactory == <span class="literal">null</span> || handler == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="built_in">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="built_in">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="built_in">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="built_in">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="built_in">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>corePoolSize：核心线程大小，当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使有其他空闲线程可以处理任务也会创新线程，等到工作的线程数大于核心线程数时就不会在创建了。如果调用了线程池的<code>prestartAllCoreThreads</code>方法，线程池会提前把核心线程都创造好，并启动</p></li><li><p>maximumPoolSize：线程池允许创建的最大线程数，此值必须大于等于1。如果队列满了，并且以创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。如果我们使用了无界队列，那么所有的任务会加入队列，这个参数就没有什么效果了</p></li><li><p>keepAliveTime：多余的空闲线程的存活时间,当前池中线程数量超过corePoolSize时，当空闲时间,达到keepAliveTime时，多余线程会被销毁直到只剩下corePoolSize个线程为止，如果任务很多，并且每个任务的执行时间比较短，避免线程重复创建和回收，可以调大这个时间，提高线程的利用率</p></li><li><p>unit：keepAliveTIme的时间单位，可以选择的单位有天、小时、分钟、毫秒、微妙、千分之一毫秒和纳秒。类型是一个枚举<code>java.util.concurrent.TimeUnit</code>，这个枚举也经常使用</p></li><li><p>workQueue：任务队列，被提交但尚未被执行的任务，用于缓存待处理任务的阻塞队列</p></li><li><p>threadFactory：表示生成线程池中工作线程的线程工厂，用于创建线程，一般默认的即可，可以通过线程工厂给每个创建出来的线程设置更有意义的名字</p></li><li><p>handler：拒绝策略，表示当队列满了，并且工作线程大于等于线程池的最大线程数（maximumPoolSize）时如何来拒绝请求执行的runnable的策略</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/1614161593084-bebbf57e-a1cd-4178-b763-24959203717b.png" alt="image"></p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/1614161599622-b82c39bb-1dbb-495e-9e4a-78f413f1c724.png" alt="image"></p><p><strong>调用线程池的execute方法处理任务，执行execute方法的过程：</strong></p><ol><li>判断线程池中运行的线程数是否小于corepoolsize，是：则创建新的线程来处理任务，否：执行下一步</li><li>试图将任务添加到workQueue指定的队列中，如果无法添加到队列，进入下一步</li><li>判断线程池中运行的线程数是否小于<code>maximumPoolSize</code>，是：则新增线程处理当前传入的任务，否：将任务传递给<code>handler</code>对象<code>rejectedExecution</code>方法处理</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1、在创建了线程池后，开始等待请求。</span><br><span class="line">2、当调用execute()方法添加一个请求任务时，线程池会做出如下判断：</span><br><span class="line">  2.1如果正在运行的线程数量小于corePoolSize，那么马上创建线程运行这个任务；</span><br><span class="line">  2.2如果正在运行的线程数量大于或等于corePoolSize，那么将这个任务放入队列；</span><br><span class="line">  2.3如果这个时候队列满了且正在运行的线程数量还小于maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务；</span><br><span class="line">  2.4如果队列满了且正在运行的线程数量大于或等于maximumPoolSize，那么线程池会启动饱和拒绝策略来执行。</span><br><span class="line">3、当一个线程完成任务时，它会从队列中取下一个任务来执行。</span><br><span class="line">4、当一个线程无事可做超过一定的时间（keepAliveTime）时，线程会判断：</span><br><span class="line">    如果当前运行的线程数大于corePoolSize，那么这个线程就被停掉。</span><br><span class="line">    所以线程池的所有任务完成后，它最终会收缩到corePoolSize的大小。</span><br></pre></td></tr></table></figure><h3 id="5、拒绝策略？生产中如设置合理参数"><a href="#5、拒绝策略？生产中如设置合理参数" class="headerlink" title="5、拒绝策略？生产中如设置合理参数"></a>5、拒绝策略？生产中如设置合理参数</h3><h4 id="1、线程池的拒绝策略"><a href="#1、线程池的拒绝策略" class="headerlink" title="1、线程池的拒绝策略"></a>1、线程池的拒绝策略</h4><p>​等待队列已经排满了，再也塞不下新任务了，同时，线程池中的max线程也达到了，无法继续为新任务服务。这个是时候我们就需要拒绝策略机制合理的处理这个问题。</p><h4 id="2、JDK内置的拒绝策略"><a href="#2、JDK内置的拒绝策略" class="headerlink" title="2、JDK内置的拒绝策略"></a>2、JDK内置的拒绝策略</h4><p>AbortPolicy(默认)：直接抛出RejectedExecutionException异常阻止系统正常运行</p><p>CallerRunsPolicy：“调用者运行”一种调节机制，该策略既不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者，从而降低新任务的流量。</p><p>DiscardOldestPolicy：抛弃队列中等待最久的任务，然后把当前任务加入队列中尝试再次提交当前任务。</p><p>DiscardPolicy：该策略默默地丢弃无法处理的任务，不予任何处理也不抛出异常。如果允许任务丢失，这是最好的一种策略。</p><p><strong>以上内置拒绝策略均实现了RejectedExecutionHandle接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo5</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        String name;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Task</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;处理&quot;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Task&#123;&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                    <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>,</span><br><span class="line">                <span class="number">1</span>,</span><br><span class="line">                <span class="number">60L</span>,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;Runnable&gt;(<span class="number">1</span>),</span><br><span class="line">                Executors.defaultThreadFactory(),</span><br><span class="line">                (r, executors) -&gt; &#123;</span><br><span class="line">                    <span class="comment">//自定义饱和策略</span></span><br><span class="line">                    <span class="comment">//记录一下无法处理的任务</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;无法处理的任务：&quot;</span> + r.toString());</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            executor.execute(<span class="keyword">new</span> <span class="title class_">Task</span>(<span class="string">&quot;任务-&quot;</span> + i));</span><br><span class="line">        &#125;</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">无法处理的任务：Task&#123;name=<span class="string">&#x27;任务-2&#x27;</span>&#125;</span><br><span class="line">无法处理的任务：Task&#123;name=<span class="string">&#x27;任务-3&#x27;</span>&#125;</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>处理任务-<span class="number">0</span></span><br><span class="line">无法处理的任务：Task&#123;name=<span class="string">&#x27;任务-4&#x27;</span>&#125;</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>处理任务-<span class="number">1</span></span><br></pre></td></tr></table></figure><p>输出结果中可以看到有3个任务进入了饱和策略中，记录了任务的日志，对于无法处理多任务，我们最好能够记录一下，让开发人员能够知道。任务进入了饱和策略，说明线程池的配置可能不是太合理，或者机器的性能有限，需要做一些优化调整。</p><h4 id="3、生产中合理的设置参数"><a href="#3、生产中合理的设置参数" class="headerlink" title="3、生产中合理的设置参数"></a>3、生产中合理的设置参数</h4><p>要想合理的配置线程池，需要先分析任务的特性，可以从以下几个角度分析：</p><ul><li>任务的性质：CPU密集型任务、IO密集型任务和混合型任务</li><li>任务的优先级：高、中、低</li><li>任务的执行时间：长、中、短</li><li>任务的依赖性：是否依赖其他的系统资源，如数据库连接。</li></ul><p>性质不同任务可以用不同规模的线程池分开处理。CPU密集型任务应该尽可能小的线程，如配置cpu数量+1个线程的线程池。由于IO密集型任务并不是一直在执行任务，不能让cpu闲着，则应配置尽可能多的线程，如：cup数量*2。混合型的任务，如果可以拆分，将其拆分成一个CPU密集型任务和一个IO密集型任务，只要这2个任务执行的时间相差不是太大，那么分解后执行的吞吐量将高于串行执行的吞吐量。可以通过<code>Runtime.getRuntime().availableProcessors()</code>方法获取cpu数量。优先级不同任务可以对线程池采用优先级队列来处理，让优先级高的先执行。</p><p>使用队列的时候建议使用有界队列，有界队列增加了系统的稳定性，如果采用无解队列，任务太多的时候可能导致系统OOM，直接让系统宕机。</p><p>线程池汇总线程大小对系统的性能有一定的影响，我们的目标是希望系统能够发挥最好的性能，过多或者过小的线程数量无法有消息的使用机器的性能。咋Java Concurrency inPractice书中给出了估算线程池大小的公式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Ncpu = CUP的数量</span><br><span class="line">Ucpu = 目标CPU的使用率，<span class="number">0</span>&lt;=Ucpu&lt;=<span class="number">1</span></span><br><span class="line">W/C = 等待时间与计算时间的比例</span><br><span class="line">为保存处理器达到期望的使用率，最有的线程池的大小等于：</span><br><span class="line">Nthreads = Ncpu × Ucpu × (<span class="number">1</span>+W/C)</span><br></pre></td></tr></table></figure><ol><li><p>CPU密集型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查看CPU核数</span></span><br><span class="line">System. out .println(Runtime. getRuntime ().availableProcessors());</span><br></pre></td></tr></table></figure><p>￼<img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20220329145519183.png" alt="image-20220329145519183"></p></li><li><p>IO密集型</p><ol><li>由于IO密集型任务线程并不是一直在执行任务，则应配置尽可能多的线程，如<strong>CPU核数 * 2</strong> 。</li><li><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20220329145652545.png" alt="image-20220329145652545"></li></ol></li></ol><p>看公司业务是CPU密集型还是IO密集型的，这两种不一样，来决定线程池线程数的最佳合理配置数。</p><h3 id="6、超级大坑-在工作中单一的-x2F-固定数的-x2F-可变的三种创建线程池的方法哪个用的多？"><a href="#6、超级大坑-在工作中单一的-x2F-固定数的-x2F-可变的三种创建线程池的方法哪个用的多？" class="headerlink" title="6、超级大坑 在工作中单一的&#x2F;固定数的&#x2F;可变的三种创建线程池的方法哪个用的多？"></a>6、超级大坑 在工作中单一的&#x2F;固定数的&#x2F;可变的三种创建线程池的方法哪个用的多？</h3><p>答案是<strong>一个都不用</strong>，我们工作中只能使用自定义的</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/1614161641934-fd8ddb1d-5b05-4d88-81c6-04a40367c591.png" alt="image"></p><h3 id="7、自定义线程池"><a href="#7、自定义线程池" class="headerlink" title="7、自定义线程池"></a>7、自定义线程池</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程池</span></span><br><span class="line"><span class="comment"> * Arrays</span></span><br><span class="line"><span class="comment"> * Collections</span></span><br><span class="line"><span class="comment"> * Executors</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThreadPoolDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">                <span class="number">2</span>,</span><br><span class="line">                <span class="number">5</span>,</span><br><span class="line">                <span class="number">2L</span>,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;Runnable&gt;(<span class="number">3</span>),</span><br><span class="line">                Executors.defaultThreadFactory(),</span><br><span class="line">                <span class="comment">//new ThreadPoolExecutor.AbortPolicy()</span></span><br><span class="line">                <span class="comment">//new ThreadPoolExecutor.CallerRunsPolicy()</span></span><br><span class="line">                <span class="comment">//new ThreadPoolExecutor.DiscardOldestPolicy()</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.DiscardPolicy()</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">//10个顾客请求</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                threadPool.execute(() -&gt; &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 办理业务&quot;</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">threadPool</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//List list = new ArrayList();</span></span><br><span class="line">        <span class="comment">//List list = Arrays.asList(&quot;a&quot;,&quot;b&quot;);</span></span><br><span class="line">        <span class="comment">//固定数的线程池，一池五线程</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//       ExecutorService threadPool =  Executors.newFixedThreadPool(5); //一个银行网点，5个受理业务的窗口</span></span><br><span class="line"><span class="comment">//       ExecutorService threadPool =  Executors.newSingleThreadExecutor(); //一个银行网点，1个受理业务的窗口</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newCachedThreadPool(); <span class="comment">//一个银行网点，可扩展受理业务的窗口</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//10个顾客请求</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                threadPool.execute(() -&gt; &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 办理业务&quot;</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8、线程池中的2个关闭方法"><a href="#8、线程池中的2个关闭方法" class="headerlink" title="8、线程池中的2个关闭方法"></a>8、线程池中的2个关闭方法</h3><p>线程池提供了2个关闭方法：<code>shutdown</code>和<code>shutdownNow</code>，当调用者两个方法之后，线程池会遍历内部的工作线程，然后调用每个工作线程的interrrupt方法给线程发送中断信号，内部如果无法响应中断信号的可能永远无法终止，所以如果内部有无线循环的，最好在循环内部检测一下线程的中断信号，合理的退出。调用者两个方法中任意一个，线程池的<code>isShutdown</code>方法就会返回true，当所有的任务线程都关闭之后，才表示线程池关闭成功，这时调用<code>isTerminaed</code>方法会返回true。</p><p>调用<code>shutdown</code>方法之后，线程池将不再接口新任务，内部会将所有已提交的任务处理完毕，处理完毕之后，工作线程自动退出。</p><p>而调用<code>shutdownNow</code>方法后，线程池会将还未处理的（在队里等待处理的任务）任务移除，将正在处理中的处理完毕之后，工作线程自动退出。</p><p>至于调用哪个方法来关闭线程，应该由提交到线程池的任务特性决定，多数情况下调用<code>shutdown</code>方法来关闭线程池，如果任务不一定要执行完，则可以调用<code>shutdownNow</code>方法。</p><h3 id="9、BlockingQueue阻塞队列"><a href="#9、BlockingQueue阻塞队列" class="headerlink" title="9、BlockingQueue阻塞队列"></a>9、BlockingQueue阻塞队列</h3><h4 id="1、栈与队列"><a href="#1、栈与队列" class="headerlink" title="1、栈与队列"></a>1、栈与队列</h4><p>栈：先进后出，后进先出</p><p>队列：先进先出</p><h4 id="2、阻塞队列"><a href="#2、阻塞队列" class="headerlink" title="2、阻塞队列"></a>2、阻塞队列</h4><p>阻塞：必须要阻塞&#x2F;不得不阻塞 </p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/1614161550577-d838e7b4-62c9-4630-ad52-34ecf72f3aee.png" alt="image"></p><p>线程1往阻塞队列里添加元素，线程2从阻塞队列里移除元素</p><p>当队列是空的，从队列中获取元素的操作将会被阻塞</p><p>当队列是满的，从队列中添加元素的操作将会被阻塞</p><p>试图从空的队列中获取元素的线程将会被阻塞，直到其他线程往空的队列插入新的元素</p><p>试图向已满的队列中添加新元素的线程将会被阻塞，直到其他线程从队列中移除一个或多个元素或者完全清空，使队列变得空闲起来并后续新增</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/1614161556740-782f1ca1-a941-4b76-b581-4b9ffef9a5ca.png" alt="image"></p><h4 id="3、种类分析"><a href="#3、种类分析" class="headerlink" title="3、种类分析"></a>3、种类分析</h4><p><strong>ArrayBlockingQueue</strong>：是一个基于数组结构的有界阻塞队列，此队列按照先进先出原则对元素进行排序</p><p><strong>LinkedBlockingQueue</strong>：由链表结构组成的有界（但大小默认值为integer.MAX_VALUE）阻塞队列，此队列按照先进先出排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法<code>Executors.newFixedThreadPool</code>使用了这个队列。</p><p>PriorityBlockingQueue：支持优先级排序的无界阻塞队列。</p><p>DelayQueue：使用优先级队列实现的延迟无界阻塞队列。</p><p><strong>SynchronousQueue</strong>：不存储元素的阻塞队列，也即单个元素的队列,每个插入操作必须等到另外一个线程调用移除操作，否则插入操作一直处理阻塞状态，吞吐量通常要高于LinkedBlockingQueue，静态工厂方法<code>Executors.newCachedThreadPool</code>使用这个队列</p><p>LinkedTransferQueue：由链表组成的无界阻塞队列。</p><p>LinkedBlockingDeque：由链表组成的双向阻塞队列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="type">String</span> <span class="variable">taskName</span> <span class="operator">=</span> <span class="string">&quot;任务&quot;</span> + j;</span><br><span class="line">            executor.execute(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;处理&quot;</span> + taskName);</span><br><span class="line">                <span class="comment">//模拟任务内部处理耗时</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中使用<code>Executors.newCachedThreadPool()</code>创建线程池，看一下的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从输出中可以看出，系统创建了50个线程处理任务，代码中使用了<code>SynchronousQueue</code>同步队列，这种队列比较特殊，放入元素必须要有另外一个线程去获取这个元素，否则放入元素会失败或者一直阻塞在那里直到有线程取走，示例中任务处理休眠了指定的时间，导致已创建的工作线程都忙于处理任务，所以新来任务之后，将任务丢入同步队列会失败，丢入队列失败之后，会尝试新建线程处理任务。使用上面的方式创建线程池需要注意，如果需要处理的任务比较耗时，会导致新来的任务都会创建新的线程进行处理，可能会导致创建非常多的线程，最终耗尽系统资源，触发OOM。</p><p><strong>PriorityBlockingQueue优先级队列的线程池</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo3</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>, Comparable&lt;Task&gt; &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Task</span><span class="params">(<span class="type">int</span> i, String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.i = i;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;处理&quot;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Task o)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.compare(o.i, <span class="built_in">this</span>.i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">PriorityBlockingQueue</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">taskName</span> <span class="operator">=</span> <span class="string">&quot;任务&quot;</span> + i;</span><br><span class="line">            executor.execute(<span class="keyword">new</span> <span class="title class_">Task</span>(i, taskName));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100</span>; i &gt;= <span class="number">90</span>; i--) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">taskName</span> <span class="operator">=</span> <span class="string">&quot;任务&quot;</span> + i;</span><br><span class="line">            executor.execute(<span class="keyword">new</span> <span class="title class_">Task</span>(i, taskName));</span><br><span class="line">        &#125;</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出中，除了第一个任务，其他任务按照优先级高低按顺序处理。原因在于：创建线程池的时候使用了优先级队列，进入队列中的任务会进行排序，任务的先后顺序由Task中的i变量决定。向<code>PriorityBlockingQueue</code>加入元素的时候，内部会调用代码中Task的<code>compareTo</code>方法决定元素的先后顺序。</p><h4 id="4、BlockingQueue核心方法"><a href="#4、BlockingQueue核心方法" class="headerlink" title="4、BlockingQueue核心方法"></a>4、BlockingQueue核心方法</h4><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/1614161565952-60513c15-8261-450d-9fd3-57f35be66a42.png" alt="image"></p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/1614161571726-0fb6d810-ca4c-4f9f-b0c7-ee1282a95d7e.png" alt="image"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 阻塞队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlockingQueueDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        List list = new ArrayList();</span></span><br><span class="line"></span><br><span class="line">        BlockingQueue&lt;String&gt; blockingQueue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//第一组</span></span><br><span class="line"><span class="comment">//        System.out.println(blockingQueue.add(&quot;a&quot;));</span></span><br><span class="line"><span class="comment">//        System.out.println(blockingQueue.add(&quot;b&quot;));</span></span><br><span class="line"><span class="comment">//        System.out.println(blockingQueue.add(&quot;c&quot;));</span></span><br><span class="line"><span class="comment">//        System.out.println(blockingQueue.element());</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//System.out.println(blockingQueue.add(&quot;x&quot;));</span></span><br><span class="line"><span class="comment">//        System.out.println(blockingQueue.remove());</span></span><br><span class="line"><span class="comment">//        System.out.println(blockingQueue.remove());</span></span><br><span class="line"><span class="comment">//        System.out.println(blockingQueue.remove());</span></span><br><span class="line"><span class="comment">//        System.out.println(blockingQueue.remove());</span></span><br><span class="line"><span class="comment">//    第二组</span></span><br><span class="line"><span class="comment">//        System.out.println(blockingQueue.offer(&quot;a&quot;));</span></span><br><span class="line"><span class="comment">//        System.out.println(blockingQueue.offer(&quot;b&quot;));</span></span><br><span class="line"><span class="comment">//        System.out.println(blockingQueue.offer(&quot;c&quot;));</span></span><br><span class="line"><span class="comment">//        System.out.println(blockingQueue.offer(&quot;x&quot;));</span></span><br><span class="line"><span class="comment">//        System.out.println(blockingQueue.poll());</span></span><br><span class="line"><span class="comment">//        System.out.println(blockingQueue.poll());</span></span><br><span class="line"><span class="comment">//        System.out.println(blockingQueue.poll());</span></span><br><span class="line"><span class="comment">//        System.out.println(blockingQueue.poll());</span></span><br><span class="line"><span class="comment">//    第三组        </span></span><br><span class="line"><span class="comment">//         blockingQueue.put(&quot;a&quot;);</span></span><br><span class="line"><span class="comment">//         blockingQueue.put(&quot;b&quot;);</span></span><br><span class="line"><span class="comment">//         blockingQueue.put(&quot;c&quot;);</span></span><br><span class="line"><span class="comment">//         //blockingQueue.put(&quot;x&quot;);</span></span><br><span class="line"><span class="comment">//        System.out.println(blockingQueue.take());</span></span><br><span class="line"><span class="comment">//        System.out.println(blockingQueue.take());</span></span><br><span class="line"><span class="comment">//        System.out.println(blockingQueue.take());</span></span><br><span class="line"><span class="comment">//        System.out.println(blockingQueue.take());</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//    第四组        </span></span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="string">&quot;a&quot;</span>));</span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="string">&quot;b&quot;</span>));</span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="string">&quot;c&quot;</span>));</span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="string">&quot;a&quot;</span>,<span class="number">3L</span>, TimeUnit.SECONDS));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10、扩展线程池"><a href="#10、扩展线程池" class="headerlink" title="10、扩展线程池"></a>10、扩展线程池</h3><p>虽然jdk提供了<code>ThreadPoolExecutor</code>这个高性能线程池，但是如果我们自己想在这个线程池上面做一些扩展，比如，监控每个任务执行的开始时间，结束时间，或者一些其他自定义的功能，我们应该怎么办？</p><p>这个jdk已经帮我们想到了，<code>ThreadPoolExecutor</code>内部提供了几个方法<code>beforeExecute</code>、<code>afterExecute</code>、<code>terminated</code>，可以由开发人员自己去这些方法。看一下线程池内部的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    beforeExecute(wt, task);<span class="comment">//任务执行之前调用的方法</span></span><br><span class="line">    <span class="type">Throwable</span> <span class="variable">thrown</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        task.run();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">        thrown = x;</span><br><span class="line">        <span class="keyword">throw</span> x;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">        thrown = x;</span><br><span class="line">        <span class="keyword">throw</span> x;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">        thrown = x;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(x);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        afterExecute(task, thrown);<span class="comment">//任务执行完毕之后调用的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    task = <span class="literal">null</span>;</span><br><span class="line">    w.completedTasks++;</span><br><span class="line">    w.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>beforeExecute：任务执行之前调用的方法，有2个参数，第1个参数是执行任务的线程，第2个参数是任务</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">beforeExecute</span><span class="params">(Thread t, Runnable r)</span> &#123; &#125;</span><br></pre></td></tr></table></figure><p><strong>afterExecute：任务执行完成之后调用的方法，2个参数，第1个参数表示任务，第2个参数表示任务执行时的异常信息，如果无异常，第二个参数为null</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">afterExecute</span><span class="params">(Runnable r, Throwable t)</span> &#123; &#125;</span><br></pre></td></tr></table></figure><p><strong>terminated：线程池最终关闭之后调用的方法。所有的工作线程都退出了，最终线程池会退出，退出时调用该方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo6</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        String name;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Task</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;处理&quot;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Task&#123;&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                    <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">10</span>,</span><br><span class="line">                <span class="number">10</span>,</span><br><span class="line">                <span class="number">60L</span>,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;Runnable&gt;(<span class="number">1</span>),</span><br><span class="line">                Executors.defaultThreadFactory(),</span><br><span class="line">                (r, executors) -&gt; &#123;</span><br><span class="line">                    <span class="comment">//自定义饱和策略</span></span><br><span class="line">                    <span class="comment">//记录一下无法处理的任务</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;无法处理的任务：&quot;</span> + r.toString());</span><br><span class="line">                &#125;) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">beforeExecute</span><span class="params">(Thread t, Runnable r)</span> &#123;</span><br><span class="line">                System.out.println(System.currentTimeMillis() + <span class="string">&quot;,&quot;</span> + t.getName() + <span class="string">&quot;,开始执行任务:&quot;</span> + r.toString());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">afterExecute</span><span class="params">(Runnable r, Throwable t)</span> &#123;</span><br><span class="line">                System.out.println(System.currentTimeMillis() + <span class="string">&quot;,&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;,任务:&quot;</span> + r.toString() + <span class="string">&quot;，执行完毕!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">terminated</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(System.currentTimeMillis() + <span class="string">&quot;,&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;，关闭线程池!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            executor.execute(<span class="keyword">new</span> <span class="title class_">Task</span>(<span class="string">&quot;任务-&quot;</span> + i));</span><br><span class="line">        &#125;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1564324574847</span>,pool-<span class="number">1</span>-thread-<span class="number">1</span>,开始执行任务:Task&#123;name=<span class="string">&#x27;任务-0&#x27;</span>&#125;</span><br><span class="line"><span class="number">1564324574850</span>,pool-<span class="number">1</span>-thread-<span class="number">3</span>,开始执行任务:Task&#123;name=<span class="string">&#x27;任务-2&#x27;</span>&#125;</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span>处理任务-<span class="number">2</span></span><br><span class="line"><span class="number">1564324574849</span>,pool-<span class="number">1</span>-thread-<span class="number">2</span>,开始执行任务:Task&#123;name=<span class="string">&#x27;任务-1&#x27;</span>&#125;</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>处理任务-<span class="number">1</span></span><br><span class="line"><span class="number">1564324574848</span>,pool-<span class="number">1</span>-thread-<span class="number">5</span>,开始执行任务:Task&#123;name=<span class="string">&#x27;任务-4&#x27;</span>&#125;</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span>处理任务-<span class="number">4</span></span><br><span class="line"><span class="number">1564324574848</span>,pool-<span class="number">1</span>-thread-<span class="number">4</span>,开始执行任务:Task&#123;name=<span class="string">&#x27;任务-3&#x27;</span>&#125;</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span>处理任务-<span class="number">3</span></span><br><span class="line"><span class="number">1564324574850</span>,pool-<span class="number">1</span>-thread-<span class="number">7</span>,开始执行任务:Task&#123;name=<span class="string">&#x27;任务-6&#x27;</span>&#125;</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">7</span>处理任务-<span class="number">6</span></span><br><span class="line"><span class="number">1564324574850</span>,pool-<span class="number">1</span>-thread-<span class="number">6</span>,开始执行任务:Task&#123;name=<span class="string">&#x27;任务-5&#x27;</span>&#125;</span><br><span class="line"><span class="number">1564324574851</span>,pool-<span class="number">1</span>-thread-<span class="number">8</span>,开始执行任务:Task&#123;name=<span class="string">&#x27;任务-7&#x27;</span>&#125;</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">8</span>处理任务-<span class="number">7</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>处理任务-<span class="number">0</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">6</span>处理任务-<span class="number">5</span></span><br><span class="line"><span class="number">1564324574851</span>,pool-<span class="number">1</span>-thread-<span class="number">10</span>,开始执行任务:Task&#123;name=<span class="string">&#x27;任务-9&#x27;</span>&#125;</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">10</span>处理任务-<span class="number">9</span></span><br><span class="line"><span class="number">1564324574852</span>,pool-<span class="number">1</span>-thread-<span class="number">9</span>,开始执行任务:Task&#123;name=<span class="string">&#x27;任务-8&#x27;</span>&#125;</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">9</span>处理任务-<span class="number">8</span></span><br><span class="line"><span class="number">1564324576851</span>,pool-<span class="number">1</span>-thread-<span class="number">2</span>,任务:Task&#123;name=<span class="string">&#x27;任务-1&#x27;</span>&#125;，执行完毕!</span><br><span class="line"><span class="number">1564324576851</span>,pool-<span class="number">1</span>-thread-<span class="number">3</span>,任务:Task&#123;name=<span class="string">&#x27;任务-2&#x27;</span>&#125;，执行完毕!</span><br><span class="line"><span class="number">1564324576852</span>,pool-<span class="number">1</span>-thread-<span class="number">1</span>,任务:Task&#123;name=<span class="string">&#x27;任务-0&#x27;</span>&#125;，执行完毕!</span><br><span class="line"><span class="number">1564324576852</span>,pool-<span class="number">1</span>-thread-<span class="number">4</span>,任务:Task&#123;name=<span class="string">&#x27;任务-3&#x27;</span>&#125;，执行完毕!</span><br><span class="line"><span class="number">1564324576852</span>,pool-<span class="number">1</span>-thread-<span class="number">8</span>,任务:Task&#123;name=<span class="string">&#x27;任务-7&#x27;</span>&#125;，执行完毕!</span><br><span class="line"><span class="number">1564324576852</span>,pool-<span class="number">1</span>-thread-<span class="number">7</span>,任务:Task&#123;name=<span class="string">&#x27;任务-6&#x27;</span>&#125;，执行完毕!</span><br><span class="line"><span class="number">1564324576852</span>,pool-<span class="number">1</span>-thread-<span class="number">5</span>,任务:Task&#123;name=<span class="string">&#x27;任务-4&#x27;</span>&#125;，执行完毕!</span><br><span class="line"><span class="number">1564324576853</span>,pool-<span class="number">1</span>-thread-<span class="number">6</span>,任务:Task&#123;name=<span class="string">&#x27;任务-5&#x27;</span>&#125;，执行完毕!</span><br><span class="line"><span class="number">1564324576853</span>,pool-<span class="number">1</span>-thread-<span class="number">10</span>,任务:Task&#123;name=<span class="string">&#x27;任务-9&#x27;</span>&#125;，执行完毕!</span><br><span class="line"><span class="number">1564324576853</span>,pool-<span class="number">1</span>-thread-<span class="number">9</span>,任务:Task&#123;name=<span class="string">&#x27;任务-8&#x27;</span>&#125;，执行完毕!</span><br><span class="line"><span class="number">1564324576853</span>,pool-<span class="number">1</span>-thread-<span class="number">9</span>，关闭线程池!</span><br></pre></td></tr></table></figure><p>从输出结果中可以看到，每个需要执行的任务打印了3行日志，执行前由线程池的<code>beforeExecute</code>打印，执行时会调用任务的<code>run</code>方法，任务执行完毕之后，会调用线程池的<code>afterExecute</code>方法，从每个任务的首尾2条日志中可以看到每个任务耗时2秒左右。线程池最终关闭之后调用了<code>terminated</code>方法。</p><h2 id="三、CompletableFuture"><a href="#三、CompletableFuture" class="headerlink" title="三、CompletableFuture"></a>三、CompletableFuture</h2><h3 id="1、Future和Callable接口"><a href="#1、Future和Callable接口" class="headerlink" title="1、Future和Callable接口"></a>1、Future和Callable接口</h3><p>Future接口定义了操作异步任务执行一些方法，如获取异步任务的执行结果、取消任务的执行、判断任务是否被取消、判断任务执行是否完毕等。</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210904000352470.png" alt="image-20210904000352470"></p><p>Callable接口中定义了需要有返回的任务需要实现的方法</p><p>比如主线程让一个子线程去执行任务，子线程可能比较耗时，启动子线程开始执行任务后，主线程就去做其他事情了，过了一会才去获取子任务的执行结果。</p><h3 id="2、从之前的FutureTask开始"><a href="#2、从之前的FutureTask开始" class="headerlink" title="2、从之前的FutureTask开始"></a>2、从之前的FutureTask开始</h3><p>Future接口相关架构</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210904000518011.png"></p><p><img src="/images/1.JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20210904000529226.png" alt="image-20210904000529226"></p><h4 id="code1"><a href="#code1" class="headerlink" title="code1"></a>code1</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableFutureDemo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException, TimeoutException&#123;</span><br><span class="line">        FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;-----come in FutureTask&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">3</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            <span class="keyword">return</span> ThreadLocalRandom.current().nextInt(<span class="number">100</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3秒钟后才出来结果，还没有计算你提前来拿(只要一调用get方法，对于结果就是不见不散，会导致阻塞)</span></span><br><span class="line">        <span class="comment">//System.out.println(Thread.currentThread().getName()+&quot;\t&quot;+futureTask.get());</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3秒钟后才出来结果，我只想等待1秒钟，过时不候</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+futureTask.get(<span class="number">1L</span>,TimeUnit.SECONDS));</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot; run... here&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>get()阻塞   一旦调用get()方法，不管是否计算完成都会导致阻塞</li></ul><h4 id="code2"><a href="#code2" class="headerlink" title="code2"></a>code2</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableFutureDemo2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;-----come in FutureTask&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">3</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>+ ThreadLocalRandom.current().nextInt(<span class="number">100</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;线程完成任务&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 用于阻塞式获取结果,如果想要异步获取结果,通常都会以轮询的方式去获取结果</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(futureTask.isDone())&#123;</span><br><span class="line">                System.out.println(futureTask.get());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>isDone()轮询</p><p>轮询的方式会耗费无谓的CPU资源，而且也不见得能及时地得到计算结果.</p><p>如果想要异步获取结果,通常都会以轮询的方式去获取结果<br>尽量不要阻塞</p><p>不见不散 – 过时不候 – 轮询</p><h3 id="3、对Future的改进"><a href="#3、对Future的改进" class="headerlink" title="3、对Future的改进"></a>3、对Future的改进</h3><h4 id="1、类CompletableFuture"><a href="#1、类CompletableFuture" class="headerlink" title="1、类CompletableFuture"></a>1、类CompletableFuture</h4><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210904001054865.png" alt="image-20210904001054865"></p><p><img src="/images/1.JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20210904001102892.png" alt="image-20210904001102892"></p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210904001143180.png" alt="image-20210904001143180"></p><h4 id="2、接口CompletionStage"><a href="#2、接口CompletionStage" class="headerlink" title="2、接口CompletionStage"></a>2、接口CompletionStage</h4><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210904001214909.png" alt="image-20210904001214909"></p><p>代表异步计算过程中的某一个阶段，一个阶段完成以后可能会触发另外一个阶段，有些类似Linux系统的管道分隔符传参数。</p><h3 id="4、核心的四个静态方法"><a href="#4、核心的四个静态方法" class="headerlink" title="4、核心的四个静态方法"></a>4、核心的四个静态方法</h3><h4 id="1、runAsync-无-返回值"><a href="#1、runAsync-无-返回值" class="headerlink" title="1、runAsync 无 返回值"></a>1、runAsync 无 返回值</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title function_">runAsync</span><span class="params">(Runnable runnable)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title function_">runAsync</span><span class="params">(Runnable runnable,Executor executor)</span>  </span><br></pre></td></tr></table></figure><h4 id="2、supplyAsync-有-返回值"><a href="#2、supplyAsync-有-返回值" class="headerlink" title="2、supplyAsync 有 返回值"></a>2、supplyAsync 有 返回值</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier,Executor executor)</span></span><br></pre></td></tr></table></figure><p>上述Executor executor参数说明</p><p>没有指定Executor的方法，直接使用默认的ForkJoinPool.commonPool() 作为它的线程池执行异步代码。</p><p>如果指定线程池，则使用我们自定义的或者特别指定的线程池执行异步代码</p><h4 id="3、Code-无-返回值"><a href="#3、Code-无-返回值" class="headerlink" title="3、Code 无 返回值"></a>3、Code 无 返回值</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableFutureDemo3</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException&#123;</span><br><span class="line">        CompletableFuture&lt;Void&gt; future = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;-----come in&quot;</span>);</span><br><span class="line">            <span class="comment">//暂停几秒钟线程</span></span><br><span class="line">            <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">1</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;-----task is over&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(future.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210904001511947.png" alt="image-20210904001511947"></p><h4 id="4、Code-有-返回值"><a href="#4、Code-有-返回值" class="headerlink" title="4、Code 有 返回值"></a>4、Code 有 返回值</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableFutureDemo3</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException&#123;</span><br><span class="line">        CompletableFuture&lt;Integer&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;-----come in&quot;</span>);</span><br><span class="line">            <span class="comment">//暂停几秒钟线程</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ThreadLocalRandom.current().nextInt(<span class="number">100</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        System.out.println(completableFuture.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5、Code-减少阻塞和轮询"><a href="#5、Code-减少阻塞和轮询" class="headerlink" title="5、Code 减少阻塞和轮询"></a>5、Code 减少阻塞和轮询</h4><p>从Java8开始引入了CompletableFuture，它是Future的功能增强版，可以传入回调对象，当异步任务完成或者发生异常时，自动调用回调对象的回调方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableFutureDemo3</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        CompletableFuture&lt;Integer&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;-----come in&quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> ThreadLocalRandom.current().nextInt(<span class="number">10</span>);</span><br><span class="line">            <span class="comment">//暂停几秒钟线程</span></span><br><span class="line">            <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">1</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;-----计算结束耗时1秒钟，result： &quot;</span>+result);</span><br><span class="line">            <span class="keyword">if</span>(result &gt; <span class="number">6</span>)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">10</span>/<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;).whenComplete((v,e) -&gt;&#123;</span><br><span class="line">            <span class="keyword">if</span>(e == <span class="literal">null</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;-----result: &quot;</span>+v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).exceptionally(e -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;-----exception: &quot;</span>+e.getCause()+<span class="string">&quot;\t&quot;</span>+e.getMessage());</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">44</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//主线程不要立刻结束，否则CompletableFuture默认使用的线程池会立刻关闭:暂停3秒钟线程</span></span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">3</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="6、CompletableFuture的优点"><a href="#6、CompletableFuture的优点" class="headerlink" title="6、CompletableFuture的优点"></a>6、CompletableFuture的优点</h4><p>异步任务结束时，会自动回调某个对象的方法；</p><p>异步任务出错时，会自动回调某个对象的方法；</p><p>主线程设置好回调后，不再关心异步任务的执行，异步任务之间可以顺序执行</p><h3 id="5、join和get对比"><a href="#5、join和get对比" class="headerlink" title="5、join和get对比"></a>5、join和get对比</h3><p>get会抛出异常，join不需要</p><h3 id="6、案例精讲-从电商网站的比价需求说开去"><a href="#6、案例精讲-从电商网站的比价需求说开去" class="headerlink" title="6、案例精讲-从电商网站的比价需求说开去"></a>6、案例精讲-从电商网站的比价需求说开去</h3><p>切记，功能→性能</p><p>​经常出现在等待某条 SQL 执行完成后，再继续执行下一条 SQL ，而这两条 SQL 本身是并无关系的，可以同时进行执行的。我们希望能够两条 SQL 同时进行处理，而不是等待其中的某一条 SQL 完成后，再继续下一条。同理，<br>对于分布式微服务的调用，按照实际业务，如果是无关联step by step的业务，可以尝试是否可以多箭齐发，同时调用。我们去比同一个商品在各个平台上的价格，要求获得一个清单列表，<br>1 step by step，查完京东查淘宝，查完淘宝查天猫……</p><p>2 all   一口气同时查询。。。。。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadLocalRandom;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">T1</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> List&lt;NetMall&gt; list = Arrays.asList(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">NetMall</span>(<span class="string">&quot;jd&quot;</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">NetMall</span>(<span class="string">&quot;tmall&quot;</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">NetMall</span>(<span class="string">&quot;pdd&quot;</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">NetMall</span>(<span class="string">&quot;mi&quot;</span>)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">findPriceSync</span><span class="params">(List&lt;NetMall&gt; list,String productName)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.stream().map(mall -&gt; String.format(productName+<span class="string">&quot; %s price is %.2f&quot;</span>,mall.getNetMallName(),mall.getPriceByName(productName))).collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">findPriceASync</span><span class="params">(List&lt;NetMall&gt; list,String productName)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.stream().map(mall -&gt; CompletableFuture.supplyAsync(() -&gt; String.format(productName + <span class="string">&quot; %s price is %.2f&quot;</span>, mall.getNetMallName(), mall.getPriceByName(productName)))).collect(Collectors.toList()).stream().map(CompletableFuture::join).collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        List&lt;String&gt; list1 = findPriceSync(list, <span class="string">&quot;thinking in java&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String element : list1) &#123;</span><br><span class="line">            System.out.println(element);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;----costTime: &quot;</span>+(endTime - startTime) +<span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime2</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        List&lt;String&gt; list2 = findPriceASync(list, <span class="string">&quot;thinking in java&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String element : list2) &#123;</span><br><span class="line">            System.out.println(element);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime2</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;----costTime: &quot;</span>+(endTime2 - startTime2) +<span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NetMall</span>&#123;</span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="keyword">private</span> String netMallName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NetMall</span><span class="params">(String netMallName)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.netMallName = netMallName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getPriceByName</span><span class="params">(String productName)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> calcPrice(productName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> <span class="title function_">calcPrice</span><span class="params">(String productName)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">1</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">        <span class="keyword">return</span> ThreadLocalRandom.current().nextDouble() + productName.charAt(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7、CompletableFuture常用方法"><a href="#7、CompletableFuture常用方法" class="headerlink" title="7、CompletableFuture常用方法"></a>7、CompletableFuture常用方法</h3><h4 id="1、获得结果和触发计算"><a href="#1、获得结果和触发计算" class="headerlink" title="1、获得结果和触发计算"></a>1、获得结果和触发计算</h4><p>获取结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不见不散</span></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 过时不候</span></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 没有计算完成的情况下，给我一个替代结果 </span></span><br><span class="line"><span class="comment">// 立即获取结果不阻塞 计算完，返回计算完成后的结果  没算完，返回设定的valueIfAbsent值</span></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">getNow</span><span class="params">(T valueIfAbsent)</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableFutureDemo2</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException&#123;</span><br><span class="line">        CompletableFuture&lt;Integer&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">1</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">533</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//去掉注释上面计算没有完成，返回444</span></span><br><span class="line">        <span class="comment">//开启注释上满计算完成，返回计算结果</span></span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">2</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(completableFuture.getNow(<span class="number">444</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">join</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableFutureDemo2</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException&#123;</span><br><span class="line">        System.out.println(CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;abc&quot;</span>).thenApply(r -&gt; r + <span class="string">&quot;123&quot;</span>).join());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><p>主动触发计算</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 是否打断get方法立即返回括号值</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">complete</span><span class="params">(T value)</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableFutureDemo4</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException&#123;</span><br><span class="line">        CompletableFuture&lt;Integer&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">1</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">533</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注释掉暂停线程，get还没有算完只能返回complete方法设置的444；暂停2秒钟线程，异步线程能够计算完成返回get</span></span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">2</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当调用CompletableFuture.get()被阻塞的时候,complete方法就是结束阻塞并get()获取设置的complete里面的值.</span></span><br><span class="line">        System.out.println(completableFuture.complete(<span class="number">444</span>)+<span class="string">&quot;\t&quot;</span>+completableFuture.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><h4 id="2、对计算结果进行处理"><a href="#2、对计算结果进行处理" class="headerlink" title="2、对计算结果进行处理"></a>2、对计算结果进行处理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">thenApply</span><br><span class="line"><span class="comment">// 计算结果存在依赖关系，这两个线程串行化</span></span><br><span class="line"><span class="comment">// 由于存在依赖关系(当前步错，不走下一步)，当前步骤有异常的话就叫停。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableFutureDemo4</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException&#123;</span><br><span class="line">        <span class="comment">//当一个线程依赖另一个线程时用 thenApply 方法来把这两个线程串行化,</span></span><br><span class="line">        CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="comment">//暂停几秒钟线程</span></span><br><span class="line">            <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">1</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;111&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1024</span>;</span><br><span class="line">        &#125;).thenApply(f -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;222&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> f + <span class="number">1</span>;</span><br><span class="line">        &#125;).thenApply(f -&gt; &#123;</span><br><span class="line">            <span class="comment">//int age = 10/0; // 异常情况：那步出错就停在那步。</span></span><br><span class="line">            System.out.println(<span class="string">&quot;333&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> f + <span class="number">1</span>;</span><br><span class="line">        &#125;).whenCompleteAsync((v,e) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;*****v: &quot;</span>+v);</span><br><span class="line">        &#125;).exceptionally(e -&gt; &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;-----主线程结束，END&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程不要立刻结束，否则CompletableFuture默认使用的线程池会立刻关闭:</span></span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">2</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">&#125;   </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">handle</span><br><span class="line"><span class="comment">// 有异常也可以往下一步走，根据带的异常参数可以进一步处理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableFutureDemo4</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException&#123;</span><br><span class="line">        <span class="comment">//当一个线程依赖另一个线程时用 handle 方法来把这两个线程串行化,</span></span><br><span class="line">        <span class="comment">// 异常情况：有异常也可以往下一步走，根据带的异常参数可以进一步处理</span></span><br><span class="line">        CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="comment">//暂停几秒钟线程</span></span><br><span class="line">            <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">1</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;111&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1024</span>;</span><br><span class="line">        &#125;).handle((f,e) -&gt; &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">10</span>/<span class="number">0</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;222&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> f + <span class="number">1</span>;</span><br><span class="line">        &#125;).handle((f,e) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;333&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> f + <span class="number">1</span>;</span><br><span class="line">        &#125;).whenCompleteAsync((v,e) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;*****v: &quot;</span>+v);</span><br><span class="line">        &#125;).exceptionally(e -&gt; &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-----主线程结束，END&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程不要立刻结束，否则CompletableFuture默认使用的线程池会立刻关闭:</span></span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">2</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210904003033912.png" alt="image-20210904003033912"></p><p><img src="/images/1.JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20210904003036925.png" alt="image-20210904003036925"></p><h4 id="3、对计算结果进行消费"><a href="#3、对计算结果进行消费" class="headerlink" title="3、对计算结果进行消费"></a>3、对计算结果进行消费</h4><p>接收任务的处理结果，并消费处理，无返回结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//thenAccept</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException&#123;</span><br><span class="line">    CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;).thenApply(f -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> f + <span class="number">2</span>;</span><br><span class="line">    &#125;).thenApply(f -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> f + <span class="number">3</span>;</span><br><span class="line">    &#125;).thenApply(f -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> f + <span class="number">4</span>;</span><br><span class="line">    &#125;).thenAccept(r -&gt; System.out.println(r));</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>Code之任务之间的顺序执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">thenRun</span><br><span class="line"><span class="title function_">thenRun</span><span class="params">(Runnable runnable)</span></span><br><span class="line"><span class="comment">// 任务 A 执行完执行 B，并且 B 不需要 A 的结果</span></span><br><span class="line">    </span><br><span class="line">thenAccept</span><br><span class="line"><span class="title function_">thenAccept</span><span class="params">(Consumer action)</span></span><br><span class="line"><span class="comment">// 任务 A 执行完执行 B，B 需要 A 的结果，但是任务 B 无返回值</span></span><br><span class="line">  </span><br><span class="line">thenApply</span><br><span class="line"><span class="title function_">thenApply</span><span class="params">(Function fn)</span></span><br><span class="line"><span class="comment">// 任务 A 执行完执行 B，B 需要 A 的结果，同时任务 B 有返回值</span></span><br><span class="line"> </span><br><span class="line">System.out.println(CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;resultA&quot;</span>).thenRun(() -&gt; &#123;&#125;).join());</span><br><span class="line">System.out.println(CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;resultA&quot;</span>).thenAccept(resultA -&gt; &#123;&#125;).join());</span><br><span class="line">System.out.println(CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;resultA&quot;</span>).thenApply(resultA -&gt; resultA + <span class="string">&quot; resultB&quot;</span>).join());</span><br></pre></td></tr></table></figure><h4 id="4、对计算速度进行选用"><a href="#4、对计算速度进行选用" class="headerlink" title="4、对计算速度进行选用"></a>4、对计算速度进行选用</h4><p>谁快用谁</p><p>applyToEither</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableFutureDemo5</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException&#123;</span><br><span class="line">        CompletableFuture&lt;Integer&gt; completableFuture1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;---come in &quot;</span>);</span><br><span class="line">            <span class="comment">//暂停几秒钟线程</span></span><br><span class="line">            <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">2</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;Integer&gt; completableFuture2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;---come in &quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">1</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;Integer&gt; thenCombineResult = completableFuture1.applyToEither(completableFuture2,f -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;---come in &quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> f + <span class="number">1</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + thenCombineResult.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5、对计算结果进行合并"><a href="#5、对计算结果进行合并" class="headerlink" title="5、对计算结果进行合并"></a>5、对计算结果进行合并</h4><p>两个CompletionStage任务都完成后，最终能把两个任务的结果一起交给thenCombine 来处理</p><p>先完成的先等着，等待其它分支任务</p><p>thenCombine</p><p>code标准版，好理解先拆分</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableFutureDemo2</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException&#123;</span><br><span class="line">        CompletableFuture&lt;Integer&gt; completableFuture1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;---come in &quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;Integer&gt; completableFuture2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;---come in &quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;Integer&gt; thenCombineResult = completableFuture1.thenCombine(completableFuture2, (x, y) -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;---come in &quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> x + y;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        System.out.println(thenCombineResult.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>code表达式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableFutureDemo6</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException&#123;</span><br><span class="line">        CompletableFuture&lt;Integer&gt; thenCombineResult = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;---come in 1&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">        &#125;).thenCombine(CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;---come in 2&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">        &#125;), (x,y) -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;---come in 3&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> x + y;</span><br><span class="line">        &#125;).thenCombine(CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;---come in 4&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">30</span>;</span><br><span class="line">        &#125;),(a,b) -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;---come in 5&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> a + b;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;-----主线程结束，END&quot;</span>);</span><br><span class="line">        System.out.println(thenCombineResult.get());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程不要立刻结束，否则CompletableFuture默认使用的线程池会立刻关闭:</span></span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">10</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8、分支合并框架"><a href="#8、分支合并框架" class="headerlink" title="8、分支合并框架"></a>8、分支合并框架</h3><p>Fork：把一个复杂任务进行分拆，大事化小</p><p>Join：把分拆任务的结果进行合并</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/1614161705639-4b976bd8-4f72-4667-872a-6f5071b4405e.png" alt="image"></p><h4 id="1、相关类"><a href="#1、相关类" class="headerlink" title="1、相关类"></a>1、相关类</h4><h5 id="1、ForkJoinPool"><a href="#1、ForkJoinPool" class="headerlink" title="1、ForkJoinPool"></a>1、ForkJoinPool</h5><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/1614161713661-c27a4d4c-134a-4f28-be61-65fd50270b3a.png" alt="image"></p><h5 id="2、ForkJoinTask"><a href="#2、ForkJoinTask" class="headerlink" title="2、ForkJoinTask"></a>2、ForkJoinTask</h5><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/1614161726172-14ae279d-84af-4616-9daf-04cb700a151e.png" alt="image"></p><h5 id="3、RecursiveTask"><a href="#3、RecursiveTask" class="headerlink" title="3、RecursiveTask"></a>3、RecursiveTask</h5><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/1614161734753-741e762e-7430-4910-a3c0-5e40803f7850.png" alt="image"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归任务：继承后可以实现递归(自己调自己)调用的任务</span></span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Fibonacci</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Integer&gt; &#123;</span><br><span class="line">   <span class="keyword">final</span> <span class="type">int</span> n;</span><br><span class="line">   Fibonacci(<span class="type">int</span> n) &#123; <span class="built_in">this</span>.n = n; &#125;</span><br><span class="line">   Integer <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">       <span class="keyword">return</span> n;</span><br><span class="line">     <span class="type">Fibonacci</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Fibonacci</span>(n - <span class="number">1</span>);</span><br><span class="line">     f1.fork();</span><br><span class="line">     <span class="type">Fibonacci</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Fibonacci</span>(n - <span class="number">2</span>);</span><br><span class="line">     <span class="keyword">return</span> f2.compute() + f1.join();</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="2、示例"><a href="#2、示例" class="headerlink" title="2、示例"></a>2、示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinPool;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinTask;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.RecursiveTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyTask</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Integer&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">ADJUST_VALUE</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> begin;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> end;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyTask</span><span class="params">(<span class="type">int</span> begin, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.begin = begin;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Integer <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>((end - begin)&lt;=ADJUST_VALUE)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span>begin;i &lt;= end;i++)&#123;</span><br><span class="line">                result = result + i;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> (begin + end)/<span class="number">2</span>;</span><br><span class="line">            <span class="type">MyTask</span> <span class="variable">task01</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTask</span>(begin,middle);</span><br><span class="line">            <span class="type">MyTask</span> <span class="variable">task02</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTask</span>(middle+<span class="number">1</span>,end);</span><br><span class="line">            task01.fork();</span><br><span class="line">            task02.fork();</span><br><span class="line">            result =  task01.join() + task02.join();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分支合并例子</span></span><br><span class="line"><span class="comment"> * ForkJoinPool</span></span><br><span class="line"><span class="comment"> * ForkJoinTask</span></span><br><span class="line"><span class="comment"> * RecursiveTask</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForkJoinDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">MyTask</span> <span class="variable">myTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTask</span>(<span class="number">0</span>,<span class="number">100</span>);</span><br><span class="line">        <span class="type">ForkJoinPool</span> <span class="variable">forkJoinPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>();</span><br><span class="line">        ForkJoinTask&lt;Integer&gt; forkJoinTask = forkJoinPool.submit(myTask);</span><br><span class="line"></span><br><span class="line">        System.out.println(forkJoinTask.get());</span><br><span class="line"></span><br><span class="line">        forkJoinPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、Java“锁”事"><a href="#四、Java“锁”事" class="headerlink" title="四、Java“锁”事"></a>四、Java“锁”事</h2><h3 id="1、Lock"><a href="#1、Lock" class="headerlink" title="1、Lock"></a>1、Lock</h3><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/1614161410285-50f57395-d195-4f93-bed4-7b7dffaf078b.png" alt="image"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Lock implementations provide more extensive locking operations than can be obtained using synchronized methods and statements. They allow more flexible structuring, may have quite different properties, and may support multiple associated Condition objects.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 锁实现提供了比使用同步方法和语句可以获得的更广泛的锁操作。它们允许更灵活的结构，可能具有非常不同的属性，并且可能支持多个关联的条件对象</span></span><br></pre></td></tr></table></figure><h3 id="2、synchronized与Lock的区别"><a href="#2、synchronized与Lock的区别" class="headerlink" title="2、synchronized与Lock的区别"></a>2、synchronized与Lock的区别</h3><ol><li>首先synchronized是java内置关键字，在jvm层面，Lock是个java类；</li><li>synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁；</li><li>synchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁；</li><li>用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了；</li><li>synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可）</li><li>Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。</li></ol><h3 id="3、synchronized"><a href="#3、synchronized" class="headerlink" title="3、synchronized"></a>3、synchronized</h3><ol><li>修饰实例方法，作用于当前实例，进入同步代码前需要先获取实例的锁</li><li>修饰静态方法，作用于类的Class对象，进入修饰的静态方法前需要先获取类的Class对象的锁</li><li>修饰代码块，需要指定加锁对象(记做lockobj)，在进入同步代码块前需要先获取lockobj的锁</li></ol><h4 id="1、synchronized作用于实例对象"><a href="#1、synchronized作用于实例对象" class="headerlink" title="1、synchronized作用于实例对象"></a>1、synchronized作用于实例对象</h4><p>所谓实例对象锁就是用synchronized修饰实例对象的实例方法，注意是<strong>实例方法</strong>，不是<strong>静态方法</strong>，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo2</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">T</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> Demo2 demo2;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">T</span><span class="params">(Demo2 demo2)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.demo2 = demo2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">                <span class="built_in">this</span>.demo2.add();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Demo2</span> <span class="variable">demo2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo2</span>();</span><br><span class="line">        <span class="type">T</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>(demo2);</span><br><span class="line">        <span class="type">T</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>(demo2);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(demo2.num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main()方法中创建了一个对象demo2和2个线程t1、t2，t1、t2中调用demo2的add()方法10000次，add()方法中执行了num++，num++实际上是分3步，获取num，然后将num+1，然后将结果赋值给num，如果t2在t1读取num和num+1之间获取了num的值，那么t1和t2会读取到同样的值，然后执行num++，两次操作之后num是相同的值，最终和期望的结果不一致，造成了线程安全失败，因此我们对add方法加了synchronized来保证线程安全。</p><p>注意：m1()方法是实例方法，两个线程操作m1()时，需要先获取demo2的锁，没有获取到锁的，将等待，直到其他线程释放锁为止。</p><p>synchronize作用于实例方法需要注意：</p><ol><li>实例方法上加synchronized，线程安全的前提是，多个线程操作的是<strong>同一个实例</strong>，如果多个线程作用于不同的实例，那么线程安全是无法保证的</li><li>同一个实例的多个实例方法上有synchronized，这些方法都是互斥的，同一时间只允许一个线程操作<strong>同一个实例的其中的一个synchronized方法</strong></li></ol><h4 id="2、synchronized作用于静态方法"><a href="#2、synchronized作用于静态方法" class="headerlink" title="2、synchronized作用于静态方法"></a>2、synchronized作用于静态方法</h4><p>当synchronized作用于静态方法时，锁的对象就是当前类的Class对象。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo3</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">T1</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            Demo3.m1();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">T1</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T1</span>();</span><br><span class="line">        <span class="type">T1</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T1</span>();</span><br><span class="line">        <span class="type">T1</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T1</span>();</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">        <span class="comment">//等待3个线程结束打印num</span></span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        t3.join();</span><br><span class="line">        System.out.println(Demo3.num);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 打印结果：</span></span><br><span class="line"><span class="comment">         * 30000</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码打印30000，和期望结果一致。m1()方法是静态方法，有synchronized修饰，锁用于与Demo3.class对象，和下面的写法类似：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (Demo4.class) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、synchronized同步代码块"><a href="#3、synchronized同步代码块" class="headerlink" title="3、synchronized同步代码块"></a>3、synchronized同步代码块</h4><p>除了使用关键字修饰实例方法和静态方法外，还可以使用同步代码块，在某些情况下，我们编写的方法体可能比较大，同时存在一些比较耗时的操作，而需要同步的代码又只有一小部分，如果直接对整个方法进行同步操作，可能会得不偿失，此时我们可以使用同步代码块的方式对需要同步的代码进行包裹，这样就无需对整个方法进行同步操作了，同步代码块的使用示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo5</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Demo5</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo5</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//省略其他耗时操作....</span></span><br><span class="line">        <span class="comment">//使用同步代码块对变量i进行同步操作,锁对象为instance</span></span><br><span class="line">        <span class="keyword">synchronized</span> (instance) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(instance);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(instance);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码看出，将synchronized作用于一个给定的实例对象instance，即当前实例对象就是锁对象，每次当线程进入synchronized包裹的代码块时就会要求当前线程持有instance实例对象锁，如果当前有其他线程正持有该对象锁，那么新到的线程就必须等待，这样也就保证了每次只有一个线程执行i++;操作。当然除了instance作为对象外，我们还可以使用this对象(代表当前实例)或者当前类的class对象作为锁，如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//this,当前实例对象锁</span></span><br><span class="line"><span class="keyword">synchronized</span>(<span class="built_in">this</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000000</span>;j++)&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//class对象锁</span></span><br><span class="line"><span class="keyword">synchronized</span>(Demo5.class)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000000</span>;j++)&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析代码是否互斥的方法，先找出synchronized作用的对象是谁，如果多个线程操作的方法中synchronized作用的锁对象一样，那么这些线程同时异步执行这些方法就是互斥的。如下代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo6</span> &#123;</span><br><span class="line">    <span class="comment">//作用于当前类的实例对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//作用于当前类的实例对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//作用于当前类的实例对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//作用于当前类Class对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">m4</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//作用于当前类Class对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m5</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Demo6.class) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">T</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">        Demo6 demo6;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">T</span><span class="params">(Demo6 demo6)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.demo6 = demo6;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Demo6</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo6</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            d1.m1();</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            d1.m2();</span><br><span class="line">        &#125;);</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            d1.m2();</span><br><span class="line">        &#125;);</span><br><span class="line">        t3.start();</span><br><span class="line">        <span class="type">Demo6</span> <span class="variable">d2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo6</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            d2.m2();</span><br><span class="line">        &#125;);</span><br><span class="line">        t4.start();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            Demo6.m4();</span><br><span class="line">        &#125;);</span><br><span class="line">        t5.start();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            Demo6.m5();</span><br><span class="line">        &#125;);</span><br><span class="line">        t6.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析上面代码：</p><ol><li>线程t1、t2、t3中调用的方法都需要获取d1的锁，所以他们是互斥的</li><li>t1&#x2F;t2&#x2F;t3这3个线程和t4不互斥，他们可以同时运行，因为前面三个线程依赖于d1的锁，t4依赖于d2的锁</li><li>t5、t6都作用于当前类的Class对象锁，所以这两个线程是互斥的，和其他几个线程不互斥</li></ol><h3 id="4、ReentrantLock"><a href="#4、ReentrantLock" class="headerlink" title="4、ReentrantLock"></a>4、ReentrantLock</h3><p>ReentrantLock是Lock的默认实现，在聊ReentranLock之前，我们需要先弄清楚一些概念：</p><ol><li>可重入锁：可重入锁是指同一个线程可以多次获得同一把锁；ReentrantLock和关键字Synchronized都是可重入锁</li><li>可中断锁：可中断锁时子线程在获取锁的过程中，是否可以相应线程中断操作。synchronized是不可中断的，ReentrantLock是可中断的</li><li>公平锁和非公平锁：公平锁是指多个线程尝试获取同一把锁的时候，获取锁的顺序按照线程到达的先后顺序获取，而不是随机插队的方式获取。synchronized是非公平锁，而ReentrantLock是两种都可以实现，不过默认是非公平锁</li></ol><h4 id="1、synchronized的局限性"><a href="#1、synchronized的局限性" class="headerlink" title="1、synchronized的局限性"></a>1、synchronized的局限性</h4><p>synchronized是java内置的关键字，它提供了一种独占的加锁方式。synchronized的获取和释放锁由jvm实现，用户不需要显示的释放锁，非常方便，然而synchronized也有一定的局限性，例如：</p><ol><li>当线程尝试获取锁的时候，如果获取不到锁会一直阻塞，这个阻塞的过程，用户无法控制</li><li>如果获取锁的线程进入休眠或者阻塞，除非当前线程异常，否则其他线程尝试获取锁必须一直等待</li></ol><p>JDK1.5之后发布，加入了Doug Lea实现的java.util.concurrent包。包内提供了Lock类，用来提供更多扩展的加锁功能。Lock弥补了synchronized的局限，提供了更加细粒度的加锁功能。</p><h4 id="2、ReentrantLock基本使用"><a href="#2、ReentrantLock基本使用" class="headerlink" title="2、ReentrantLock基本使用"></a>2、ReentrantLock基本使用</h4><p>我们使用3个线程来对一个共享变量++操作，先使用<strong>synchronized</strong>实现，然后使用<strong>ReentrantLock</strong>实现。</p><p><strong>synchronized方式</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo2</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">T</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">                Demo2.add();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>();</span><br><span class="line">        <span class="type">T</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>();</span><br><span class="line">        <span class="type">T</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>();</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        t3.join();</span><br><span class="line">        System.out.println(Demo2.num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ReentrantLock方式</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo3</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            num++;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">T</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">                Demo3.add();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>();</span><br><span class="line">        <span class="type">T</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>();</span><br><span class="line">        <span class="type">T</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>();</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        t3.join();</span><br><span class="line">        System.out.println(Demo3.num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ReentrantLock的使用过程：</strong></p><ol><li><strong>创建锁：ReentrantLock lock &#x3D; new ReentrantLock();</strong></li><li><strong>获取锁：lock.lock()</strong></li><li><strong>释放锁：lock.unlock();</strong></li></ol><p>对比上面的代码，与关键字synchronized相比，ReentrantLock锁有明显的操作过程，开发人员必须手动的指定何时加锁，何时释放锁，正是因为这样手动控制，ReentrantLock对逻辑控制的灵活度要远远胜于关键字synchronized，上面代码需要注意**lock.unlock()**一定要放在finally中，否则，若程序出现了异常，锁没有释放，那么其他线程就再也没有机会获取这个锁了。</p><h4 id="3、ReentrantLock获取锁的过程是可中断的"><a href="#3、ReentrantLock获取锁的过程是可中断的" class="headerlink" title="3、ReentrantLock获取锁的过程是可中断的"></a>3、ReentrantLock获取锁的过程是可中断的</h4><p>对于synchronized关键字，如果一个线程在等待获取锁，最终只有2种结果：</p><ol><li>要么获取到锁然后继续后面的操作</li><li>要么一直等待，直到其他线程释放锁为止</li></ol><p>而ReentrantLock提供了另外一种可能，就是在等待获取锁的过程中（<strong>发起获取锁请求到还未获取到锁这段时间内</strong>）是可以被中断的，也就是说在等待锁的过程中，程序可以根据需要取消获取锁的请求。有些使用这个操作是非常有必要的。比如：你和好朋友越好一起去打球，如果你等了半小时朋友还没到，突然你接到一个电话，朋友由于突发状况，不能来了，那么你一定达到回府。中断操作正是提供了一套类似的机制，如果一个线程正在等待获取锁，那么它依然可以收到一个通知，被告知无需等待，可以停止工作了。</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo6</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">lock1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">lock2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">T</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="type">int</span> lock;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">T</span><span class="params">(String name, <span class="type">int</span> lock)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(name);</span><br><span class="line">            <span class="built_in">this</span>.lock = lock;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>.lock == <span class="number">1</span>) &#123;</span><br><span class="line">                    lock1.lockInterruptibly();</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                    lock2.lockInterruptibly();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    lock2.lockInterruptibly();</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                    lock1.lockInterruptibly();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;中断标志:&quot;</span> + <span class="built_in">this</span>.isInterrupted());</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (lock1.isHeldByCurrentThread()) &#123;</span><br><span class="line">                    lock1.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (lock2.isHeldByCurrentThread()) &#123;</span><br><span class="line">                    lock2.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>(<span class="string">&quot;t1&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="type">T</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>(<span class="string">&quot;t2&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先运行一下上面代码，发现程序无法结束，使用jstack查看线程堆栈信息，发现2个线程死锁了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Found one Java-level deadlock:</span><br><span class="line">=============================</span><br><span class="line"><span class="string">&quot;t2&quot;</span>:</span><br><span class="line">  waiting <span class="keyword">for</span> ownable synchronizer <span class="number">0x0000000717380c20</span>, (a java.util.concurrent.locks.ReentrantLock$NonfairSync),</span><br><span class="line">  which is held by <span class="string">&quot;t1&quot;</span></span><br><span class="line"><span class="string">&quot;t1&quot;</span>:</span><br><span class="line">  waiting <span class="keyword">for</span> ownable synchronizer <span class="number">0x0000000717380c50</span>, (a java.util.concurrent.locks.ReentrantLock$NonfairSync),</span><br><span class="line">  which is held by <span class="string">&quot;t2</span></span><br></pre></td></tr></table></figure><p>lock1被线程t1占用，lock2被线程t2占用，线程t1在等待获取lock2，线程t2在等待获取lock1，都在相互等待获取对方持有的锁，最终产生了死锁，如果是在synchronized关键字情况下发生了死锁现象，程序是无法结束的。</p><p>我们对上面代码改造一下，线程t2一直无法获取到lock1，那么等待5秒之后，我们中断获取锁的操作。主要修改一下main方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">T</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>(<span class="string">&quot;t1&quot;</span>, <span class="number">1</span>);</span><br><span class="line"><span class="type">T</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>(<span class="string">&quot;t2&quot;</span>, <span class="number">2</span>);</span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">t2.interrupt();</span><br></pre></td></tr></table></figure><p>新增了2行代码<code>TimeUnit.SECONDS.sleep(5);t2.interrupt();</code>，程序可以结束了，运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">java.lang.InterruptedException</span><br><span class="line">    at java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireInterruptibly(AbstractQueuedSynchronizer.java:<span class="number">898</span>)</span><br><span class="line">    at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireInterruptibly(AbstractQueuedSynchronizer.java:<span class="number">1222</span>)</span><br><span class="line">    at java.util.concurrent.locks.ReentrantLock.lockInterruptibly(ReentrantLock.java:<span class="number">335</span>)</span><br><span class="line">    at com.itsoku.chat06.Demo6$T.run(Demo6.java:<span class="number">31</span>)</span><br><span class="line">中断标志:<span class="literal">false</span></span><br></pre></td></tr></table></figure><p>从上面信息中可以看出，代码的31行触发了异常，<strong>中断标志输出：false</strong></p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/ec24264d-651f-4eb6-aa60-bb98a3098f78.png" alt="ec24264d-651f-4eb6-aa60-bb98a3098f78"></p><p>t2在31行一直获取不到lock1的锁，主线程中等待了5秒之后，t2线程调用了<code>interrupt()</code>方法，将线程的中断标志置为true，此时31行会触发<code>InterruptedException</code>异常，然后线程t2可以继续向下执行，释放了lock2的锁，然后线程t1可以正常获取锁，程序得以继续进行。线程发送中断信号触发InterruptedException异常之后，中断标志将被清空。</p><p>关于获取锁的过程中被中断，注意几点:</p><ol><li><strong>ReentrankLock中必须使用实例方法<code>lockInterruptibly()</code>获取锁时，在线程调用interrupt()方法之后，才会引发<code>InterruptedException</code>异常</strong></li><li><strong>线程调用interrupt()之后，线程的中断标志会被置为true</strong></li><li><strong>触发InterruptedException异常之后，线程的中断标志会被清空，即置为false</strong></li><li><strong>所以当线程调用interrupt()引发InterruptedException异常，中断标志的变化是:false-&gt;true-&gt;false</strong></li></ol><h4 id="4、ReentrantLock锁申请等待限时"><a href="#4、ReentrantLock锁申请等待限时" class="headerlink" title="4、ReentrantLock锁申请等待限时"></a>4、ReentrantLock锁申请等待限时</h4><p>申请锁等待限时是什么意思？一般情况下，获取锁的时间我们是不知道的，synchronized关键字获取锁的过程中，只能等待其他线程把锁释放之后才能够有机会获取到锁。所以获取锁的时间有长有短。如果获取锁的时间能够设置超时时间，那就非常好了。</p><p>ReentrantLock刚好提供了这样功能，给我们提供了获取锁限时等待的方法<code>tryLock()</code>，可以选择传入时间参数，表示等待指定的时间，无参则表示立即返回锁申请的结果：true表示获取锁成功，false表示获取锁失败。</p><p><strong>tryLock无参方法</strong></p><p>看一下源码中tryLock方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span></span><br></pre></td></tr></table></figure><p>返回boolean类型的值，此方法会立即返回，结果表示获取锁是否成功，示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo8</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">lock1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">T</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">T</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(System.currentTimeMillis() + <span class="string">&quot;:&quot;</span> + <span class="built_in">this</span>.getName() + <span class="string">&quot;开始获取锁!&quot;</span>);</span><br><span class="line">                <span class="comment">//获取锁超时时间设置为3秒，3秒内是否能否获取锁都会返回</span></span><br><span class="line">                <span class="keyword">if</span> (lock1.tryLock()) &#123;</span><br><span class="line">                    System.out.println(System.currentTimeMillis() + <span class="string">&quot;:&quot;</span> + <span class="built_in">this</span>.getName() + <span class="string">&quot;获取到了锁!&quot;</span>);</span><br><span class="line">                    <span class="comment">//获取到锁之后，休眠5秒</span></span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(System.currentTimeMillis() + <span class="string">&quot;:&quot;</span> + <span class="built_in">this</span>.getName() + <span class="string">&quot;未能获取到锁!&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (lock1.isHeldByCurrentThread()) &#123;</span><br><span class="line">                    lock1.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>(<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        <span class="type">T</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>(<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中获取锁成功之后，休眠5秒，会导致另外一个线程获取锁失败，运行代码，输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1563356291081</span>:t2开始获取锁!</span><br><span class="line"><span class="number">1563356291081</span>:t2获取到了锁!</span><br><span class="line"><span class="number">1563356291081</span>:t1开始获取锁!</span><br><span class="line"><span class="number">1563356291081</span>:t1未能获取到锁!</span><br></pre></td></tr></table></figure><p><strong>tryLock有参方法</strong></p><p>可以明确设置获取锁的超时时间，该方法签名：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span><br></pre></td></tr></table></figure><p>该方法在指定的时间内不管是否可以获取锁，都会返回结果，返回true，表示获取锁成功，返回false表示获取失败。此方法有2个参数，第一个参数是时间类型，是一个枚举，可以表示时、分、秒、毫秒等待，使用比较方便，第1个参数表示在时间类型上的时间长短。此方法在执行的过程中，如果调用了线程的中断interrupt()方法，会触发InterruptedException异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo7</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">lock1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">T</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">T</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(System.currentTimeMillis() + <span class="string">&quot;:&quot;</span> + <span class="built_in">this</span>.getName() + <span class="string">&quot;开始获取锁!&quot;</span>);</span><br><span class="line">                <span class="comment">//获取锁超时时间设置为3秒，3秒内是否能否获取锁都会返回</span></span><br><span class="line">                <span class="keyword">if</span> (lock1.tryLock(<span class="number">3</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">                    System.out.println(System.currentTimeMillis() + <span class="string">&quot;:&quot;</span> + <span class="built_in">this</span>.getName() + <span class="string">&quot;获取到了锁!&quot;</span>);</span><br><span class="line">                    <span class="comment">//获取到锁之后，休眠5秒</span></span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(System.currentTimeMillis() + <span class="string">&quot;:&quot;</span> + <span class="built_in">this</span>.getName() + <span class="string">&quot;未能获取到锁!&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (lock1.isHeldByCurrentThread()) &#123;</span><br><span class="line">                    lock1.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>(<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        <span class="type">T</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>(<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序中调用了ReentrantLock的实例方法<code>tryLock(3, TimeUnit.SECONDS)</code>，表示获取锁的超时时间是3秒，3秒后不管是否能否获取锁，该方法都会有返回值，获取到锁之后，内部休眠了5秒，会导致另外一个线程获取锁失败。</p><p>运行程序，输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1563355512901</span>:t2开始获取锁!</span><br><span class="line"><span class="number">1563355512901</span>:t1开始获取锁!</span><br><span class="line"><span class="number">1563355512902</span>:t2获取到了锁!</span><br><span class="line"><span class="number">1563355515904</span>:t1未能获取到锁!</span><br></pre></td></tr></table></figure><p>输出结果中分析，t2获取到锁了，然后休眠了5秒，t1获取锁失败，t1打印了2条信息，时间相差3秒左右。</p><p><strong>关于tryLock()方法和tryLock(long timeout, TimeUnit unit)方法，说明一下：</strong></p><ol><li>都会返回boolean值，结果表示获取锁是否成功</li><li>tryLock()方法，不管是否获取成功，都会立即返回；而有参的tryLock方法会尝试在指定的时间内去获取锁，中间会阻塞的现象，在指定的时间之后会不管是否能够获取锁都会返回结果</li><li>tryLock()方法不会响应线程的中断方法；而有参的tryLock方法会响应线程的中断方法，而触发<code>InterruptedException</code>异常，这个从2个方法的声明上可以可以看出来</li></ol><h4 id="5、ReentrantLock其他常用的方法"><a href="#5、ReentrantLock其他常用的方法" class="headerlink" title="5、ReentrantLock其他常用的方法"></a>5、ReentrantLock其他常用的方法</h4><ol><li>isHeldByCurrentThread：实例方法，判断当前线程是否持有ReentrantLock的锁，上面代码中有使用过。</li></ol><p><strong>获取锁的4种方法对比</strong></p><table><thead><tr><th>获取锁的方法</th><th>是否立即响应(不会阻塞)</th><th>是否响应中断</th></tr></thead><tbody><tr><td>lock()</td><td>×</td><td>×</td></tr><tr><td>lockInterruptibly()</td><td>×</td><td>√</td></tr><tr><td>tryLock()</td><td>√</td><td>×</td></tr><tr><td>tryLock(long timeout, TimeUnit unit)</td><td>×</td><td>√</td></tr></tbody></table><h4 id="6、总结"><a href="#6、总结" class="headerlink" title="6、总结"></a>6、总结</h4><ol><li>ReentrantLock可以实现公平锁和非公平锁</li><li>ReentrantLock默认实现的是非公平锁</li><li>ReentrantLock的获取锁和释放锁必须成对出现，锁了几次，也要释放几次</li><li>释放锁的操作必须放在finally中执行</li><li>lockInterruptibly()实例方法可以相应线程的中断方法，调用线程的interrupt()方法时，lockInterruptibly()方法会触发<code>InterruptedException</code>异常</li><li>关于<code>InterruptedException</code>异常说一下，看到方法声明上带有 <code>throws InterruptedException</code>，表示该方法可以相应线程中断，调用线程的interrupt()方法时，这些方法会触发<code>InterruptedException</code>异常，触发InterruptedException时，线程的中断中断状态会被清除。所以如果程序由于调用<code>interrupt()</code>方法而触发<code>InterruptedException</code>异常，线程的标志由默认的false变为ture，然后又变为false</li><li>实例方法tryLock()会尝试获取锁，会立即返回，返回值表示是否获取成功</li><li>实例方法tryLock(long timeout, TimeUnit unit)会在指定的时间内尝试获取锁，指定的时间内是否能够获取锁，都会返回，返回值表示是否获取锁成功，该方法会响应线程的中断</li></ol><h3 id="5、悲观锁"><a href="#5、悲观锁" class="headerlink" title="5、悲观锁"></a>5、悲观锁</h3><p>认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。</p><p>synchronized关键字和Lock的实现类都是悲观锁</p><p>适合写操作多的场景，先加锁可以保证写操作时数据正确。</p><p>显式的锁定之后再操作同步资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//=============悲观锁的调用方式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//加锁后的业务逻辑......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保证多个线程使用的是同一个lock对象的前提下</span></span><br><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 操作同步资源</span></span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6、乐观锁"><a href="#6、乐观锁" class="headerlink" title="6、乐观锁"></a>6、乐观锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//=============乐观锁的调用方式</span></span><br><span class="line"><span class="comment">// 保证多个线程使用的是同一个AtomicInteger</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">atomicInteger.incrementAndGet();</span><br></pre></td></tr></table></figure><p>​乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。</p><p>如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作</p><p>乐观锁在Java中是通过使用无锁编程来实现，最常采用的是CAS算法，Java原子类中的递增操作就通过CAS自旋实现的。</p><p>适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升。</p><p>乐观锁则直接去操作同步资源，是一种无锁算法，得之我幸不得我命，再抢</p><p>乐观锁一般有两种实现方式：</p><ol><li>采用版本号机制</li><li>CAS（Compare-and-Swap，即比较并替换）算法实现</li></ol><h3 id="7、八锁案例"><a href="#7、八锁案例" class="headerlink" title="7、八锁案例"></a>7、八锁案例</h3><h4 id="1、JDK源码-notify方法"><a href="#1、JDK源码-notify方法" class="headerlink" title="1、JDK源码(notify方法)"></a>1、JDK源码(notify方法)</h4><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210907200227293-16310161483121.png" alt="image-20210907200227293"></p><h4 id="2、8种锁的案例实际体现在3个地方"><a href="#2、8种锁的案例实际体现在3个地方" class="headerlink" title="2、8种锁的案例实际体现在3个地方"></a>2、8种锁的案例实际体现在3个地方</h4><ol><li>作用于实例方法，当前实例加锁，进入同步代码前要获得当前实例的锁；</li><li>作用于代码块，对括号里配置的对象加锁。</li><li>作用于静态方法，当前类加锁，进去同步代码前要获得当前类对象的锁；</li></ol><h5 id="1、标准访问有ab两个线程，请问先打印邮件还是短信"><a href="#1、标准访问有ab两个线程，请问先打印邮件还是短信" class="headerlink" title="1、标准访问有ab两个线程，请问先打印邮件还是短信"></a>1、标准访问有ab两个线程，请问先打印邮件还是短信</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span> <span class="comment">//资源类</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-------sendEmail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendSMS</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-------sendSMS&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lock8Demo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span><span class="comment">//一切程序的入口，主线程</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();<span class="comment">//资源类1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            phone.sendEmail();</span><br><span class="line">        &#125;,<span class="string">&quot;a&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//暂停毫秒</span></span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            phone.sendSMS();</span><br><span class="line">        &#125;,<span class="string">&quot;b&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-------sendEmail</span><br><span class="line">-------sendSMS</span><br></pre></td></tr></table></figure><h5 id="2、sendEmail方法暂停3秒钟，请问先打印邮件还是短信"><a href="#2、sendEmail方法暂停3秒钟，请问先打印邮件还是短信" class="headerlink" title="2、sendEmail方法暂停3秒钟，请问先打印邮件还是短信"></a>2、sendEmail方法暂停3秒钟，请问先打印邮件还是短信</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span> <span class="comment">//资源类</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//暂停几秒钟线程</span></span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">3</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;-------sendEmail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendSMS</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-------sendSMS&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lock8Demo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span><span class="comment">//一切程序的入口，主线程</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();<span class="comment">//资源类1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            phone.sendEmail();</span><br><span class="line">        &#125;,<span class="string">&quot;a&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//暂停毫秒</span></span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            phone.sendSMS();</span><br><span class="line">        &#125;,<span class="string">&quot;b&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-------sendEmail</span><br><span class="line">-------sendSMS</span><br></pre></td></tr></table></figure><h5 id="1-2结论"><a href="#1-2结论" class="headerlink" title="1-2结论"></a>1-2结论</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">一个对象里面如果有多个synchronized方法，某一个时刻内，只要一个线程去调用其中的一个synchronized方法了，</span><br><span class="line">其它的线程都只能等待，换句话说，某一个时刻内，只能有唯一的一个线程去访问这些synchronized方法</span><br><span class="line">锁的是当前对象this，被锁定后，其它的线程都不能进入到当前对象的其它的synchronized方法</span><br></pre></td></tr></table></figure><h5 id="3、新增一个普通的hello方法，请问先打印邮件还是hello"><a href="#3、新增一个普通的hello方法，请问先打印邮件还是hello" class="headerlink" title="3、新增一个普通的hello方法，请问先打印邮件还是hello"></a>3、新增一个普通的hello方法，请问先打印邮件还是hello</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span> <span class="comment">//资源类</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//暂停几秒钟线程</span></span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">3</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;-------sendEmail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendSMS</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-------sendSMS&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-------hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lock8Demo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span><span class="comment">//一切程序的入口，主线程</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();<span class="comment">//资源类1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            phone.sendEmail();</span><br><span class="line">        &#125;,<span class="string">&quot;a&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//暂停毫秒</span></span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            phone.hello();</span><br><span class="line">        &#125;,<span class="string">&quot;b&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-------hello</span><br><span class="line">-------sendEmail</span><br></pre></td></tr></table></figure><h5 id="4、有两部手机，请问先打印邮件还是短信"><a href="#4、有两部手机，请问先打印邮件还是短信" class="headerlink" title="4、有两部手机，请问先打印邮件还是短信"></a>4、有两部手机，请问先打印邮件还是短信</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span> <span class="comment">//资源类</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//暂停几秒钟线程</span></span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">3</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;-------sendEmail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendSMS</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-------sendSMS&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-------hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lock8Demo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span><span class="comment">//一切程序的入口，主线程</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();<span class="comment">//资源类1</span></span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();<span class="comment">//资源类2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            phone.sendEmail();</span><br><span class="line">        &#125;,<span class="string">&quot;a&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//暂停毫秒</span></span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            phone2.sendSMS();</span><br><span class="line">        &#125;,<span class="string">&quot;b&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-------sendSMS</span><br><span class="line">-------sendEmail</span><br></pre></td></tr></table></figure><h5 id="3-4结论"><a href="#3-4结论" class="headerlink" title="3-4结论"></a>3-4结论</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">加个普通方法后发现和同步锁无关,hello</span><br><span class="line">换成两个对象后，不是同一把锁了，情况立刻变化。</span><br></pre></td></tr></table></figure><h5 id="5、两个静态同步方法，同1部手机，请问先打印邮件还是短信"><a href="#5、两个静态同步方法，同1部手机，请问先打印邮件还是短信" class="headerlink" title="5、两个静态同步方法，同1部手机，请问先打印邮件还是短信"></a>5、两个静态同步方法，同1部手机，请问先打印邮件还是短信</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span> <span class="comment">//资源类</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//暂停几秒钟线程</span></span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">3</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;-------sendEmail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendSMS</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-------sendSMS&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-------hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lock8Demo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span><span class="comment">//一切程序的入口，主线程</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();<span class="comment">//资源类1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            phone.sendEmail();</span><br><span class="line">        &#125;,<span class="string">&quot;a&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//暂停毫秒</span></span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            phone.sendSMS();</span><br><span class="line">        &#125;,<span class="string">&quot;b&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-------sendEmail</span><br><span class="line">-------sendSMS</span><br></pre></td></tr></table></figure><h5 id="6、两个静态同步方法，-2部手机，请问先打印邮件还是短信"><a href="#6、两个静态同步方法，-2部手机，请问先打印邮件还是短信" class="headerlink" title="6、两个静态同步方法， 2部手机，请问先打印邮件还是短信"></a>6、两个静态同步方法， 2部手机，请问先打印邮件还是短信</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span> <span class="comment">//资源类</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//暂停几秒钟线程</span></span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">3</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;-------sendEmail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendSMS</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-------sendSMS&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-------hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lock8Demo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span><span class="comment">//一切程序的入口，主线程</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();<span class="comment">//资源类1</span></span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();<span class="comment">//资源类2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            phone.sendEmail();</span><br><span class="line">        &#125;,<span class="string">&quot;a&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//暂停毫秒</span></span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            phone2.sendSMS();</span><br><span class="line">        &#125;,<span class="string">&quot;b&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-------sendEmail</span><br><span class="line">-------sendSMS</span><br></pre></td></tr></table></figure><h5 id="5-6结论"><a href="#5-6结论" class="headerlink" title="5-6结论"></a>5-6结论</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">都换成静态同步方法后，情况又变化</span><br><span class="line">三种 synchronized 锁的内容有一些差别:</span><br><span class="line">对于普通同步方法，锁的是当前实例对象，通常指this,具体的一部部手机,所有的普通同步方法用的都是同一把锁——实例对象本身，</span><br><span class="line">对于静态同步方法，锁的是当前类的Class对象，如Phone.class唯一的一个模板</span><br><span class="line">对于同步方法块，锁的是 synchronized 括号内的对象</span><br></pre></td></tr></table></figure><h5 id="7、1个静态同步方法，1个普通同步方法-同1部手机，请问先打印邮件还是短信"><a href="#7、1个静态同步方法，1个普通同步方法-同1部手机，请问先打印邮件还是短信" class="headerlink" title="7、1个静态同步方法，1个普通同步方法,同1部手机，请问先打印邮件还是短信"></a>7、1个静态同步方法，1个普通同步方法,同1部手机，请问先打印邮件还是短信</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span> <span class="comment">//资源类</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//暂停几秒钟线程</span></span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">3</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;-------sendEmail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendSMS</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-------sendSMS&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-------hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lock8Demo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span><span class="comment">//一切程序的入口，主线程</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();<span class="comment">//资源类1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            phone.sendEmail();</span><br><span class="line">        &#125;,<span class="string">&quot;a&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//暂停毫秒</span></span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            phone.sendSMS();</span><br><span class="line">        &#125;,<span class="string">&quot;b&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-------sendSMS</span><br><span class="line">-------sendEmail</span><br></pre></td></tr></table></figure><h5 id="8、1个静态同步方法，1个普通同步方法-2部手机，请问先打印邮件还是短信"><a href="#8、1个静态同步方法，1个普通同步方法-2部手机，请问先打印邮件还是短信" class="headerlink" title="8、1个静态同步方法，1个普通同步方法,2部手机，请问先打印邮件还是短信"></a>8、1个静态同步方法，1个普通同步方法,2部手机，请问先打印邮件还是短信</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span> <span class="comment">//资源类</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//暂停几秒钟线程</span></span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">3</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;-------sendEmail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendSMS</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-------sendSMS&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-------hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lock8Demo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span><span class="comment">//一切程序的入口，主线程</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();<span class="comment">//资源类1</span></span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();<span class="comment">//资源类2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            phone.sendEmail();</span><br><span class="line">        &#125;,<span class="string">&quot;a&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//暂停毫秒</span></span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            phone2.sendSMS();</span><br><span class="line">        &#125;,<span class="string">&quot;b&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-------sendSMS</span><br><span class="line">-------sendEmail</span><br></pre></td></tr></table></figure><h5 id="7-8结论"><a href="#7-8结论" class="headerlink" title="7-8结论"></a>7-8结论</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">当一个线程试图访问同步代码时它首先必须得到锁，退出或抛出异常时必须释放锁。</span><br><span class="line"></span><br><span class="line">所有的普通同步方法用的都是同一把锁——实例对象本身，就是new出来的具体实例对象本身,本类this</span><br><span class="line">也就是说如果一个实例对象的普通同步方法获取锁后，该实例对象的其他普通同步方法必须等待获取锁的方法释放锁后才能获取锁。</span><br><span class="line"></span><br><span class="line">所有的静态同步方法用的也是同一把锁——类对象本身，就是我们说过的唯一模板Class</span><br><span class="line">具体实例对象this和唯一模板Class，这两把锁是两个不同的对象，所以静态同步方法与普通同步方法之间是不会有竞态条件的</span><br><span class="line">但是一旦一个静态同步方法获取锁后，其他的静态同步方法都必须等待该方法释放锁后才能获取锁。</span><br></pre></td></tr></table></figure><h3 id="8、公平锁和非公平锁"><a href="#8、公平锁和非公平锁" class="headerlink" title="8、公平锁和非公平锁"></a>8、公平锁和非公平锁</h3><p>在大多数情况下，锁的申请都是非公平的，也就是说，线程1首先请求锁A，接着线程2也请求了锁A。那么当锁A可用时，是线程1可获得锁还是线程2可获得锁呢？这是不一定的，系统只是会从这个锁的等待队列中随机挑选一个，因此不能保证其公平性。这就好比买票不排队，大家都围在售票窗口前，售票员忙的焦头烂额，也顾及不上谁先谁后，随便找个人出票就完事了，最终导致的结果是，有些人可能一直买不到票。而公平锁，则不是这样，它会按照到达的先后顺序获得资源。公平锁的一大特点是：它不会产生饥饿现象，只要你排队，最终还是可以等到资源的；synchronized关键字默认是有jvm内部实现控制的，是非公平锁。而ReentrantLock运行开发者自己设置锁的公平性。</p><p>看一下jdk中ReentrantLock的源码，2个构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认构造方法创建的是非公平锁。</p><p>第2个构造方法，有个fair参数，当fair为true的时候创建的是公平锁，公平锁看起来很不错，不过要实现公平锁，系统内部肯定需要维护一个有序队列，因此公平锁的实现成本比较高，性能相对于非公平锁来说相对低一些。因此，在默认情况下，锁是非公平的，如果没有特别要求，则不建议使用公平锁。</p><p>公平锁和非公平锁在程序调度上是很不一样，来一个公平锁示例看一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo5</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">fairLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">T</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">T</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                fairLock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="built_in">this</span>.getName() + <span class="string">&quot;获得锁!&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    fairLock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>(<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        <span class="type">T</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>(<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        <span class="type">T</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>(<span class="string">&quot;t3&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        t3.join();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下输出的结果，锁是按照先后顺序获得的。</p><p>修改一下上面代码，改为非公平锁试试，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">fairLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>从ReentrantLock卖票编码演示公平和非公平现象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ticket</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">    <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sale</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(number &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;卖出第：\t&quot;</span>+(number--)+<span class="string">&quot;\t 还剩下:&quot;</span>+number);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SaleTicketDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Ticket</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ticket</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123; <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;<span class="number">35</span>; i++)  ticket.sale(); &#125;,<span class="string">&quot;a&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123; <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;<span class="number">35</span>; i++)  ticket.sale(); &#125;,<span class="string">&quot;b&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123; <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;<span class="number">35</span>; i++)  ticket.sale(); &#125;,<span class="string">&quot;c&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生活中，排队讲求先来后到视为公平。程序中的公平性也是符合请求锁的绝对时间的，其实就是 FIFO，否则视为不公平</p><h4 id="1、源码解读"><a href="#1、源码解读" class="headerlink" title="1、源码解读"></a>1、源码解读</h4><p>​按序排队公平锁，就是判断同步队列是否还有先驱节点的存在(我前面还有人吗?)，如果没有先驱节点才能获取锁；先占先得非公平锁，是不管这个事的，只要能抢获到同步状态就可以</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210916224629198.png" alt="image-20210916224629198"></p><h4 id="2、为什么会有公平锁-x2F-非公平锁的设计为什么默认非公平？"><a href="#2、为什么会有公平锁-x2F-非公平锁的设计为什么默认非公平？" class="headerlink" title="2、为什么会有公平锁&#x2F;非公平锁的设计为什么默认非公平？"></a>2、为什么会有公平锁&#x2F;非公平锁的设计为什么默认非公平？</h4><ol><li>恢复挂起的线程到真正锁的获取还是有时间差的，从开发人员来看这个时间微乎其微，但是从CPU的角度来看，这个时间差存在的还是很明显的。所以非公平锁能更充分的利用CPU 的时间片，尽量减少 CPU 空闲状态时间。</li><li>使用多线程很重要的考量点是线程切换的开销，当采用非公平锁时，当1个线程请求锁获取同步状态，然后释放同步状态，因为不需要考虑是否还有前驱节点，所以刚释放锁的线程在此刻再次获取同步状态的概率就变得非常大，所以就减少了线程的开销。</li></ol><h4 id="3、使⽤公平锁会有什么问题"><a href="#3、使⽤公平锁会有什么问题" class="headerlink" title="3、使⽤公平锁会有什么问题"></a>3、使⽤公平锁会有什么问题</h4><p>公平锁保证了排队的公平性，非公平锁霸气的忽视这个规则，所以就有可能导致排队的长时间在排队，也没有机会获取到锁，这就是传说中的 “锁饥饿”</p><h4 id="4、什么时候用公平？什么时候用非公平？"><a href="#4、什么时候用公平？什么时候用非公平？" class="headerlink" title="4、什么时候用公平？什么时候用非公平？"></a>4、什么时候用公平？什么时候用非公平？</h4><p>如果为了更高的吞吐量，很显然非公平锁是比较合适的，因为节省很多线程切换时间，吞吐量自然就上去了；否则那就用公平锁，大家公平使用。</p><h3 id="9、可重入锁-又名递归锁"><a href="#9、可重入锁-又名递归锁" class="headerlink" title="9、可重入锁(又名递归锁)"></a>9、可重入锁(又名递归锁)</h3><p>是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁(前提，锁对象得是同一个对象)，不会因为之前已经获取过还没释放而阻塞。</p><p>如果是1个有 synchronized 修饰的递归调用方法，程序第2次进入被自己阻塞了岂不是天大的笑话，出现了作茧自缚。所以Java中ReentrantLock和synchronized都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。</p><h4 id="1、“可重入锁”这四个字分开来解释："><a href="#1、“可重入锁”这四个字分开来解释：" class="headerlink" title="1、“可重入锁”这四个字分开来解释："></a>1、“可重入锁”这四个字分开来解释：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">可：可以。</span><br><span class="line">重：再次。</span><br><span class="line">入：进入。</span><br><span class="line">锁：同步锁。</span><br><span class="line"></span><br><span class="line">进入什么:进入同步域（即同步代码块/方法或显式锁锁定的代码）</span><br><span class="line">一句话:一个线程中的多个流程可以获取同一把锁，持有这把同步锁可以再次进入。</span><br><span class="line">自己可以获取自己的内部锁</span><br></pre></td></tr></table></figure><h4 id="2、可重入锁种类"><a href="#2、可重入锁种类" class="headerlink" title="2、可重入锁种类"></a>2、可重入锁种类</h4><h5 id="1、隐式锁（即synchronized关键字使用的锁）默认是可重入锁"><a href="#1、隐式锁（即synchronized关键字使用的锁）默认是可重入锁" class="headerlink" title="1、隐式锁（即synchronized关键字使用的锁）默认是可重入锁"></a>1、隐式锁（即synchronized关键字使用的锁）默认是可重入锁</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">指的是可重复可递归调用的锁，在外层使用锁之后，在内层仍然可以使用，并且不发生死锁，这样的锁就叫做可重入锁。</span><br><span class="line">简单的来说就是：在一个synchronized修饰的方法或代码块的内部调用本类的其他synchronized修饰的方法或代码块时，是永远可以得到锁的</span><br><span class="line"></span><br><span class="line">与可重入锁相反，不可重入锁不可递归调用，递归调用就发生死锁。</span><br></pre></td></tr></table></figure><p>同步块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReEntryLockDemo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">objectLockA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (objectLockA)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;-----外层调用&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (objectLockA)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;-----中层调用&quot;</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (objectLockA)&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;-----内层调用&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;a&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同步方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReEntryLockDemo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-----m1&quot;</span>);</span><br><span class="line">        m2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-----m2&quot;</span>);</span><br><span class="line">        m3();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">m3</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-----m3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">ReEntryLockDemo</span> <span class="variable">reEntryLockDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReEntryLockDemo</span>();</span><br><span class="line"></span><br><span class="line">        reEntryLockDemo.m1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2、显式锁（即Lock）也有ReentrantLock这样的可重入锁。"><a href="#2、显式锁（即Lock）也有ReentrantLock这样的可重入锁。" class="headerlink" title="2、显式锁（即Lock）也有ReentrantLock这样的可重入锁。"></a>2、显式锁（即Lock）也有ReentrantLock这样的可重入锁。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo4</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            num++;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">T</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">                Demo4.add();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>();</span><br><span class="line">        <span class="type">T</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>();</span><br><span class="line">        <span class="type">T</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>();</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        t3.join();</span><br><span class="line">        System.out.println(Demo4.num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中add()方法中，当一个线程进入的时候，会执行2次获取锁的操作，运行程序可以正常结束，并输出和期望值一样的30000，假如ReentrantLock是不可重入的锁，那么同一个线程第2次获取锁的时候由于前面的锁还未释放而导致死锁，程序是无法正常结束的。ReentrantLock命名也挺好的Re entrant Lock，和其名字一样，可重入锁。</p><p>代码中还有几点需要注意：</p><ol><li><strong>lock()方法和unlock()方法需要成对出现，锁了几次，也要释放几次，否则后面的线程无法获取锁了；可以将add中的unlock删除一个事实，上面代码运行将无法结束</strong></li><li><strong>unlock()方法放在finally中执行，保证不管程序是否有异常，锁必定会释放</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-05-14 11:59</span></span><br><span class="line"><span class="comment"> * 在一个Synchronized修饰的方法或代码块的内部调用本类的其他Synchronized修饰的方法或代码块时，是永远可以得到锁的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReEntryLockDemo</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;----外层调用lock&quot;</span>);</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;----内层调用lock&quot;</span>);</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 这里故意注释，实现加锁次数和释放次数不一样</span></span><br><span class="line">                    <span class="comment">// 由于加锁次数和释放次数不一样，第二个线程始终无法获取到锁，导致一直在等待。</span></span><br><span class="line">                    lock.unlock(); <span class="comment">// 正常情况，加锁几次就要解锁几次</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;a&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;b thread----外层调用lock&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;b&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、Synchronized的重入的实现机理"><a href="#3、Synchronized的重入的实现机理" class="headerlink" title="3、Synchronized的重入的实现机理"></a>3、Synchronized的重入的实现机理</h4><p>​每个锁对象拥有一个锁计数器和一个指向持有该锁的线程的指针。</p><p>​当执行monitorenter时，如果目标锁对象的计数器为零，那么说明它没有被其他线程所持有，Java虚拟机会将该锁对象的持有线程设置为当前线程，并且将其计数器加1。</p><p>​在目标锁对象的计数器不为零的情况下，如果锁对象的持有线程是当前线程，那么 Java 虚拟机可以将其计数器加1，否则需要等待，直至持有线程释放该锁。</p><p>​当执行monitorexit时，Java虚拟机则需将锁对象的计数器减1。计数器为零代表锁已被释放。</p><h3 id="10、死锁"><a href="#10、死锁" class="headerlink" title="10、死锁"></a>10、死锁</h3><p>​死锁是指两个或两个以上的线程在执行过程中,因争夺资源而造成的一种互相等待的现象,若无外力干涉那它们都将无法推进下去，如果系统资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就很低，否则就会因争夺有限的资源而陷入死锁。</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/%E5%9B%BE%E5%83%8F.png" alt="图像"></p><h4 id="1、产生死锁主要原因"><a href="#1、产生死锁主要原因" class="headerlink" title="1、产生死锁主要原因"></a>1、产生死锁主要原因</h4><ol><li>系统资源不足</li><li>进程运行推进的顺序不合适</li><li>资源分配不当</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLockDemo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">objectLockA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">objectLockB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (objectLockA)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;自己持有A，希望获得B&quot;</span>);</span><br><span class="line">                <span class="comment">//暂停几秒钟线程</span></span><br><span class="line">                <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">1</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (objectLockB)</span><br><span class="line">                &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;A-------已经获得B&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (objectLockB)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;自己持有B，希望获得A&quot;</span>);</span><br><span class="line">                <span class="comment">//暂停几秒钟线程</span></span><br><span class="line">                <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">1</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (objectLockA)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;B-------已经获得A&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、如何排查死锁"><a href="#2、如何排查死锁" class="headerlink" title="2、如何排查死锁"></a>2、如何排查死锁</h4><ol><li>纯命令</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jps -l</span><br><span class="line">jstack 进程编号</span><br></pre></td></tr></table></figure><ol start="2"><li>图形化</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jconsole</span><br></pre></td></tr></table></figure><h2 id="五、线程间通信"><a href="#五、线程间通信" class="headerlink" title="五、线程间通信"></a>五、线程间通信</h2><h3 id="1、面试题：两个线程打印"><a href="#1、面试题：两个线程打印" class="headerlink" title="1、面试题：两个线程打印"></a>1、面试题：两个线程打印</h3><p>两个线程，一个线程打印1-52，另一个打印字母A-Z打印顺序为12A34B…5152Z</p><h4 id="1、synchronized实现"><a href="#1、synchronized实现" class="headerlink" title="1、synchronized实现"></a>1、synchronized实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xue.thread;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShareDataOne</span><span class="comment">//资源类&#123;</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//初始值为零的一个变量</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">     <span class="comment">//1判断</span></span><br><span class="line">     <span class="keyword">if</span>(number !=<span class="number">0</span> ) &#123;</span><br><span class="line">       <span class="built_in">this</span>.wait();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//2干活</span></span><br><span class="line">     ++number;</span><br><span class="line">     System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+number);</span><br><span class="line">     <span class="comment">//3通知</span></span><br><span class="line">     <span class="built_in">this</span>.notifyAll();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">     <span class="comment">// 1判断</span></span><br><span class="line">     <span class="keyword">if</span> (number == <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="built_in">this</span>.wait();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 2干活</span></span><br><span class="line">     --number;</span><br><span class="line">     System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + number);</span><br><span class="line">     <span class="comment">// 3通知</span></span><br><span class="line">     <span class="built_in">this</span>.notifyAll();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> *现在两个线程，</span></span><br><span class="line"><span class="comment"> * 可以操作初始值为零的一个变量，</span></span><br><span class="line"><span class="comment"> * 实现一个线程对该变量加1，一个线程对该变量减1，</span></span><br><span class="line"><span class="comment"> * 交替，来10轮。 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xialei</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  * 笔记：Java里面如何进行工程级别的多线程编写</span></span><br><span class="line"><span class="comment"> * 1 多线程变成模板（套路）-----上</span></span><br><span class="line"><span class="comment"> *     1.1  线程    操作    资源类  </span></span><br><span class="line"><span class="comment"> *     1.2  高内聚  低耦合</span></span><br><span class="line"><span class="comment"> * 2 多线程变成模板（套路）-----下</span></span><br><span class="line"><span class="comment"> *     2.1  判断</span></span><br><span class="line"><span class="comment"> *     2.2  干活</span></span><br><span class="line"><span class="comment"> *     2.3  通知</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NotifyWaitDemoOne</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">     <span class="type">ShareDataOne</span> <span class="variable">sd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShareDataOne</span>();</span><br><span class="line">     <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            sd.increment();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">     <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            sd.decrement();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * * </span></span><br><span class="line"><span class="comment"> * 2 多线程变成模板（套路）-----下</span></span><br><span class="line"><span class="comment"> *     2.1  判断</span></span><br><span class="line"><span class="comment"> *     2.2  干活</span></span><br><span class="line"><span class="comment"> *     2.3  通知</span></span><br><span class="line"><span class="comment"> * 3 防止虚假唤醒用while</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * */</span></span><br></pre></td></tr></table></figure><h4 id="2、换成4个线程"><a href="#2、换成4个线程" class="headerlink" title="2、换成4个线程"></a>2、换成4个线程</h4><p>​换成4个线程会导致错误，虚假唤醒</p><p>​原因：在java多线程判断时，不能用if，程序出事出在了判断上面，</p><p>突然有一添加的线程进到if了，突然中断了交出控制权，</p><p>没有进行验证，而是直接走下去了，加了两次，甚至多次</p><h4 id="3、4个线程解决方案"><a href="#3、4个线程解决方案" class="headerlink" title="3、4个线程解决方案"></a>3、4个线程解决方案</h4><p>解决虚假唤醒：查看API，java.lang.Object</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/1614161426163-57912cc0-5b3e-4851-93f4-6d7c4c97118b.png" alt="image"></p><p>中断和虚假唤醒是可能产生的，所以要用loop循环，if只判断一次，while是只要唤醒就要拉回来再判断一次。if换成while</p><h4 id="4、java8新版实现"><a href="#4、java8新版实现" class="headerlink" title="4、java8新版实现"></a>4、java8新版实现</h4><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/1614161433565-2c36af0b-fd95-455c-a4a3-7e3bcff3c86b.png" alt="image"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BoundedBuffer</span> &#123;</span><br><span class="line">   <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">   <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">notFull</span>  <span class="operator">=</span> lock.newCondition(); </span><br><span class="line">   <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">notEmpty</span> <span class="operator">=</span> lock.newCondition(); </span><br><span class="line"> </span><br><span class="line">   <span class="keyword">final</span> Object[] items = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">100</span>];</span><br><span class="line">   <span class="type">int</span> putptr, takeptr, count;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(Object x)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">     lock.lock();</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="keyword">while</span> (count == items.length)</span><br><span class="line">         notFull.await();</span><br><span class="line">       items[putptr] = x;</span><br><span class="line">       <span class="keyword">if</span> (++putptr == items.length) putptr = <span class="number">0</span>;</span><br><span class="line">       ++count;</span><br><span class="line">       notEmpty.signal();</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       lock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xue.thread;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.omg.IOP.Codec;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShareData</span><span class="comment">//资源类</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//初始值为零的一个变量</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">  <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition</span>  <span class="operator">=</span> lock.newCondition(); </span><br><span class="line">   </span><br><span class="line">  <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span><br><span class="line">  &#123;</span><br><span class="line">     </span><br><span class="line">      lock.lock();</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//判断</span></span><br><span class="line">          <span class="keyword">while</span>(number!=<span class="number">0</span>) &#123;</span><br><span class="line">            condition.await();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//干活</span></span><br><span class="line">          ++number;</span><br><span class="line">          System.out.println(Thread.currentThread().getName()+<span class="string">&quot; \t &quot;</span>+number);</span><br><span class="line">          <span class="comment">//通知</span></span><br><span class="line">          condition.signalAll();</span><br><span class="line">     &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       lock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span><br><span class="line">  &#123;</span><br><span class="line">      </span><br><span class="line">      lock.lock();</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//判断</span></span><br><span class="line">          <span class="keyword">while</span>(number!=<span class="number">1</span>) &#123;</span><br><span class="line">            condition.await();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//干活</span></span><br><span class="line">          --number;</span><br><span class="line">          System.out.println(Thread.currentThread().getName()+<span class="string">&quot; \t &quot;</span>+number);</span><br><span class="line">          <span class="comment">//通知</span></span><br><span class="line">          condition.signalAll();</span><br><span class="line">     &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       lock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/*public synchronized void increment() throws InterruptedException </span></span><br><span class="line"><span class="comment">  &#123;</span></span><br><span class="line"><span class="comment">     //判断</span></span><br><span class="line"><span class="comment">     while(number!=0) &#123;</span></span><br><span class="line"><span class="comment">       this.wait();</span></span><br><span class="line"><span class="comment">     &#125;</span></span><br><span class="line"><span class="comment">     //干活</span></span><br><span class="line"><span class="comment">     ++number;</span></span><br><span class="line"><span class="comment">     System.out.println(Thread.currentThread().getName()+&quot; \t &quot;+number);</span></span><br><span class="line"><span class="comment">     //通知</span></span><br><span class="line"><span class="comment">     this.notifyAll();;</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  public synchronized void decrement() throws InterruptedException </span></span><br><span class="line"><span class="comment">  &#123;</span></span><br><span class="line"><span class="comment">     //判断</span></span><br><span class="line"><span class="comment">     while(number!=1) &#123;</span></span><br><span class="line"><span class="comment">       this.wait();</span></span><br><span class="line"><span class="comment">     &#125;</span></span><br><span class="line"><span class="comment">     //干活</span></span><br><span class="line"><span class="comment">     --number;</span></span><br><span class="line"><span class="comment">     System.out.println(Thread.currentThread().getName()+&quot; \t &quot;+number);</span></span><br><span class="line"><span class="comment">     //通知</span></span><br><span class="line"><span class="comment">     this.notifyAll();</span></span><br><span class="line"><span class="comment">  &#125;*/</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> *现在两个线程，</span></span><br><span class="line"><span class="comment"> * 可以操作初始值为零的一个变量，</span></span><br><span class="line"><span class="comment"> * 实现一个线程对该变量加1，一个线程对该变量减1，</span></span><br><span class="line"><span class="comment"> * 交替，来10轮。 </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  * 笔记：Java里面如何进行工程级别的多线程编写</span></span><br><span class="line"><span class="comment"> * 1 多线程变成模板（套路）-----上</span></span><br><span class="line"><span class="comment"> *     1.1  线程    操作    资源类  </span></span><br><span class="line"><span class="comment"> *     1.2  高内聚  低耦合</span></span><br><span class="line"><span class="comment"> * 2 多线程变成模板（套路）-----下</span></span><br><span class="line"><span class="comment"> *     2.1  判断</span></span><br><span class="line"><span class="comment"> *     2.2  干活</span></span><br><span class="line"><span class="comment"> *     2.3  通知</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NotifyWaitDemo</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">  &#123;</span><br><span class="line">     <span class="type">ShareData</span> <span class="variable">sd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShareData</span>();</span><br><span class="line">     <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line"> </span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            sd.increment();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line"> </span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            sd.decrement();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">     <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line"> </span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            sd.increment();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">     <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line"> </span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            sd.decrement();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;, <span class="string">&quot;D&quot;</span>).start();</span><br><span class="line">     </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * * </span></span><br><span class="line"><span class="comment"> * 2 多线程变成模板（套路）-----下</span></span><br><span class="line"><span class="comment"> *     2.1  判断</span></span><br><span class="line"><span class="comment"> *     2.2  干活</span></span><br><span class="line"><span class="comment"> *     2.3  通知</span></span><br><span class="line"><span class="comment"> * 3 防止虚假唤醒用while</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * */</span></span><br></pre></td></tr></table></figure><h3 id="2、线程间定制化调用通信"><a href="#2、线程间定制化调用通信" class="headerlink" title="2、线程间定制化调用通信"></a>2、线程间定制化调用通信</h3><p>1、有顺序通知，需要有标识位</p><p>2、有一个锁Lock，3把钥匙Condition</p><p>3、判断标志位</p><p>4、输出线程名+第几次+第几轮</p><p>5、修改标志位，通知下一个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xue.thread;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShareResource</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//1:A 2:B 3:C </span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">  <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">c1</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">  <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">c2</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">  <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">c3</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print5</span><span class="params">(<span class="type">int</span> totalLoopNumber)</span></span><br><span class="line">  &#123;</span><br><span class="line">     lock.lock();</span><br><span class="line">     <span class="keyword">try</span> </span><br><span class="line">     &#123;</span><br><span class="line">       <span class="comment">//1 判断</span></span><br><span class="line">       <span class="keyword">while</span>(number != <span class="number">1</span>)</span><br><span class="line">       &#123;</span><br><span class="line">          <span class="comment">//A 就要停止</span></span><br><span class="line">          c1.await();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//2 干活</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">5</span>; i++) </span><br><span class="line">       &#123;</span><br><span class="line">          System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+i+<span class="string">&quot;\t totalLoopNumber: &quot;</span>+totalLoopNumber);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//3 通知</span></span><br><span class="line">       number = <span class="number">2</span>;</span><br><span class="line">       c2.signal();</span><br><span class="line">     &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       lock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print10</span><span class="params">(<span class="type">int</span> totalLoopNumber)</span></span><br><span class="line">  &#123;</span><br><span class="line">     lock.lock();</span><br><span class="line">     <span class="keyword">try</span> </span><br><span class="line">     &#123;</span><br><span class="line">       <span class="comment">//1 判断</span></span><br><span class="line">       <span class="keyword">while</span>(number != <span class="number">2</span>)</span><br><span class="line">       &#123;</span><br><span class="line">          <span class="comment">//A 就要停止</span></span><br><span class="line">          c2.await();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//2 干活</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">10</span>; i++) </span><br><span class="line">       &#123;</span><br><span class="line">          System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+i+<span class="string">&quot;\t totalLoopNumber: &quot;</span>+totalLoopNumber);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//3 通知</span></span><br><span class="line">       number = <span class="number">3</span>;</span><br><span class="line">       c3.signal();</span><br><span class="line">     &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       lock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print15</span><span class="params">(<span class="type">int</span> totalLoopNumber)</span></span><br><span class="line">  &#123;</span><br><span class="line">     lock.lock();</span><br><span class="line">     <span class="keyword">try</span> </span><br><span class="line">     &#123;</span><br><span class="line">       <span class="comment">//1 判断</span></span><br><span class="line">       <span class="keyword">while</span>(number != <span class="number">3</span>)</span><br><span class="line">       &#123;</span><br><span class="line">          <span class="comment">//A 就要停止</span></span><br><span class="line">          c3.await();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//2 干活</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">15</span>; i++) </span><br><span class="line">       &#123;</span><br><span class="line">          System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+i+<span class="string">&quot;\t totalLoopNumber: &quot;</span>+totalLoopNumber);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//3 通知</span></span><br><span class="line">       number = <span class="number">1</span>;</span><br><span class="line">       c1.signal();</span><br><span class="line">     &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       lock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: </span></span><br><span class="line"><span class="comment"> * 多线程之间按顺序调用，实现A-&gt;B-&gt;C</span></span><br><span class="line"><span class="comment"> * 三个线程启动，要求如下：</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * AA打印5次，BB打印10次，CC打印15次</span></span><br><span class="line"><span class="comment"> * 接着</span></span><br><span class="line"><span class="comment"> * AA打印5次，BB打印10次，CC打印15次</span></span><br><span class="line"><span class="comment"> * ......来10轮  </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadOrderAccess</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">  &#123;</span><br><span class="line">     <span class="type">ShareResource</span> <span class="variable">sr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShareResource</span>();</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">10</span>; i++) </span><br><span class="line">       &#123;</span><br><span class="line">          sr.print5(i);</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;, <span class="string">&quot;AA&quot;</span>).start();</span><br><span class="line">     <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">10</span>; i++) </span><br><span class="line">       &#123;</span><br><span class="line">          sr.print10(i);</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;, <span class="string">&quot;BB&quot;</span>).start();</span><br><span class="line">     <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">10</span>; i++) </span><br><span class="line">       &#123;</span><br><span class="line">          sr.print15(i);</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;, <span class="string">&quot;CC&quot;</span>).start();   </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="六、LockSupport与线程中断"><a href="#六、LockSupport与线程中断" class="headerlink" title="六、LockSupport与线程中断"></a>六、LockSupport与线程中断</h2><h3 id="1、线程中断机制"><a href="#1、线程中断机制" class="headerlink" title="1、线程中断机制"></a>1、线程中断机制</h3><h5 id="1、如何停止、中断一个运行中的线程？？"><a href="#1、如何停止、中断一个运行中的线程？？" class="headerlink" title="1、如何停止、中断一个运行中的线程？？"></a>1、如何停止、中断一个运行中的线程？？</h5><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/fdsfsdf.png" alt="fdsfsdf"></p><h5 id="2、什么是中断？"><a href="#2、什么是中断？" class="headerlink" title="2、什么是中断？"></a>2、什么是中断？</h5><p>首先<br>        一个线程不应该由其他线程来强制中断或停止，而是应该由线程自己自行停止。所以，Thread.stop, Thread.suspend, Thread.resume 都已经被废弃了。</p><p>其次<br>        在Java中没有办法立即停止一条线程，然而停止线程却显得尤为重要，如取消一个耗时操作。因此，Java提供了一种用于停止线程的机制——中断。</p><p>​中断只是一种协作机制，Java没有给中断增加任何语法，中断的过程完全需要程序员自己实现。若要中断一个线程，你需要手动调用该线程的interrupt方法，该方法也仅仅是将线程对象的中断标识设成true；接着你需要自己写代码不断地检测当前线程的标识位，如果为true，表示别的线程要求这条线程中断，<br>此时究竟该做什么需要你自己写代码实现。</p><p>​每个线程对象中都有一个标识，用于表示线程是否被中断；该标识位为true表示中断，为false表示未中断；通过调用线程对象的interrupt方法将该线程的标识位设为true；可以在别的线程中调用，也可以在自己的线程中调用</p><h5 id="3、中断的相关API方法"><a href="#3、中断的相关API方法" class="headerlink" title="3、中断的相关API方法"></a>3、中断的相关API方法</h5><table><thead><tr><th>public void interrupt()</th><th>实例方法，<br/>实例方法interrupt()仅仅是设置线程的中断状态为true，不会停止线程</th></tr></thead><tbody><tr><td>public static boolean interrupted()</td><td>静态方法，Thread.interrupted();  <br/>判断线程是否被中断，并清除当前中断状态<br/>这个方法做了两件事：<br/>1 返回当前线程的中断状态<br/>2 将当前线程的中断状态设为false<br/> <br/>这个方法有点不好理解，因为连续调用两次的结果可能不一样。</td></tr><tr><td>public boolean isInterrupted()</td><td>实例方法，<br/>判断当前线程是否被中断（通过检查中断标志位）</td></tr></tbody></table><h3 id="2、如何使用中断标识停止线程？"><a href="#2、如何使用中断标识停止线程？" class="headerlink" title="2、如何使用中断标识停止线程？"></a>2、如何使用中断标识停止线程？</h3><p>在需要中断的线程中不断监听中断状态，一旦发生中断，就执行相应的中断处理业务逻辑。</p><h4 id="1、通过一个volatile变量实现"><a href="#1、通过一个volatile变量实现" class="headerlink" title="1、通过一个volatile变量实现"></a>1、通过一个volatile变量实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterruptDemo</span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">exit</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">T</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="comment">//循环处理业务</span></span><br><span class="line">                <span class="keyword">if</span> (exit) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setExit</span><span class="params">()</span> &#123;</span><br><span class="line">        exit = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>();</span><br><span class="line">        t.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        setExit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中启动了一个线程，线程的run方法中有个死循环，内部通过exit变量的值来控制是否退出。<code>TimeUnit.SECONDS.sleep(3);</code>让主线程休眠3秒，此处为什么使用TimeUnit？TimeUnit使用更方便一些，能够很清晰的控制休眠时间，底层还是转换为Thread.sleep实现的。程序有个重点：<strong>volatile</strong>关键字，exit变量必须通过这个修饰，如果把这个去掉，程序无法正常退出。volatile控制了变量在多线程中的可见性。</p><h4 id="2、通过AtomicBoolean"><a href="#2、通过AtomicBoolean" class="headerlink" title="2、通过AtomicBoolean"></a>2、通过AtomicBoolean</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StopThreadDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">AtomicBoolean</span> <span class="variable">atomicBoolean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span>(atomicBoolean.get())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123; TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;-----hello&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">3</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line"></span><br><span class="line">        atomicBoolean.set(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、通过Thread类自带的中断api方法实现"><a href="#3、通过Thread类自带的中断api方法实现" class="headerlink" title="3、通过Thread类自带的中断api方法实现"></a>3、通过Thread类自带的中断api方法实现</h4><ol><li>实例方法interrupt()，没有返回值</li></ol><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210916231409508.png" alt="image-20210916231409508"></p><table><thead><tr><th>public void interrupt()</th><th>实例方法，<br/>调用interrupt()方法仅仅是在当前线程中打了一个停止的标记，并不是真正立刻停止线程。</th></tr></thead></table><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/vcxvdfgsdgdg.png" alt="vcxvdfgsdgdg"></p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210916231506817.png" alt="image-20210916231506817"></p><ol start="2"><li>实例方法isInterrupted，返回布尔值</li></ol><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210916231603313.png" alt="image-20210916231603313"></p><table><thead><tr><th>public boolean isInterrupted()</th><th>实例方法，<br/>获取中断标志位的当前值是什么，<br/>判断当前线程是否被中断（通过检查中断标志位），默认是false</th></tr></thead></table><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210916231626044.png" alt="image-20210916231626044"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterruptDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(Thread.currentThread().isInterrupted())</span><br><span class="line">                &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;-----t1 线程被中断了，break，程序结束&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;-----hello&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;**************&quot;</span>+t1.isInterrupted());</span><br><span class="line">        <span class="comment">//暂停5毫秒</span></span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.MILLISECONDS.sleep(<span class="number">5</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">        t1.interrupt();</span><br><span class="line">        System.out.println(<span class="string">&quot;**************&quot;</span>+t1.isInterrupted());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上面的程序，程序可以正常结束。线程内部有个中断标志，当调用线程的interrupt()实例方法之后，线程的中断标志会被置为true，可以通过线程的实例方法isInterrupted()获取线程的中断标志。</p><h4 id="4、当前线程的中断标识为true，是不是就立刻停止？"><a href="#4、当前线程的中断标识为true，是不是就立刻停止？" class="headerlink" title="4、当前线程的中断标识为true，是不是就立刻停止？"></a>4、当前线程的中断标识为true，是不是就立刻停止？</h4><p>具体来说，当对一个线程，调用 interrupt() 时：</p><p>①  如果线程处于正常活动状态，那么会将该线程的中断标志设置为 true，仅此而已。<br>被设置中断标志的线程将继续正常运行，不受影响。所以， interrupt() 并不能真正的中断线程，需要被调用的线程自己进行配合才行。</p><p>②  如果线程处于被阻塞状态（例如处于sleep, wait, join 等状态），在别的线程中调用当前线程对象的interrupt方法，<br>那么线程将立即退出被阻塞状态，并抛出一个InterruptedException异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterruptDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">300</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;-------&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;after t1.interrupt()--第2次---: &quot;</span> + Thread.currentThread().isInterrupted());</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;before t1.interrupt()----: &quot;</span> + t1.isInterrupted());</span><br><span class="line">        <span class="comment">//实例方法interrupt()仅仅是设置线程的中断状态位设置为true，不会停止线程</span></span><br><span class="line">        t1.interrupt();</span><br><span class="line">        <span class="comment">//活动状态,t1线程还在执行中</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;after t1.interrupt()--第1次---: &quot;</span> + t1.isInterrupted());</span><br><span class="line">        <span class="comment">//非活动状态,t1线程不在执行中，已经结束执行了。</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;after t1.interrupt()--第3次---: &quot;</span> + t1.isInterrupted());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210916231745805.png" alt="image-20210916231745805"></p><p><img src="/images/1.JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20210916231758523.png" alt="image-20210916231758523"></p><p><strong>中断只是一种协同机制，修改中断标识位仅此而已，不是立刻stop打断</strong></p><h4 id="5、静态方法Thread-interrupted"><a href="#5、静态方法Thread-interrupted" class="headerlink" title="5、静态方法Thread.interrupted()"></a>5、静态方法Thread.interrupted()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 作用是测试当前线程是否被中断（检查中断标志），返回一个boolean并清除中断状态，</span></span><br><span class="line"><span class="comment"> * 第二次再调用时中断状态已经被清除，将返回一个false。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterruptDemo</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;---&quot;</span>+Thread.interrupted());</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;---&quot;</span>+Thread.interrupted());</span><br><span class="line">        System.out.println(<span class="string">&quot;111111&quot;</span>);</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">        System.out.println(<span class="string">&quot;222222&quot;</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;---&quot;</span>+Thread.interrupted());</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;---&quot;</span>+Thread.interrupted());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>public static boolean interrupted()</th><th>静态方法，Thread.interrupted();  <br/>判断线程是否被中断，并清除当前中断状态，类似i++<br/>这个方法做了两件事：<br/>1 返回当前线程的中断状态<br/>2 将当前线程的中断状态设为false<br/> <br/>这个方法有点不好理解，因为连续调用两次的结果可能不一样。</th></tr></thead></table><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210916231923048.png" alt="image-20210916231923048"></p><p>都会返回中断状态，两者对比</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210916231944854.png" alt="image-20210916231944854"></p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210916232053782.png"></p><h4 id="6、总结-1"><a href="#6、总结-1" class="headerlink" title="6、总结"></a>6、总结</h4><p>线程中断相关的方法：</p><p>interrupt()方法是一个实例方法<br>        它通知目标线程中断，也就是设置目标线程的中断标志位为true，中断标志位表示当前线程已经被中断了。</p><p>isInterrupted()方法也是一个实例方法<br>        它判断当前线程是否被中断（通过检查中断标志位）并获取中断标志</p><p>Thread类的静态方法interrupted()<br>        返回当前线程的中断状态(boolean类型)且将当前线程的中断状态设为false，此方法调用之后会清除当前线程的中断标志位的状态（将中断标志置为false了），返回当前值并清零置false</p><h3 id="3、LockSupport是什么"><a href="#3、LockSupport是什么" class="headerlink" title="3、LockSupport是什么"></a>3、LockSupport是什么</h3><p><strong>LockSupport</strong>位于<strong>java.util.concurrent</strong>（<strong>简称juc</strong>）包中，算是juc中一个基础类，juc中很多地方都会使用LockSupport，非常重要，希望大家一定要掌握。</p><p>关于线程等待&#x2F;唤醒的方法，前面的文章中我们已经讲过2种了：</p><ol><li>方式1：使用Object中的wait()方法让线程等待，使用Object中的notify()方法唤醒线程</li><li>方式2：使用juc包中Condition的await()方法让线程等待，使用signal()方法唤醒线程</li></ol><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210916232319808.png" alt="image-20210916232319808"></p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210916232333615.png" alt="image-20210916232333615"></p><p><img src="/images/1.JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20210916232340860.png" alt="image-20210916232340860"></p><p>LockSupport是用来创建锁和其他同步类的基本线程阻塞原语。</p><p>下面这句话，后面详细说<br>LockSupport中的park() 和 unpark() 的作用分别是阻塞线程和解除阻塞线程</p><h3 id="4、线程等待唤醒机制"><a href="#4、线程等待唤醒机制" class="headerlink" title="4、线程等待唤醒机制"></a>4、线程等待唤醒机制</h3><h4 id="1、3种让线程等待和唤醒的方法"><a href="#1、3种让线程等待和唤醒的方法" class="headerlink" title="1、3种让线程等待和唤醒的方法"></a>1、3种让线程等待和唤醒的方法</h4><ol><li>使用Object中的wait()方法让线程等待，使用Object中的notify()方法唤醒线程</li><li>使用JUC包中Condition的await()方法让线程等待，使用signal()方法唤醒线程</li><li>LockSupport类可以阻塞当前线程以及唤醒指定被阻塞的线程</li></ol><h4 id="2、Object类中的wait和notify方法实现线程等待和唤醒"><a href="#2、Object类中的wait和notify方法实现线程等待和唤醒" class="headerlink" title="2、Object类中的wait和notify方法实现线程等待和唤醒"></a>2、Object类中的wait和notify方法实现线程等待和唤醒</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 要求：t1线程等待3秒钟，3秒钟后t2线程唤醒t1线程继续工作</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1 正常程序演示</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 以下异常情况：</span></span><br><span class="line"><span class="comment"> * 2 wait方法和notify方法，两个都去掉同步代码块后看运行效果</span></span><br><span class="line"><span class="comment"> *   2.1 异常情况</span></span><br><span class="line"><span class="comment"> *   Exception in thread &quot;t1&quot; java.lang.IllegalMonitorStateException at java.lang.Object.wait(Native Method)</span></span><br><span class="line"><span class="comment"> *   Exception in thread &quot;t2&quot; java.lang.IllegalMonitorStateException at java.lang.Object.notify(Native Method)</span></span><br><span class="line"><span class="comment"> *   2.2 结论</span></span><br><span class="line"><span class="comment"> *   Object类中的wait、notify、notifyAll用于线程等待和唤醒的方法，都必须在synchronized内部执行（必须用到关键字synchronized）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 3 将notify放在wait方法前面</span></span><br><span class="line"><span class="comment"> *   3.1 程序一直无法结束</span></span><br><span class="line"><span class="comment"> *   3.2 结论</span></span><br><span class="line"><span class="comment"> *   先wait后notify、notifyall方法，等待中的线程才会被唤醒，否则无法唤醒</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockSupportDemo</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span><span class="comment">//main方法，主线程一切程序入口</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">objectLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">//同一把锁，类似资源类</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (objectLock) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    objectLock.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;被唤醒了&quot;</span>);</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//暂停几秒钟线程</span></span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">3L</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (objectLock) &#123;</span><br><span class="line">                objectLock.notify();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//objectLock.notify();</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/*synchronized (objectLock) &#123;</span></span><br><span class="line"><span class="comment">                try &#123;</span></span><br><span class="line"><span class="comment">                    objectLock.wait();</span></span><br><span class="line"><span class="comment">                &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">                    e.printStackTrace();</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;*/</span></span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1、正常"><a href="#1、正常" class="headerlink" title="1、正常"></a>1、正常</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockSupportDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span><span class="comment">//main方法，主线程一切程序入口</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">objectLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">//同一把锁，类似资源类</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (objectLock) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    objectLock.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;被唤醒了&quot;</span>);</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//暂停几秒钟线程</span></span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">3L</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (objectLock) &#123;</span><br><span class="line">                objectLock.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2、异常1"><a href="#2、异常1" class="headerlink" title="2、异常1"></a>2、异常1</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 要求：t1线程等待3秒钟，3秒钟后t2线程唤醒t1线程继续工作</span></span><br><span class="line"><span class="comment"> * 以下异常情况：</span></span><br><span class="line"><span class="comment"> * 2 wait方法和notify方法，两个都去掉同步代码块后看运行效果</span></span><br><span class="line"><span class="comment"> *   2.1 异常情况</span></span><br><span class="line"><span class="comment"> *   Exception in thread &quot;t1&quot; java.lang.IllegalMonitorStateException at java.lang.Object.wait(Native Method)</span></span><br><span class="line"><span class="comment"> *   Exception in thread &quot;t2&quot; java.lang.IllegalMonitorStateException at java.lang.Object.notify(Native Method)</span></span><br><span class="line"><span class="comment"> *   2.2 结论</span></span><br><span class="line"><span class="comment"> *   Object类中的wait、notify、notifyAll用于线程等待和唤醒的方法，都必须在synchronized内部执行（必须用到关键字synchronized）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockSupportDemo</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span><span class="comment">//main方法，主线程一切程序入口</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">objectLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">//同一把锁，类似资源类</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    objectLock.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;被唤醒了&quot;</span>);</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//暂停几秒钟线程</span></span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">3L</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            objectLock.notify();</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>wait方法和notify方法，两个都去掉同步代码块</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210916232855724.png" alt="image-20210916232855724"></p><h5 id="3、异常2"><a href="#3、异常2" class="headerlink" title="3、异常2"></a>3、异常2</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 要求：t1线程等待3秒钟，3秒钟后t2线程唤醒t1线程继续工作</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 3 将notify放在wait方法前先执行，t1先notify了，3秒钟后t2线程再执行wait方法</span></span><br><span class="line"><span class="comment"> *   3.1 程序一直无法结束</span></span><br><span class="line"><span class="comment"> *   3.2 结论</span></span><br><span class="line"><span class="comment"> *   先wait后notify、notifyall方法，等待中的线程才会被唤醒，否则无法唤醒</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockSupportDemo</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span><span class="comment">//main方法，主线程一切程序入口</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">objectLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">//同一把锁，类似资源类</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (objectLock) &#123;</span><br><span class="line">                objectLock.notify();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;通知了&quot;</span>);</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//t1先notify了，3秒钟后t2线程再执行wait方法</span></span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">3L</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (objectLock) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    objectLock.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;被唤醒了&quot;</span>);</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将notify放在wait方法前面</p><p>程序无法执行，无法唤醒</p><h5 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、总结</h5><p>wait和notify方法必须要在同步块或者方法里面，且成对出现使用</p><p>先wait后notify才OK</p><h4 id="3、Condition接口中的await后signal方法实现线程的等待和唤醒"><a href="#3、Condition接口中的await后signal方法实现线程的等待和唤醒" class="headerlink" title="3、Condition接口中的await后signal方法实现线程的等待和唤醒"></a>3、Condition接口中的await后signal方法实现线程的等待和唤醒</h4><h5 id="1、正常-1"><a href="#1、正常-1" class="headerlink" title="1、正常"></a>1、正常</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockSupportDemo2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">        <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;start&quot;</span>);</span><br><span class="line">                condition.await();</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;被唤醒&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//暂停几秒钟线程</span></span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">3L</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                condition.signal();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;通知了&quot;</span>);</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2、异常1-1"><a href="#2、异常1-1" class="headerlink" title="2、异常1"></a>2、异常1</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 异常：</span></span><br><span class="line"><span class="comment"> * condition.await();和condition.signal();都触发了IllegalMonitorStateException异常</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 原因：调用condition中线程等待和唤醒的方法的前提是，要在lock和unlock方法中,要有锁才能调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockSupportDemo2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">        <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;start&quot;</span>);</span><br><span class="line">                condition.await();</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;被唤醒&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//暂停几秒钟线程</span></span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">3L</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                condition.signal();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;通知了&quot;</span>);</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>去掉lock&#x2F;unlock</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210916233230684.png" alt="image-20210916233230684"></p><p>condition.await();和 condition.signal();都触发了 IllegalMonitorStateException异常。</p><p>结论：<br>lock、unlock对里面才能正确调用调用condition中线程等待和唤醒的方法</p><h5 id="3、异常2-1"><a href="#3、异常2-1" class="headerlink" title="3、异常2"></a>3、异常2</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 异常：</span></span><br><span class="line"><span class="comment"> * 程序无法运行</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 原因：先await()后signal才OK，否则线程无法被唤醒</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockSupportDemo2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">        <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                condition.signal();</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;signal&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//暂停几秒钟线程</span></span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">3L</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;等待被唤醒&quot;</span>);</span><br><span class="line">                condition.await();</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;被唤醒&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先signal后await</p><h5 id="4、总结-1"><a href="#4、总结-1" class="headerlink" title="4、总结"></a>4、总结</h5><p>Condtion中的线程等待和唤醒方法之前，需要先获取锁</p><p>一定要先await后signal，不要反了</p><h4 id="4、Object和Condition使用的限制条件"><a href="#4、Object和Condition使用的限制条件" class="headerlink" title="4、Object和Condition使用的限制条件"></a>4、Object和Condition使用的限制条件</h4><p>线程先要获得并持有锁，必须在锁块(synchronized或lock)中</p><p>必须要先等待后唤醒，线程才能够被唤醒</p><h4 id="5、LockSupport类中的park等待和unpark唤醒"><a href="#5、LockSupport类中的park等待和unpark唤醒" class="headerlink" title="5、LockSupport类中的park等待和unpark唤醒"></a>5、LockSupport类中的park等待和unpark唤醒</h4><p>通过park()和unpark(thread)方法来实现阻塞和唤醒线程的操作</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210916233452889.png" alt="image-20210916233452889"></p><p>LockSupport是用来创建锁和其他同步类的基本线程阻塞原语。</p><p>​LockSupport类使用了一种名为Permit（许可）的概念来做到阻塞和唤醒线程的功能， 每个线程都有一个许可(permit)，<br>permit只有两个值1和零，默认是零。<br>可以把许可看成是一种(0,1)信号量（Semaphore），但与 Semaphore 不同的是，许可的累加上限是1。</p><h5 id="1、主要方法"><a href="#1、主要方法" class="headerlink" title="1、主要方法"></a>1、主要方法</h5><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210916233517944.png" alt="image-20210916233517944"></p><p><strong>阻塞</strong></p><p>park() &#x2F;park(Object blocker) </p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210916233615025.png" alt="image-20210916233615025"></p><p>阻塞当前线程&#x2F;阻塞传入的具体线程</p><p><strong>唤醒</strong></p><p>unpark(Thread thread) </p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210916233726972.png" alt="image-20210916233726972"></p><p>唤醒处于阻塞状态的指定线程</p><h5 id="2、代码"><a href="#2、代码" class="headerlink" title="2、代码"></a>2、代码</h5><p>正常+无锁块要求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockSupportDemo3</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//正常使用+不需要锁块</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName()+<span class="string">&quot; &quot;</span>+<span class="string">&quot;1111111111111&quot;</span>);</span><br><span class="line">    LockSupport.park();</span><br><span class="line">    System.out.println(Thread.currentThread().getName()+<span class="string">&quot; &quot;</span>+<span class="string">&quot;2222222222222------end被唤醒&quot;</span>);</span><br><span class="line">&#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">t1.start();</span><br><span class="line"></span><br><span class="line"><span class="comment">//暂停几秒钟线程</span></span><br><span class="line"><span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">3</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line"></span><br><span class="line">LockSupport.unpark(t1);</span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">&quot;   -----LockSupport.unparrk() invoked over&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之前错误的先唤醒后等待，LockSupport照样支持</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">T1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">3</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+System.currentTimeMillis());</span><br><span class="line">            LockSupport.park();</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+System.currentTimeMillis()+<span class="string">&quot;---被叫醒&quot;</span>);</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">1</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line"></span><br><span class="line">        LockSupport.unpark(t1);</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+System.currentTimeMillis()+<span class="string">&quot;---unpark over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210916233832563.png" alt="image-20210916233832563"></p><h2 id="七、集合不安全"><a href="#七、集合不安全" class="headerlink" title="七、集合不安全"></a>七、集合不安全</h2><h3 id="1、线程不安全错误"><a href="#1、线程不安全错误" class="headerlink" title="1、线程不安全错误"></a>1、线程不安全错误</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.util.ConcurrentModificationException</span><br><span class="line">ArrayList在迭代的时候如果同时对其进行修改就会</span><br><span class="line">抛出java.util.ConcurrentModificationException异常 并发修改异常</span><br></pre></td></tr></table></figure><h3 id="2、List不安全"><a href="#2、List不安全" class="headerlink" title="2、List不安全"></a>2、List不安全</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;<span class="number">30</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                list.add(UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">8</span>));</span><br><span class="line">                System.out.println(list);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 看ArrayList的源码</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 没有synchronized线程不安全</span></span><br></pre></td></tr></table></figure><h4 id="1、-解决方案"><a href="#1、-解决方案" class="headerlink" title="1、 解决方案"></a>1、 解决方案</h4><h5 id="1、Vector"><a href="#1、Vector" class="headerlink" title="1、Vector"></a>1、Vector</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/1614161454663-ad91cc9b-df6d-46b9-b9ea-cb30859660e3.png" alt="image"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 看Vector的源码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    elementData[elementCount++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 有synchronized线程安全</span></span><br></pre></td></tr></table></figure><h5 id="2、Collections"><a href="#2、Collections" class="headerlink" title="2、Collections"></a>2、Collections</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line"><span class="comment">// Collections提供了方法synchronizedList保证list是同步线程安全的</span></span><br><span class="line"><span class="comment">// 那HashMap，HashSet是线程安全的吗？也不是,所以有同样的线程安全方法</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/1614161465300-4f72afb7-5318-41d8-ac75-afa03514b63f.png" alt="image"></p><h5 id="3、写时复制-JUC"><a href="#3、写时复制-JUC" class="headerlink" title="3、写时复制(JUC)"></a>3、写时复制(JUC)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/1614161496374-08a7194a-7fe7-4a1b-8491-73632bbfb33d.png" alt="image"></p><h5 id="4、CopyOnWrite理论"><a href="#4、CopyOnWrite理论" class="headerlink" title="4、CopyOnWrite理论"></a>4、CopyOnWrite理论</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e element to be appended to this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​CopyOnWrite容器即写时复制的容器。往一个容器添加元素的时候，不直接往当前容器Object[]添加，而是先将当前容器Object[]进行Copy，复制出一个新的容器Object[] newElements，然后向新的容器Object[] newElements里添加元素。添加元素后，再将原容器的引用指向新的容器setArray(newElements)。这样做的好处是可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。</p><h3 id="3、Set不安全"><a href="#3、Set不安全" class="headerlink" title="3、Set不安全"></a>3、Set不安全</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();<span class="comment">//线程不安全</span></span><br><span class="line"> </span><br><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArraySet</span>&lt;&gt;();<span class="comment">//线程安全</span></span><br><span class="line">HashSet底层数据结构是什么？</span><br><span class="line">HashMap  ?</span><br><span class="line"> </span><br><span class="line">但HashSet的add是放一个值，而HashMap是放K、V键值对</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">()</span> &#123;</span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、Map不安全"><a href="#4、Map不安全" class="headerlink" title="4、Map不安全"></a>4、Map不安全</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();<span class="comment">//线程不安全</span></span><br><span class="line"></span><br><span class="line">Map&lt;String,String&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();<span class="comment">//线程安全</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CopyOnWriteArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CopyOnWriteArraySet;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 请举例说明集合类是不安全的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NotSafeDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        Map&lt;String,String&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;<span class="number">30</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                map.put(Thread.currentThread().getName(),UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">8</span>));</span><br><span class="line">                System.out.println(map);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setNoSafe</span><span class="params">()</span> &#123;</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArraySet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;<span class="number">30</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                set.add(UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">8</span>));</span><br><span class="line">                System.out.println(set);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">listNoSafe</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//        List&lt;String&gt; list = Arrays.asList(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);</span></span><br><span class="line">        <span class="comment">//        list.forEach(System.out::println);</span></span><br><span class="line">        <span class="comment">//写时复制</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// new CopyOnWriteArrayList&lt;&gt;();</span></span><br><span class="line">        <span class="comment">//Collections.synchronizedList(new ArrayList&lt;&gt;());</span></span><br><span class="line">        <span class="comment">//new Vector&lt;&gt;();//new ArrayList&lt;&gt;();</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;<span class="number">30</span> ; i++) &#123;</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                        list.add(UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">8</span>));</span><br><span class="line">                        System.out.println(list);</span><br><span class="line">                    &#125;,String.valueOf(i)).start();</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写时复制</span></span><br><span class="line"><span class="comment">     CopyOnWrite容器即写时复制的容器。往一个容器添加元素的时候，不直接往当前容器Object[]添加，</span></span><br><span class="line"><span class="comment">     而是先将当前容器Object[]进行Copy，复制出一个新的容器Object[] newElements，然后向新的容器Object[] newElements里添加元素。</span></span><br><span class="line"><span class="comment">     添加元素后，再将原容器的引用指向新的容器setArray(newElements)。</span></span><br><span class="line"><span class="comment">     这样做的好处是可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。</span></span><br><span class="line"><span class="comment">     所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public boolean add(E e) &#123;</span></span><br><span class="line"><span class="comment">        final ReentrantLock lock = this.lock;</span></span><br><span class="line"><span class="comment">        lock.lock();</span></span><br><span class="line"><span class="comment">        try &#123;</span></span><br><span class="line"><span class="comment">            Object[] elements = getArray();</span></span><br><span class="line"><span class="comment">            int len = elements.length;</span></span><br><span class="line"><span class="comment">            Object[] newElements = Arrays.copyOf(elements, len + 1);</span></span><br><span class="line"><span class="comment">            newElements[len] = e;</span></span><br><span class="line"><span class="comment">            setArray(newElements);</span></span><br><span class="line"><span class="comment">            return true;</span></span><br><span class="line"><span class="comment">        &#125; finally &#123;</span></span><br><span class="line"><span class="comment">            lock.unlock();</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure><h2 id="八、JUC强大的辅助类"><a href="#八、JUC强大的辅助类" class="headerlink" title="八、JUC强大的辅助类"></a>八、JUC强大的辅助类</h2><h3 id="1、CountDownLatch减少计数"><a href="#1、CountDownLatch减少计数" class="headerlink" title="1、CountDownLatch减少计数"></a>1、CountDownLatch减少计数</h3><p>CountDownLatch称之为闭锁，它可以使一个或一批线程在闭锁上等待，等到其他线程执行完相应操作后，闭锁打开，这些等待的线程才可以继续执行。确切的说，闭锁在内部维护了一个倒计数器。通过该计数器的值来决定闭锁的状态，从而决定是否允许等待的线程继续执行。</p><p><strong>常用方法：</strong></p><p>**public CountDownLatch(int count)**：构造方法，count表示计数器的值，不能小于0，否者会报异常。</p><p><strong>public void await() throws InterruptedException</strong>：调用await()会让当前线程等待，直到计数器为0的时候，方法才会返回，此方法会响应线程中断操作。</p><p><strong>public boolean await(long timeout, TimeUnit unit) throws InterruptedException</strong>：限时等待，在超时之前，计数器变为了0，方法返回true，否者直到超时，返回false，此方法会响应线程中断操作。</p><p>**public void countDown()**：让计数器减1</p><p>CountDownLatch使用步骤：</p><ol><li>创建CountDownLatch对象</li><li>调用其实例方法<code>await()</code>，让当前线程等待</li><li>调用<code>countDown()</code>方法，让计数器减1</li><li>当计数器变为0的时候，<code>await()</code>方法会返回</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xue.thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> *  *让一些线程阻塞直到另一些线程完成一系列操作后才被唤醒。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * CountDownLatch主要有两个方法，当一个或多个线程调用await方法时，这些线程会阻塞。</span></span><br><span class="line"><span class="comment"> * 其它线程调用countDown方法会将计数器减1(调用countDown方法的线程不会阻塞)，</span></span><br><span class="line"><span class="comment"> * 当计数器的值变为0时，因await方法阻塞的线程会被唤醒，继续执行。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 解释：6个同学陆续离开教室后值班同学才可以关门。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * main主线程必须要等前面6个线程完成全部工作后，自己才能开干 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLatchDemo</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line">   &#123;</span><br><span class="line">         <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">6</span>);</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">6</span>; i++) <span class="comment">//6个上自习的同学，各自离开教室的时间不一致</span></span><br><span class="line">       &#123;</span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">              System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t 号同学离开教室&quot;</span>);</span><br><span class="line">              countDownLatch.countDown();</span><br><span class="line">          &#125;, String.valueOf(i)).start();</span><br><span class="line">       &#125;</span><br><span class="line">       countDownLatch.await();</span><br><span class="line">       System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t****** 班长关门走人，main线程是班长&quot;</span>);</span><br><span class="line">          </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>CountDownLatch主要有两个方法，当一个或多个线程调用await方法时，这些线程会阻塞。</li><li>其它线程调用countDown方法会将计数器减1(调用countDown方法的线程不会阻塞)，</li><li>当计数器的值变为0时，因await方法阻塞的线程会被唤醒，继续执行。</li></ul><h4 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h4><p>假如有这样一个需求，当我们需要解析一个Excel里多个sheet的数据时，可以考虑使用多线程，每个线程解析一个sheet里的数据，等到所有的sheet都解析完之后，程序需要统计解析总耗时。分析一下：解析每个sheet耗时可能不一样，总耗时就是最长耗时的那个操作。</p><p>我们能够想到的最简单的做法是使用join，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">T</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="comment">//休眠时间（秒）</span></span><br><span class="line">        <span class="type">int</span> sleepSeconds;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">T</span><span class="params">(String name, <span class="type">int</span> sleepSeconds)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(name);</span><br><span class="line">            <span class="built_in">this</span>.sleepSeconds = sleepSeconds;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">ct</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">            <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            System.out.println(startTime + <span class="string">&quot;,&quot;</span> + ct.getName() + <span class="string">&quot;,开始处理!&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//模拟耗时操作，休眠sleepSeconds秒</span></span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="built_in">this</span>.sleepSeconds);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            System.out.println(endTime + <span class="string">&quot;,&quot;</span> + ct.getName() + <span class="string">&quot;,处理完毕,耗时:&quot;</span> + (endTime - startTime));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">starTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">T</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>(<span class="string">&quot;解析sheet1线程&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="type">T</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>(<span class="string">&quot;解析sheet2线程&quot;</span>, <span class="number">5</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;总耗时:&quot;</span> + (endTime - starTime));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1563767560271</span>,解析sheet1线程,开始处理!</span><br><span class="line"><span class="number">1563767560272</span>,解析sheet2线程,开始处理!</span><br><span class="line"><span class="number">1563767562273</span>,解析sheet1线程,处理完毕,耗时:<span class="number">2002</span></span><br><span class="line"><span class="number">1563767565274</span>,解析sheet2线程,处理完毕,耗时:<span class="number">5002</span></span><br><span class="line">总耗时:<span class="number">5005</span></span><br></pre></td></tr></table></figure><p>代码中启动了2个解析sheet的线程，第一个耗时2秒，第二个耗时5秒，最终结果中总耗时：5秒。上面的关键技术点是线程的<code>join()</code>方法，此方法会让当前线程等待被调用的线程完成之后才能继续。可以看一下join的源码，内部其实是在synchronized方法中调用了线程的wait方法，最后被调用的线程执行完毕之后，由jvm自动调用其notifyAll()方法，唤醒所有等待中的线程。这个notifyAll()方法是由jvm内部自动调用的，jdk源码中是看不到的，需要看jvm源码，有兴趣的同学可以去查一下。所以JDK不推荐在线程上调用wait、notify、notifyAll方法。</p><p>而在JDK1.5之后的并发包中提供的CountDownLatch也可以实现join的这个功能。</p><p>我们使用CountDownLatch来完成上面示例中使用join实现的功能，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">T</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="comment">//休眠时间（秒）</span></span><br><span class="line">        <span class="type">int</span> sleepSeconds;</span><br><span class="line">        CountDownLatch countDownLatch;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">T</span><span class="params">(String name, <span class="type">int</span> sleepSeconds, CountDownLatch countDownLatch)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(name);</span><br><span class="line">            <span class="built_in">this</span>.sleepSeconds = sleepSeconds;</span><br><span class="line">            <span class="built_in">this</span>.countDownLatch = countDownLatch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">ct</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">            <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            System.out.println(startTime + <span class="string">&quot;,&quot;</span> + ct.getName() + <span class="string">&quot;,开始处理!&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//模拟耗时操作，休眠sleepSeconds秒</span></span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="built_in">this</span>.sleepSeconds);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            System.out.println(endTime + <span class="string">&quot;,&quot;</span> + ct.getName() + <span class="string">&quot;,处理完毕,耗时:&quot;</span> + (endTime - startTime));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis() + <span class="string">&quot;,&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;线程 start!&quot;</span>);</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">starTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">T</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>(<span class="string">&quot;解析sheet1线程&quot;</span>, <span class="number">2</span>, countDownLatch);</span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="type">T</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>(<span class="string">&quot;解析sheet2线程&quot;</span>, <span class="number">5</span>, countDownLatch);</span><br><span class="line">        t2.start();</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(System.currentTimeMillis() + <span class="string">&quot;,&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;线程 end!&quot;</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;总耗时:&quot;</span> + (endTime - starTime));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1563767580511</span>,main线程 start!</span><br><span class="line"><span class="number">1563767580513</span>,解析sheet1线程,开始处理!</span><br><span class="line"><span class="number">1563767580513</span>,解析sheet2线程,开始处理!</span><br><span class="line"><span class="number">1563767582515</span>,解析sheet1线程,处理完毕,耗时:<span class="number">2002</span></span><br><span class="line"><span class="number">1563767585515</span>,解析sheet2线程,处理完毕,耗时:<span class="number">5002</span></span><br><span class="line"><span class="number">1563767585515</span>,main线程 end!</span><br><span class="line">总耗时:<span class="number">5003</span></span><br></pre></td></tr></table></figure><p>从结果中看出，效果和join实现的效果一样，代码中创建了计数器为2的<code>CountDownLatch</code>，主线程中调用<code>countDownLatch.await();</code>会让主线程等待，t1、t2线程中模拟执行耗时操作，最终在finally中调用了<code>countDownLatch.countDown();</code>,此方法每调用一次，CountDownLatch内部计数器会减1，当计数器变为0的时候，主线程中的await()会返回，然后继续执行。注意：上面的<code>countDown()</code>这个是必须要执行的方法，所以放在finally中执行。</p><h4 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h4><p>等待指定的时间</p><p>还是上面的示例，2个线程解析2个sheet，主线程等待2个sheet解析完成。主线程说，我等待2秒，你们还是无法处理完成，就不等待了，直接返回。如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">T</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="comment">//休眠时间（秒）</span></span><br><span class="line">        <span class="type">int</span> sleepSeconds;</span><br><span class="line">        CountDownLatch countDownLatch;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">T</span><span class="params">(String name, <span class="type">int</span> sleepSeconds, CountDownLatch countDownLatch)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(name);</span><br><span class="line">            <span class="built_in">this</span>.sleepSeconds = sleepSeconds;</span><br><span class="line">            <span class="built_in">this</span>.countDownLatch = countDownLatch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">ct</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">            <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            System.out.println(startTime + <span class="string">&quot;,&quot;</span> + ct.getName() + <span class="string">&quot;,开始处理!&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//模拟耗时操作，休眠sleepSeconds秒</span></span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="built_in">this</span>.sleepSeconds);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            System.out.println(endTime + <span class="string">&quot;,&quot;</span> + ct.getName() + <span class="string">&quot;,处理完毕,耗时:&quot;</span> + (endTime - startTime));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis() + <span class="string">&quot;,&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;线程 start!&quot;</span>);</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">starTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">T</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>(<span class="string">&quot;解析sheet1线程&quot;</span>, <span class="number">2</span>, countDownLatch);</span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="type">T</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>(<span class="string">&quot;解析sheet2线程&quot;</span>, <span class="number">5</span>, countDownLatch);</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> countDownLatch.await(<span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">        System.out.println(System.currentTimeMillis() + <span class="string">&quot;,&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;线程 end!&quot;</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程耗时:&quot;</span> + (endTime - starTime) + <span class="string">&quot;,result:&quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1563767637316</span>,main线程 start!</span><br><span class="line"><span class="number">1563767637320</span>,解析sheet1线程,开始处理!</span><br><span class="line"><span class="number">1563767637320</span>,解析sheet2线程,开始处理!</span><br><span class="line"><span class="number">1563767639321</span>,解析sheet1线程,处理完毕,耗时:<span class="number">2001</span></span><br><span class="line"><span class="number">1563767639322</span>,main线程 end!</span><br><span class="line">主线程耗时:<span class="number">2004</span>,result:<span class="literal">false</span></span><br><span class="line"><span class="number">1563767642322</span>,解析sheet2线程,处理完毕,耗时:<span class="number">5002</span></span><br></pre></td></tr></table></figure><p>从输出结果中可以看出，线程2耗时了5秒，主线程耗时了2秒，主线程中调用<code>countDownLatch.await(2, TimeUnit.SECONDS);</code>，表示最多等2秒，不管计数器是否为0，await方法都会返回，若等待时间内，计数器变为0了，立即返回true，否则超时后返回false。</p><h4 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h4><p>2个CountDown结合使用的示例</p><p>有3个人参见跑步比赛，需要先等指令员发指令枪后才能开跑，所有人都跑完之后，指令员喊一声，大家跑完了。</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">T</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="comment">//跑步耗时（秒）</span></span><br><span class="line">        <span class="type">int</span> runCostSeconds;</span><br><span class="line">        CountDownLatch commanderCd;</span><br><span class="line">        CountDownLatch countDown;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">T</span><span class="params">(String name, <span class="type">int</span> runCostSeconds, CountDownLatch commanderCd, CountDownLatch countDown)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(name);</span><br><span class="line">            <span class="built_in">this</span>.runCostSeconds = runCostSeconds;</span><br><span class="line">            <span class="built_in">this</span>.commanderCd = commanderCd;</span><br><span class="line">            <span class="built_in">this</span>.countDown = countDown;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">//等待指令员枪响</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                commanderCd.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">ct</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">            <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            System.out.println(startTime + <span class="string">&quot;,&quot;</span> + ct.getName() + <span class="string">&quot;,开始跑!&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//模拟耗时操作，休眠runCostSeconds秒</span></span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="built_in">this</span>.runCostSeconds);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                countDown.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            System.out.println(endTime + <span class="string">&quot;,&quot;</span> + ct.getName() + <span class="string">&quot;,跑步结束,耗时:&quot;</span> + (endTime - startTime));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis() + <span class="string">&quot;,&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;线程 start!&quot;</span>);</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">commanderCd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">starTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">T</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>(<span class="string">&quot;小张&quot;</span>, <span class="number">2</span>, commanderCd, countDownLatch);</span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="type">T</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>(<span class="string">&quot;小李&quot;</span>, <span class="number">5</span>, commanderCd, countDownLatch);</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="type">T</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>(<span class="string">&quot;路人甲&quot;</span>, <span class="number">10</span>, commanderCd, countDownLatch);</span><br><span class="line">        t3.start();</span><br><span class="line">        <span class="comment">//主线程休眠5秒,模拟指令员准备发枪耗时操作</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        System.out.println(System.currentTimeMillis() + <span class="string">&quot;,枪响了，大家开始跑&quot;</span>);</span><br><span class="line">        commanderCd.countDown();</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(System.currentTimeMillis() + <span class="string">&quot;,&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;所有人跑完了，主线程耗时:&quot;</span> + (endTime - starTime));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1563767691087</span>,main线程 start!</span><br><span class="line"><span class="number">1563767696092</span>,枪响了，大家开始跑</span><br><span class="line"><span class="number">1563767696092</span>,小张,开始跑!</span><br><span class="line"><span class="number">1563767696092</span>,小李,开始跑!</span><br><span class="line"><span class="number">1563767696092</span>,路人甲,开始跑!</span><br><span class="line"><span class="number">1563767698093</span>,小张,跑步结束,耗时:<span class="number">2001</span></span><br><span class="line"><span class="number">1563767701093</span>,小李,跑步结束,耗时:<span class="number">5001</span></span><br><span class="line"><span class="number">1563767706093</span>,路人甲,跑步结束,耗时:<span class="number">10001</span></span><br><span class="line"><span class="number">1563767706093</span>,main所有人跑完了，主线程耗时:<span class="number">15004</span></span><br></pre></td></tr></table></figure><p>代码中，t1、t2、t3启动之后，都阻塞在<code>commanderCd.await();</code>，主线程模拟发枪准备操作耗时5秒，然后调用<code>commanderCd.countDown();</code>模拟发枪操作，此方法被调用以后，阻塞在<code>commanderCd.await();</code>的3个线程会向下执行。主线程调用<code>countDownLatch.await();</code>之后进行等待，每个人跑完之后，调用<code>countDown.countDown();</code>通知一下<code>countDownLatch</code>让计数器减1，最后3个人都跑完了，主线程从<code>countDownLatch.await();</code>返回继续向下执行。</p><h4 id="手写一个并行处理任务的工具类"><a href="#手写一个并行处理任务的工具类" class="headerlink" title="手写一个并行处理任务的工具类"></a>手写一个并行处理任务的工具类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.util.CollectionUtils;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TaskDisposeUtils</span> &#123;</span><br><span class="line">    <span class="comment">//并行线程数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> POOL_SIZE;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        POOL_SIZE = Integer.max(Runtime.getRuntime().availableProcessors(), <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 并行处理，并等待结束</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> taskList 任务列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> consumer 消费者</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">dispose</span><span class="params">(List&lt;T&gt; taskList, Consumer&lt;T&gt; consumer)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        dispose(<span class="literal">true</span>, POOL_SIZE, taskList, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 并行处理，并等待结束</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> moreThread 是否多线程执行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> poolSize   线程池大小</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> taskList   任务列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> consumer   消费者</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">dispose</span><span class="params">(<span class="type">boolean</span> moreThread, <span class="type">int</span> poolSize, List&lt;T&gt; taskList, Consumer&lt;T&gt; consumer)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(taskList)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (moreThread &amp;&amp; poolSize &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            poolSize = Math.min(poolSize, taskList.size());</span><br><span class="line">            <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                executorService = Executors.newFixedThreadPool(poolSize);</span><br><span class="line">                <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(taskList.size());</span><br><span class="line">                <span class="keyword">for</span> (T item : taskList) &#123;</span><br><span class="line">                    executorService.execute(() -&gt; &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            consumer.accept(item);</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            countDownLatch.countDown();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.await();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (executorService != <span class="literal">null</span>) &#123;</span><br><span class="line">                    executorService.shutdown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (T item : taskList) &#123;</span><br><span class="line">                consumer.accept(item);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//生成1-10的10个数字，放在list中，相当于10个任务</span></span><br><span class="line">        List&lt;Integer&gt; list = Stream.iterate(<span class="number">1</span>, a -&gt; a + <span class="number">1</span>).limit(<span class="number">10</span>).collect(Collectors.toList());</span><br><span class="line">        <span class="comment">//启动多线程处理list中的数据，每个任务休眠时间为list中的数值</span></span><br><span class="line">        TaskDisposeUtils.dispose(list, item -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">                TimeUnit.SECONDS.sleep(item);</span><br><span class="line">                <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">                System.out.println(System.currentTimeMillis() + <span class="string">&quot;,任务&quot;</span> + item + <span class="string">&quot;执行完毕，耗时:&quot;</span> + (endTime - startTime));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//上面所有任务处理完毕完毕之后，程序才能继续</span></span><br><span class="line">        System.out.println(list + <span class="string">&quot;中的任务都处理完毕!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行代码输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1563769828130</span>,任务<span class="number">1</span>执行完毕，耗时:<span class="number">1000</span></span><br><span class="line"><span class="number">1563769829130</span>,任务<span class="number">2</span>执行完毕，耗时:<span class="number">2000</span></span><br><span class="line"><span class="number">1563769830131</span>,任务<span class="number">3</span>执行完毕，耗时:<span class="number">3001</span></span><br><span class="line"><span class="number">1563769831131</span>,任务<span class="number">4</span>执行完毕，耗时:<span class="number">4001</span></span><br><span class="line"><span class="number">1563769832131</span>,任务<span class="number">5</span>执行完毕，耗时:<span class="number">5001</span></span><br><span class="line"><span class="number">1563769833130</span>,任务<span class="number">6</span>执行完毕，耗时:<span class="number">6000</span></span><br><span class="line"><span class="number">1563769834131</span>,任务<span class="number">7</span>执行完毕，耗时:<span class="number">7001</span></span><br><span class="line"><span class="number">1563769835131</span>,任务<span class="number">8</span>执行完毕，耗时:<span class="number">8001</span></span><br><span class="line"><span class="number">1563769837131</span>,任务<span class="number">9</span>执行完毕，耗时:<span class="number">9001</span></span><br><span class="line"><span class="number">1563769839131</span>,任务<span class="number">10</span>执行完毕，耗时:<span class="number">10001</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]中的任务都处理完毕!</span><br></pre></td></tr></table></figure><p><strong>TaskDisposeUtils是一个并行处理的工具类，可以传入n个任务内部使用线程池进行处理，等待所有任务都处理完成之后，方法才会返回。比如我们发送短信，系统中有1万条短信，我们使用上面的工具，每次取100条并行发送，待100个都处理完毕之后，再取一批按照同样的逻辑发送。</strong></p><h3 id="2、CyclicBarrier循环栅栏"><a href="#2、CyclicBarrier循环栅栏" class="headerlink" title="2、CyclicBarrier循环栅栏"></a>2、CyclicBarrier循环栅栏</h3><p>CyclicBarrier通常称为循环屏障。它和CountDownLatch很相似，都可以使线程先等待然后再执行。不过CountDownLatch是使一批线程等待另一批线程执行完后再执行；而CyclicBarrier只是使等待的线程达到一定数目后再让它们继续执行。故而CyclicBarrier内部也有一个计数器,计数器的初始值在创建对象时通过构造参数指定,如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">CyclicBarrier</span><span class="params">(<span class="type">int</span> parties)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(parties, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每调用一次await()方法都将使阻塞的线程数+1，只有阻塞的线程数达到设定值时屏障才会打开，允许阻塞的所有线程继续执行。除此之外，CyclicBarrier还有几点需要注意的地方:</p><ul><li>CyclicBarrier的计数器可以重置而CountDownLatch不行，这意味着CyclicBarrier实例可以被重复使用而CountDownLatch只能被使用一次。而这也是循环屏障循环二字的语义所在。</li><li>CyclicBarrier允许用户自定义barrierAction操作，这是个可选操作，可以在创建CyclicBarrier对象时指定</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">CyclicBarrier</span><span class="params">(<span class="type">int</span> parties, Runnable barrierAction)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="built_in">this</span>.parties = parties;</span><br><span class="line">    <span class="built_in">this</span>.count = parties;</span><br><span class="line">    <span class="built_in">this</span>.barrierCommand = barrierAction;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦用户在创建CyclicBarrier对象时设置了barrierAction参数，则在阻塞线程数达到设定值屏障打开前，会调用barrierAction的run()方法完成用户自定义的操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xue.thread;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * CyclicBarrier</span></span><br><span class="line"><span class="comment"> * 的字面意思是可循环（Cyclic）使用的屏障（Barrier）。它要做的事情是，</span></span><br><span class="line"><span class="comment"> * 让一组线程到达一个屏障（也可以叫同步点）时被阻塞，</span></span><br><span class="line"><span class="comment"> * 直到最后一个线程到达屏障时，屏障才会开门，所有</span></span><br><span class="line"><span class="comment"> * 被屏障拦截的线程才会继续干活。</span></span><br><span class="line"><span class="comment"> * 线程进入屏障通过CyclicBarrier的await()方法。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 集齐7颗龙珠就可以召唤神龙</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrierDemo</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NUMBER</span> <span class="operator">=</span> <span class="number">7</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">  &#123;</span><br><span class="line">     <span class="comment">//CyclicBarrier(int parties, Runnable barrierAction) </span></span><br><span class="line">     </span><br><span class="line">     <span class="type">CyclicBarrier</span> <span class="variable">cyclicBarrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(NUMBER, ()-&gt;&#123;System.out.println(<span class="string">&quot;*****集齐7颗龙珠就可以召唤神龙&quot;</span>);&#125;) ;</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">7</span>; i++) &#123;</span><br><span class="line">       <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t 星龙珠被收集 &quot;</span>);</span><br><span class="line">            cyclicBarrier.await();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">       </span><br><span class="line">       &#125;, String.valueOf(i)).start();</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line"> </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>CyclicBarrier的字面意思是可循环（Cyclic）使用的屏障（Barrier）。它要做的事情是，</li><li>让一组线程到达一个屏障（也可以叫同步点）时被阻塞，</li><li>直到最后一个线程到达屏障时，屏障才会开门，所有</li><li>被屏障拦截的线程才会继续干活。</li><li>线程进入屏障通过CyclicBarrier的await()方法。</li></ul><h4 id="示例1-简单使用CyclicBarrier"><a href="#示例1-简单使用CyclicBarrier" class="headerlink" title="示例1 简单使用CyclicBarrier"></a>示例1 简单使用CyclicBarrier</h4><p>公司组织旅游，大家都有经历过，10个人，中午到饭点了，需要等到10个人都到了才能开饭，先到的人坐那等着，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">CyclicBarrier</span> <span class="variable">cyclicBarrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">T</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="type">int</span> sleep;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">T</span><span class="params">(String name, <span class="type">int</span> sleep)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(name);</span><br><span class="line">            <span class="built_in">this</span>.sleep = sleep;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//模拟休眠</span></span><br><span class="line">                TimeUnit.SECONDS.sleep(sleep);</span><br><span class="line">                <span class="type">long</span> <span class="variable">starTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">                <span class="comment">//调用await()的时候，当前线程将会被阻塞，需要等待其他员工都到达await了才能继续</span></span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">                <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">                System.out.println(<span class="built_in">this</span>.getName() + <span class="string">&quot;,sleep:&quot;</span> + <span class="built_in">this</span>.sleep + <span class="string">&quot; 等待了&quot;</span> + (endTime - starTime) + <span class="string">&quot;(ms),开始吃饭了！&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">T</span>(<span class="string">&quot;员工&quot;</span> + i, i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">员工<span class="number">1</span>,sleep:<span class="number">1</span> 等待了<span class="number">9000</span>(ms),开始吃饭了！</span><br><span class="line">员工<span class="number">9</span>,sleep:<span class="number">9</span> 等待了<span class="number">1000</span>(ms),开始吃饭了！</span><br><span class="line">员工<span class="number">8</span>,sleep:<span class="number">8</span> 等待了<span class="number">2001</span>(ms),开始吃饭了！</span><br><span class="line">员工<span class="number">7</span>,sleep:<span class="number">7</span> 等待了<span class="number">3001</span>(ms),开始吃饭了！</span><br><span class="line">员工<span class="number">6</span>,sleep:<span class="number">6</span> 等待了<span class="number">4001</span>(ms),开始吃饭了！</span><br><span class="line">员工<span class="number">4</span>,sleep:<span class="number">4</span> 等待了<span class="number">6000</span>(ms),开始吃饭了！</span><br><span class="line">员工<span class="number">5</span>,sleep:<span class="number">5</span> 等待了<span class="number">5000</span>(ms),开始吃饭了！</span><br><span class="line">员工<span class="number">10</span>,sleep:<span class="number">10</span> 等待了<span class="number">0</span>(ms),开始吃饭了！</span><br><span class="line">员工<span class="number">2</span>,sleep:<span class="number">2</span> 等待了<span class="number">7999</span>(ms),开始吃饭了！</span><br><span class="line">员工<span class="number">3</span>,sleep:<span class="number">3</span> 等待了<span class="number">7000</span>(ms),开始吃饭了！</span><br></pre></td></tr></table></figure><p>代码中模拟了10个员工上桌吃饭的场景，等待所有员工都到齐了才能开发，可以看到第10个员工最慢，前面的都在等待第10个员工，员工1等待了9秒，上面代码中调用<code>cyclicBarrier.await();</code>会让当前线程等待。当10个员工都调用了<code>cyclicBarrier.await();</code>之后，所有处于等待中的员工都会被唤醒，然后继续运行。</p><h4 id="示例2-循环使用CyclicBarrier"><a href="#示例2-循环使用CyclicBarrier" class="headerlink" title="示例2 循环使用CyclicBarrier"></a>示例2 循环使用CyclicBarrier</h4><p>对示例1进行改造一下，吃饭完毕之后，所有人都去车上，待所有人都到车上之后，驱车去下一景点玩。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">CyclicBarrier</span> <span class="variable">cyclicBarrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">T</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="type">int</span> sleep;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">T</span><span class="params">(String name, <span class="type">int</span> sleep)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(name);</span><br><span class="line">            <span class="built_in">this</span>.sleep = sleep;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//等待吃饭</span></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//模拟休眠</span></span><br><span class="line">                TimeUnit.SECONDS.sleep(sleep);</span><br><span class="line">                <span class="type">long</span> <span class="variable">starTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">                <span class="comment">//调用await()的时候，当前线程将会被阻塞，需要等待其他员工都到达await了才能继续</span></span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">                <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">                System.out.println(<span class="built_in">this</span>.getName() + <span class="string">&quot;,sleep:&quot;</span> + <span class="built_in">this</span>.sleep + <span class="string">&quot; 等待了&quot;</span> + (endTime - starTime) + <span class="string">&quot;(ms),开始吃饭了！&quot;</span>);</span><br><span class="line">                <span class="comment">//休眠sleep时间，模拟当前员工吃饭耗时</span></span><br><span class="line">                TimeUnit.SECONDS.sleep(sleep);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//等待所有人到齐之后，开车去下一站</span></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">drive</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">starTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">                <span class="comment">//调用await()的时候，当前线程将会被阻塞，需要等待其他员工都到达await了才能继续</span></span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">                <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">                System.out.println(<span class="built_in">this</span>.getName() + <span class="string">&quot;,sleep:&quot;</span> + <span class="built_in">this</span>.sleep + <span class="string">&quot; 等待了&quot;</span> + (endTime - starTime) + <span class="string">&quot;(ms),去下一景点的路上！&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">//等待所有人到齐之后吃饭，先到的人坐那等着，什么事情不要干</span></span><br><span class="line">            <span class="built_in">this</span>.eat();</span><br><span class="line">            <span class="comment">//等待所有人到齐之后开车去下一景点，先到的人坐那等着，什么事情不要干</span></span><br><span class="line">            <span class="built_in">this</span>.drive();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">T</span>(<span class="string">&quot;员工&quot;</span> + i, i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">员工<span class="number">10</span>,sleep:<span class="number">10</span> 等待了<span class="number">0</span>(ms),开始吃饭了！</span><br><span class="line">员工<span class="number">5</span>,sleep:<span class="number">5</span> 等待了<span class="number">5000</span>(ms),开始吃饭了！</span><br><span class="line">员工<span class="number">6</span>,sleep:<span class="number">6</span> 等待了<span class="number">4000</span>(ms),开始吃饭了！</span><br><span class="line">员工<span class="number">9</span>,sleep:<span class="number">9</span> 等待了<span class="number">1001</span>(ms),开始吃饭了！</span><br><span class="line">员工<span class="number">4</span>,sleep:<span class="number">4</span> 等待了<span class="number">6000</span>(ms),开始吃饭了！</span><br><span class="line">员工<span class="number">3</span>,sleep:<span class="number">3</span> 等待了<span class="number">7000</span>(ms),开始吃饭了！</span><br><span class="line">员工<span class="number">1</span>,sleep:<span class="number">1</span> 等待了<span class="number">9001</span>(ms),开始吃饭了！</span><br><span class="line">员工<span class="number">2</span>,sleep:<span class="number">2</span> 等待了<span class="number">8000</span>(ms),开始吃饭了！</span><br><span class="line">员工<span class="number">8</span>,sleep:<span class="number">8</span> 等待了<span class="number">2001</span>(ms),开始吃饭了！</span><br><span class="line">员工<span class="number">7</span>,sleep:<span class="number">7</span> 等待了<span class="number">3000</span>(ms),开始吃饭了！</span><br><span class="line">员工<span class="number">10</span>,sleep:<span class="number">10</span> 等待了<span class="number">0</span>(ms),去下一景点的路上！</span><br><span class="line">员工<span class="number">1</span>,sleep:<span class="number">1</span> 等待了<span class="number">8998</span>(ms),去下一景点的路上！</span><br><span class="line">员工<span class="number">5</span>,sleep:<span class="number">5</span> 等待了<span class="number">4999</span>(ms),去下一景点的路上！</span><br><span class="line">员工<span class="number">4</span>,sleep:<span class="number">4</span> 等待了<span class="number">5999</span>(ms),去下一景点的路上！</span><br><span class="line">员工<span class="number">3</span>,sleep:<span class="number">3</span> 等待了<span class="number">6998</span>(ms),去下一景点的路上！</span><br><span class="line">员工<span class="number">2</span>,sleep:<span class="number">2</span> 等待了<span class="number">7998</span>(ms),去下一景点的路上！</span><br><span class="line">员工<span class="number">9</span>,sleep:<span class="number">9</span> 等待了<span class="number">999</span>(ms),去下一景点的路上！</span><br><span class="line">员工<span class="number">8</span>,sleep:<span class="number">8</span> 等待了<span class="number">1999</span>(ms),去下一景点的路上！</span><br><span class="line">员工<span class="number">7</span>,sleep:<span class="number">7</span> 等待了<span class="number">2999</span>(ms),去下一景点的路上！</span><br><span class="line">员工<span class="number">6</span>,sleep:<span class="number">6</span> 等待了<span class="number">3999</span>(ms),去下一景点的路上！</span><br></pre></td></tr></table></figure><p>坑，又是员工10最慢，要提升效率了，不能吃的太多，得减肥。</p><p>代码中CyclicBarrier相当于使用了2次，第一次用于等待所有人到达后开饭，第二次用于等待所有人上车后驱车去下一景点。注意一些先到的员工会在其他人到达之前，都处于等待状态（<code>cyclicBarrier.await();</code>会让当前线程阻塞），无法干其他事情，等到最后一个人到了会唤醒所有人，然后继续。</p><blockquote><p>CyclicBarrier内部相当于有个计数器（构造方法传入的），每次调用<code>await();</code>后，计数器会减1，并且await()方法会让当前线程阻塞，等待计数器减为0的时候，所有在await()上等待的线程被唤醒，然后继续向下执行，此时计数器又会被还原为创建时的值，然后可以继续再次使用。</p></blockquote><h4 id="示例3-最后到的人给大家上酒，然后开饭"><a href="#示例3-最后到的人给大家上酒，然后开饭" class="headerlink" title="示例3 最后到的人给大家上酒，然后开饭"></a>示例3 最后到的人给大家上酒，然后开饭</h4><p>还是示例1中的例子，员工10是最后到达的，让所有人都久等了，那怎么办，得给所有人倒酒，然后开饭，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">CyclicBarrier</span> <span class="variable">cyclicBarrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">10</span>, () -&gt; &#123;</span><br><span class="line">        <span class="comment">//模拟倒酒，花了2秒，又得让其他9个人等2秒</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;说，不好意思，让大家久等了，给大家倒酒赔罪!&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">T</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="type">int</span> sleep;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">T</span><span class="params">(String name, <span class="type">int</span> sleep)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(name);</span><br><span class="line">            <span class="built_in">this</span>.sleep = sleep;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//模拟休眠</span></span><br><span class="line">                TimeUnit.SECONDS.sleep(sleep);</span><br><span class="line">                <span class="type">long</span> <span class="variable">starTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">                <span class="comment">//调用await()的时候，当前线程将会被阻塞，需要等待其他员工都到达await了才能继续</span></span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">                <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">                System.out.println(<span class="built_in">this</span>.getName() + <span class="string">&quot;,sleep:&quot;</span> + <span class="built_in">this</span>.sleep + <span class="string">&quot; 等待了&quot;</span> + (endTime - starTime) + <span class="string">&quot;(ms),开始吃饭了！&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">T</span>(<span class="string">&quot;员工&quot;</span> + i, i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">员工<span class="number">10</span>说，不好意思，让大家久等了，给大家倒酒赔罪!</span><br><span class="line">员工<span class="number">10</span>,sleep:<span class="number">10</span> 等待了<span class="number">2000</span>(ms),开始吃饭了！</span><br><span class="line">员工<span class="number">1</span>,sleep:<span class="number">1</span> 等待了<span class="number">11000</span>(ms),开始吃饭了！</span><br><span class="line">员工<span class="number">2</span>,sleep:<span class="number">2</span> 等待了<span class="number">10000</span>(ms),开始吃饭了！</span><br><span class="line">员工<span class="number">5</span>,sleep:<span class="number">5</span> 等待了<span class="number">7000</span>(ms),开始吃饭了！</span><br><span class="line">员工<span class="number">7</span>,sleep:<span class="number">7</span> 等待了<span class="number">5000</span>(ms),开始吃饭了！</span><br><span class="line">员工<span class="number">9</span>,sleep:<span class="number">9</span> 等待了<span class="number">3000</span>(ms),开始吃饭了！</span><br><span class="line">员工<span class="number">4</span>,sleep:<span class="number">4</span> 等待了<span class="number">8000</span>(ms),开始吃饭了！</span><br><span class="line">员工<span class="number">3</span>,sleep:<span class="number">3</span> 等待了<span class="number">9001</span>(ms),开始吃饭了！</span><br><span class="line">员工<span class="number">8</span>,sleep:<span class="number">8</span> 等待了<span class="number">4001</span>(ms),开始吃饭了！</span><br><span class="line">员工<span class="number">6</span>,sleep:<span class="number">6</span> 等待了<span class="number">6001</span>(ms),开始吃饭了！</span><br></pre></td></tr></table></figure><p>代码中创建<code>CyclicBarrier</code>对象时，多传入了一个参数（内部是倒酒操作），先到的人先等待，待所有人都到齐之后，需要先给大家倒酒，然后唤醒所有等待中的人让大家开饭。从输出结果中我们发现，倒酒操作是由最后一个人操作的，最后一个人倒酒完毕之后，才唤醒所有等待中的其他员工，让大家开饭。</p><h4 id="示例4-其中一个人等待中被打断了"><a href="#示例4-其中一个人等待中被打断了" class="headerlink" title="示例4 其中一个人等待中被打断了"></a>示例4 其中一个人等待中被打断了</h4><p>员工5等待中，突然接了个电话，有点急事，然后就拿起筷子开吃了，其他人会怎么样呢？看着他吃么？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.Time;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">CyclicBarrier</span> <span class="variable">cyclicBarrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">T</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="type">int</span> sleep;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">T</span><span class="params">(String name, <span class="type">int</span> sleep)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(name);</span><br><span class="line">            <span class="built_in">this</span>.sleep = sleep;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">starTime</span> <span class="operator">=</span> <span class="number">0</span>, endTime = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//模拟休眠</span></span><br><span class="line">                TimeUnit.SECONDS.sleep(sleep);</span><br><span class="line">                starTime = System.currentTimeMillis();</span><br><span class="line">                <span class="comment">//调用await()的时候，当前线程将会被阻塞，需要等待其他员工都到达await了才能继续</span></span><br><span class="line">                System.out.println(<span class="built_in">this</span>.getName() + <span class="string">&quot;到了！&quot;</span>);</span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            endTime = System.currentTimeMillis();</span><br><span class="line">            System.out.println(<span class="built_in">this</span>.getName() + <span class="string">&quot;,sleep:&quot;</span> + <span class="built_in">this</span>.sleep + <span class="string">&quot; 等待了&quot;</span> + (endTime - starTime) + <span class="string">&quot;(ms),开始吃饭了！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sleep</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">10</span>) &#123;</span><br><span class="line">                sleep = <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>(<span class="string">&quot;员工&quot;</span> + i, sleep);</span><br><span class="line">            t.start();</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">5</span>) &#123;</span><br><span class="line">                <span class="comment">//模拟员工5接了个电话，将自己等待吃饭给打断了</span></span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                System.out.println(t.getName() + <span class="string">&quot;,有点急事，我先开干了！&quot;</span>);</span><br><span class="line">                t.interrupt();</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">员工<span class="number">4</span>到了！</span><br><span class="line">员工<span class="number">3</span>到了！</span><br><span class="line">员工<span class="number">5</span>到了！</span><br><span class="line">员工<span class="number">1</span>到了！</span><br><span class="line">员工<span class="number">2</span>到了！</span><br><span class="line">员工<span class="number">5</span>,有点急事，我先开干了！</span><br><span class="line">java.util.concurrent.BrokenBarrierException</span><br><span class="line">员工<span class="number">1</span>,sleep:<span class="number">0</span> 等待了<span class="number">1001</span>(ms),开始吃饭了！</span><br><span class="line">    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:<span class="number">250</span>)</span><br><span class="line">员工<span class="number">3</span>,sleep:<span class="number">0</span> 等待了<span class="number">1001</span>(ms),开始吃饭了！</span><br><span class="line">    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:<span class="number">362</span>)</span><br><span class="line">员工<span class="number">4</span>,sleep:<span class="number">0</span> 等待了<span class="number">1001</span>(ms),开始吃饭了！</span><br><span class="line">    at com.itsoku.chat15.Demo4$T.run(Demo4.java:<span class="number">31</span>)</span><br><span class="line">员工<span class="number">2</span>,sleep:<span class="number">0</span> 等待了<span class="number">1001</span>(ms),开始吃饭了！</span><br><span class="line">员工<span class="number">5</span>,sleep:<span class="number">0</span> 等待了<span class="number">1002</span>(ms),开始吃饭了！</span><br><span class="line">java.util.concurrent.BrokenBarrierException</span><br><span class="line">    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:<span class="number">250</span>)</span><br><span class="line">    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:<span class="number">362</span>)</span><br><span class="line">    at com.itsoku.chat15.Demo4$T.run(Demo4.java:<span class="number">31</span>)</span><br><span class="line">java.util.concurrent.BrokenBarrierException</span><br><span class="line">    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:<span class="number">250</span>)</span><br><span class="line">    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:<span class="number">362</span>)</span><br><span class="line">    at com.itsoku.chat15.Demo4$T.run(Demo4.java:<span class="number">31</span>)</span><br><span class="line">java.util.concurrent.BrokenBarrierException</span><br><span class="line">    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:<span class="number">250</span>)</span><br><span class="line">    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:<span class="number">362</span>)</span><br><span class="line">    at com.itsoku.chat15.Demo4$T.run(Demo4.java:<span class="number">31</span>)</span><br><span class="line">java.lang.InterruptedException</span><br><span class="line">    at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.reportInterruptAfterWait(AbstractQueuedSynchronizer.java:<span class="number">2014</span>)</span><br><span class="line">    at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:<span class="number">2048</span>)</span><br><span class="line">    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:<span class="number">234</span>)</span><br><span class="line">    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:<span class="number">362</span>)</span><br><span class="line">    at com.itsoku.chat15.Demo4$T.run(Demo4.java:<span class="number">31</span>)</span><br><span class="line">java.util.concurrent.BrokenBarrierException</span><br><span class="line">    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:<span class="number">207</span>)</span><br><span class="line">    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:<span class="number">362</span>)</span><br><span class="line">    at com.itsoku.chat15.Demo4$T.run(Demo4.java:<span class="number">31</span>)</span><br><span class="line">java.util.concurrent.BrokenBarrierException</span><br><span class="line">员工<span class="number">6</span>到了！</span><br><span class="line">    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:<span class="number">207</span>)</span><br><span class="line">    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:<span class="number">362</span>)</span><br><span class="line">员工<span class="number">9</span>到了！</span><br><span class="line">    at com.itsoku.chat15.Demo4$T.run(Demo4.java:<span class="number">31</span>)</span><br><span class="line">员工<span class="number">8</span>到了！</span><br><span class="line">员工<span class="number">7</span>到了！</span><br><span class="line">员工<span class="number">6</span>,sleep:<span class="number">0</span> 等待了<span class="number">0</span>(ms),开始吃饭了！</span><br><span class="line">员工<span class="number">7</span>,sleep:<span class="number">0</span> 等待了<span class="number">1</span>(ms),开始吃饭了！</span><br><span class="line">java.util.concurrent.BrokenBarrierException</span><br><span class="line">    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:<span class="number">207</span>)</span><br><span class="line">    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:<span class="number">362</span>)</span><br><span class="line">    at com.itsoku.chat15.Demo4$T.run(Demo4.java:<span class="number">31</span>)</span><br><span class="line">java.util.concurrent.BrokenBarrierException</span><br><span class="line">    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:<span class="number">207</span>)</span><br><span class="line">    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:<span class="number">362</span>)</span><br><span class="line">    at com.itsoku.chat15.Demo4$T.run(Demo4.java:<span class="number">31</span>)</span><br><span class="line">员工<span class="number">8</span>,sleep:<span class="number">0</span> 等待了<span class="number">1</span>(ms),开始吃饭了！</span><br><span class="line">员工<span class="number">9</span>,sleep:<span class="number">0</span> 等待了<span class="number">1</span>(ms),开始吃饭了！</span><br><span class="line">Disconnected from the target VM, address: <span class="string">&#x27;127.0.0.1:64413&#x27;</span>, transport: <span class="string">&#x27;socket&#x27;</span></span><br><span class="line">java.util.concurrent.BrokenBarrierException</span><br><span class="line">    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:<span class="number">207</span>)</span><br><span class="line">    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:<span class="number">362</span>)</span><br><span class="line">    at com.itsoku.chat15.Demo4$T.run(Demo4.java:<span class="number">31</span>)</span><br><span class="line">员工<span class="number">10</span>到了！</span><br><span class="line">员工<span class="number">10</span>,sleep:<span class="number">10</span> 等待了<span class="number">0</span>(ms),开始吃饭了！</span><br></pre></td></tr></table></figure><p>输出的信息看着有点乱，给大家理一理，员工5遇到急事，拿起筷子就是吃，这样好么，当然不好，他这么做了，后面看他这么做了都跟着这么做（这种场景是不是很熟悉，有一个人拿起筷子先吃起来，其他人都跟着上了），直接不等其他人了，拿起筷子就开吃了。CyclicBarrier遇到这种情况就是这么处理的。前面4个员工都在<code>await()</code>处等待着，员工5也在<code>await()</code>上等待着，等了1秒（<code>TimeUnit.SECONDS.sleep(1);</code>），接了个电话，然后给员工5发送中断信号后（<code>t.interrupt();</code>），员工5的await()方法会触发<code>InterruptedException</code>异常，此时其他等待中的前4个员工，看着5开吃了，自己立即也不等了，内部从<code>await()</code>方法中触发<code>BrokenBarrierException</code>异常，然后也开吃了，后面的6&#x2F;7&#x2F;8&#x2F;9&#x2F;10员工来了以后发现大家都开吃了，自己也不等了，6-10员工调用<code>await()</code>直接抛出了<code>BrokenBarrierException</code>异常，然后继续向下。</p><p><strong>结论：</strong></p><ol><li><strong>内部有一个人把规则破坏了（接收到中断信号），其他人都不按规则来了，不会等待了</strong></li><li><strong>接收到中断信号的线程，await方法会触发InterruptedException异常，然后被唤醒向下运行</strong></li><li><strong>其他等待中 或者后面到达的线程，会在await()方法上触发<code>BrokenBarrierException</code>异常，然后继续执行</strong></li></ol><h4 id="示例5-其中一个人只愿意等的5秒"><a href="#示例5-其中一个人只愿意等的5秒" class="headerlink" title="示例5 其中一个人只愿意等的5秒"></a>示例5 其中一个人只愿意等的5秒</h4><p>基于示例1，员工1只愿意等的5秒，5s后如果大家还没到期，自己要开吃了，员工1开吃了，其他人会怎么样呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo5</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">CyclicBarrier</span> <span class="variable">cyclicBarrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">T</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="type">int</span> sleep;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">T</span><span class="params">(String name, <span class="type">int</span> sleep)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(name);</span><br><span class="line">            <span class="built_in">this</span>.sleep = sleep;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">starTime</span> <span class="operator">=</span> <span class="number">0</span>, endTime = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//模拟休眠</span></span><br><span class="line">                TimeUnit.SECONDS.sleep(sleep);</span><br><span class="line">                starTime = System.currentTimeMillis();</span><br><span class="line">                <span class="comment">//调用await()的时候，当前线程将会被阻塞，需要等待其他员工都到达await了才能继续</span></span><br><span class="line">                System.out.println(<span class="built_in">this</span>.getName() + <span class="string">&quot;到了！&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>.getName().equals(<span class="string">&quot;员工1&quot;</span>)) &#123;</span><br><span class="line">                    cyclicBarrier.await(<span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            endTime = System.currentTimeMillis();</span><br><span class="line">            System.out.println(<span class="built_in">this</span>.getName() + <span class="string">&quot;,sleep:&quot;</span> + <span class="built_in">this</span>.sleep + <span class="string">&quot; 等待了&quot;</span> + (endTime - starTime) + <span class="string">&quot;(ms),开始吃饭了！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>(<span class="string">&quot;员工&quot;</span> + i, i);</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">员工<span class="number">1</span>到了！</span><br><span class="line">员工<span class="number">2</span>到了！</span><br><span class="line">员工<span class="number">3</span>到了！</span><br><span class="line">员工<span class="number">4</span>到了！</span><br><span class="line">员工<span class="number">5</span>到了！</span><br><span class="line">员工<span class="number">6</span>到了！</span><br><span class="line">员工<span class="number">1</span>,sleep:<span class="number">1</span> 等待了<span class="number">5001</span>(ms),开始吃饭了！</span><br><span class="line">员工<span class="number">5</span>,sleep:<span class="number">5</span> 等待了<span class="number">1001</span>(ms),开始吃饭了！</span><br><span class="line">java.util.concurrent.TimeoutException</span><br><span class="line">    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:<span class="number">257</span>)</span><br><span class="line">    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:<span class="number">435</span>)</span><br><span class="line">    at com.itsoku.chat15.Demo5$T.run(Demo5.java:<span class="number">32</span>)</span><br><span class="line">java.util.concurrent.BrokenBarrierException</span><br><span class="line">    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:<span class="number">250</span>)</span><br><span class="line">    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:<span class="number">362</span>)</span><br><span class="line">    at com.itsoku.chat15.Demo5$T.run(Demo5.java:<span class="number">34</span>)</span><br><span class="line">java.util.concurrent.BrokenBarrierException</span><br><span class="line">    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:<span class="number">207</span>)</span><br><span class="line">    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:<span class="number">362</span>)</span><br><span class="line">    at com.itsoku.chat15.Demo5$T.run(Demo5.java:<span class="number">34</span>)</span><br><span class="line">员工<span class="number">6</span>,sleep:<span class="number">6</span> 等待了<span class="number">2</span>(ms),开始吃饭了！</span><br><span class="line">java.util.concurrent.BrokenBarrierException</span><br><span class="line">员工<span class="number">2</span>,sleep:<span class="number">2</span> 等待了<span class="number">4002</span>(ms),开始吃饭了！</span><br><span class="line">    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:<span class="number">250</span>)</span><br><span class="line">员工<span class="number">3</span>,sleep:<span class="number">3</span> 等待了<span class="number">3001</span>(ms),开始吃饭了！</span><br><span class="line">    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:<span class="number">362</span>)</span><br><span class="line">员工<span class="number">4</span>,sleep:<span class="number">4</span> 等待了<span class="number">2001</span>(ms),开始吃饭了！</span><br><span class="line">    at com.itsoku.chat15.Demo5$T.run(Demo5.java:<span class="number">34</span>)</span><br><span class="line">java.util.concurrent.BrokenBarrierException</span><br><span class="line">    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:<span class="number">250</span>)</span><br><span class="line">    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:<span class="number">362</span>)</span><br><span class="line">    at com.itsoku.chat15.Demo5$T.run(Demo5.java:<span class="number">34</span>)</span><br><span class="line">java.util.concurrent.BrokenBarrierException</span><br><span class="line">    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:<span class="number">250</span>)</span><br><span class="line">    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:<span class="number">362</span>)</span><br><span class="line">    at com.itsoku.chat15.Demo5$T.run(Demo5.java:<span class="number">34</span>)</span><br><span class="line">java.util.concurrent.BrokenBarrierException</span><br><span class="line">员工<span class="number">7</span>到了！</span><br><span class="line">    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:<span class="number">207</span>)</span><br><span class="line">员工<span class="number">7</span>,sleep:<span class="number">7</span> 等待了<span class="number">0</span>(ms),开始吃饭了！</span><br><span class="line">    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:<span class="number">362</span>)</span><br><span class="line">    at com.itsoku.chat15.Demo5$T.run(Demo5.java:<span class="number">34</span>)</span><br><span class="line">员工<span class="number">8</span>到了！</span><br><span class="line">员工<span class="number">8</span>,sleep:<span class="number">8</span> 等待了<span class="number">0</span>(ms),开始吃饭了！</span><br><span class="line">java.util.concurrent.BrokenBarrierException</span><br><span class="line">    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:<span class="number">207</span>)</span><br><span class="line">    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:<span class="number">362</span>)</span><br><span class="line">    at com.itsoku.chat15.Demo5$T.run(Demo5.java:<span class="number">34</span>)</span><br><span class="line">员工<span class="number">9</span>到了！</span><br><span class="line">java.util.concurrent.BrokenBarrierException</span><br><span class="line">员工<span class="number">9</span>,sleep:<span class="number">9</span> 等待了<span class="number">0</span>(ms),开始吃饭了！</span><br><span class="line">    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:<span class="number">207</span>)</span><br><span class="line">    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:<span class="number">362</span>)</span><br><span class="line">    at com.itsoku.chat15.Demo5$T.run(Demo5.java:<span class="number">34</span>)</span><br><span class="line">java.util.concurrent.BrokenBarrierException</span><br><span class="line">员工<span class="number">10</span>到了！</span><br><span class="line">    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:<span class="number">207</span>)</span><br><span class="line">    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:<span class="number">362</span>)</span><br><span class="line">员工<span class="number">10</span>,sleep:<span class="number">10</span> 等待了<span class="number">0</span>(ms),开始吃饭了！</span><br><span class="line">    at com.itsoku.chat15.Demo5$T.run(Demo5.java:<span class="number">34</span>)</span><br></pre></td></tr></table></figure><p>从输出结果中我们可以看到：1等待5秒之后，开吃了，其他等待人都开吃了，后面来的人不等待，直接开吃了。</p><p>员工1调用有参<code>await</code>方法等待5秒之后，触发了<code>TimeoutException</code>异常，然后继续向下运行，其他的在5开吃之前已经等了一会的的几个员工，他们看到5开吃了，自己立即不等待了，也也开吃了（他们的<code>await</code>抛出了<code>BrokenBarrierException</code>异常）；还有几个员工在5开吃之后到达的，他们直接不等待了，直接抛出<code>BrokenBarrierException</code>异常，然后也开吃了。</p><p><strong>结论：</strong></p><ol><li><p><strong>等待超时的方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">await</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException,BrokenBarrierException,TimeoutException</span><br></pre></td></tr></table></figure></li><li><p><strong>内部有一个人把规则破坏了（等待超时），其他人都不按规则来了，不会等待了</strong></p></li><li><p><strong>等待超时的线程，await方法会触发TimeoutException异常，然后被唤醒向下运行</strong></p></li><li><p><strong>其他等待中 或者后面到达的线程，会在await()方法上触发<code>BrokenBarrierException</code>异常，然后继续执行</strong></p></li></ol><h4 id="示例6-重建规则"><a href="#示例6-重建规则" class="headerlink" title="示例6 重建规则"></a>示例6 重建规则</h4><p>示例5中改造一下，员工1等待5秒超时之后，开吃了，打破了规则，先前等待中的以及后面到达的都不按规则来了，都拿起筷子开吃。过了一会，导游重新告知大家，要按规则来，然后重建了规则，大家都按规则来了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo6</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">CyclicBarrier</span> <span class="variable">cyclicBarrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">//规则是否已重建</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">guizhe</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">T</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="type">int</span> sleep;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">T</span><span class="params">(String name, <span class="type">int</span> sleep)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(name);</span><br><span class="line">            <span class="built_in">this</span>.sleep = sleep;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">starTime</span> <span class="operator">=</span> <span class="number">0</span>, endTime = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//模拟休眠</span></span><br><span class="line">                TimeUnit.SECONDS.sleep(sleep);</span><br><span class="line">                starTime = System.currentTimeMillis();</span><br><span class="line">                <span class="comment">//调用await()的时候，当前线程将会被阻塞，需要等待其他员工都到达await了才能继续</span></span><br><span class="line">                System.out.println(<span class="built_in">this</span>.getName() + <span class="string">&quot;到了！&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (!guizhe) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">this</span>.getName().equals(<span class="string">&quot;员工1&quot;</span>)) &#123;</span><br><span class="line">                        cyclicBarrier.await(<span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        cyclicBarrier.await();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            endTime = System.currentTimeMillis();</span><br><span class="line">            System.out.println(<span class="built_in">this</span>.getName() + <span class="string">&quot;,sleep:&quot;</span> + <span class="built_in">this</span>.sleep + <span class="string">&quot; 等待了&quot;</span> + (endTime - starTime) + <span class="string">&quot;(ms),开始吃饭了！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>(<span class="string">&quot;员工&quot;</span> + i, i);</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//等待10秒之后，重置，重建规则</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">15</span>);</span><br><span class="line">        cyclicBarrier.reset();</span><br><span class="line">        guizhe = <span class="literal">true</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;---------------大家太皮了，请大家按规则来------------------&quot;</span>);</span><br><span class="line">        <span class="comment">//再来一次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>(<span class="string">&quot;员工&quot;</span> + i, i);</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">员工<span class="number">1</span>到了！</span><br><span class="line">员工<span class="number">2</span>到了！</span><br><span class="line">员工<span class="number">3</span>到了！</span><br><span class="line">员工<span class="number">4</span>到了！</span><br><span class="line">员工<span class="number">5</span>到了！</span><br><span class="line">java.util.concurrent.TimeoutException</span><br><span class="line">    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:<span class="number">257</span>)</span><br><span class="line">    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:<span class="number">435</span>)</span><br><span class="line">    at com.itsoku.chat15.Demo6$T.run(Demo6.java:<span class="number">36</span>)</span><br><span class="line">java.util.concurrent.BrokenBarrierException</span><br><span class="line">    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:<span class="number">250</span>)</span><br><span class="line">    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:<span class="number">362</span>)</span><br><span class="line">    at com.itsoku.chat15.Demo6$T.run(Demo6.java:<span class="number">38</span>)</span><br><span class="line">java.util.concurrent.BrokenBarrierException</span><br><span class="line">    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:<span class="number">250</span>)</span><br><span class="line">    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:<span class="number">362</span>)</span><br><span class="line">    at com.itsoku.chat15.Demo6$T.run(Demo6.java:<span class="number">38</span>)</span><br><span class="line">java.util.concurrent.BrokenBarrierException</span><br><span class="line">    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:<span class="number">250</span>)</span><br><span class="line">    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:<span class="number">362</span>)</span><br><span class="line">    at com.itsoku.chat15.Demo6$T.run(Demo6.java:<span class="number">38</span>)</span><br><span class="line">java.util.concurrent.BrokenBarrierException</span><br><span class="line">    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:<span class="number">250</span>)</span><br><span class="line">    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:<span class="number">362</span>)</span><br><span class="line">    at com.itsoku.chat15.Demo6$T.run(Demo6.java:<span class="number">38</span>)</span><br><span class="line">java.util.concurrent.BrokenBarrierException</span><br><span class="line">    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:<span class="number">250</span>)</span><br><span class="line">    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:<span class="number">362</span>)</span><br><span class="line">    at com.itsoku.chat15.Demo6$T.run(Demo6.java:<span class="number">38</span>)</span><br><span class="line">员工<span class="number">6</span>到了！</span><br><span class="line">员工<span class="number">1</span>,sleep:<span class="number">1</span> 等待了<span class="number">5002</span>(ms),开始吃饭了！</span><br><span class="line">员工<span class="number">6</span>,sleep:<span class="number">6</span> 等待了<span class="number">4</span>(ms),开始吃饭了！</span><br><span class="line">员工<span class="number">4</span>,sleep:<span class="number">4</span> 等待了<span class="number">2004</span>(ms),开始吃饭了！</span><br><span class="line">员工<span class="number">5</span>,sleep:<span class="number">5</span> 等待了<span class="number">1004</span>(ms),开始吃饭了！</span><br><span class="line">员工<span class="number">3</span>,sleep:<span class="number">3</span> 等待了<span class="number">3002</span>(ms),开始吃饭了！</span><br><span class="line">员工<span class="number">2</span>,sleep:<span class="number">2</span> 等待了<span class="number">4004</span>(ms),开始吃饭了！</span><br><span class="line">员工<span class="number">7</span>到了！</span><br><span class="line">员工<span class="number">7</span>,sleep:<span class="number">7</span> 等待了<span class="number">0</span>(ms),开始吃饭了！</span><br><span class="line">java.util.concurrent.BrokenBarrierException</span><br><span class="line">    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:<span class="number">207</span>)</span><br><span class="line">    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:<span class="number">362</span>)</span><br><span class="line">    at com.itsoku.chat15.Demo6$T.run(Demo6.java:<span class="number">38</span>)</span><br><span class="line">java.util.concurrent.BrokenBarrierException</span><br><span class="line">    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:<span class="number">207</span>)</span><br><span class="line">    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:<span class="number">362</span>)</span><br><span class="line">    at com.itsoku.chat15.Demo6$T.run(Demo6.java:<span class="number">38</span>)</span><br><span class="line">员工<span class="number">8</span>到了！</span><br><span class="line">员工<span class="number">8</span>,sleep:<span class="number">8</span> 等待了<span class="number">0</span>(ms),开始吃饭了！</span><br><span class="line">java.util.concurrent.BrokenBarrierException</span><br><span class="line">员工<span class="number">9</span>到了！</span><br><span class="line">    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:<span class="number">207</span>)</span><br><span class="line">员工<span class="number">9</span>,sleep:<span class="number">9</span> 等待了<span class="number">0</span>(ms),开始吃饭了！</span><br><span class="line">    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:<span class="number">362</span>)</span><br><span class="line">    at com.itsoku.chat15.Demo6$T.run(Demo6.java:<span class="number">38</span>)</span><br><span class="line">java.util.concurrent.BrokenBarrierException</span><br><span class="line">员工<span class="number">10</span>到了！</span><br><span class="line">    at java.util.concurrent.CyclicBarrier.dowait(CyclicBarrier.java:<span class="number">207</span>)</span><br><span class="line">员工<span class="number">10</span>,sleep:<span class="number">10</span> 等待了<span class="number">0</span>(ms),开始吃饭了！</span><br><span class="line">    at java.util.concurrent.CyclicBarrier.await(CyclicBarrier.java:<span class="number">362</span>)</span><br><span class="line">    at com.itsoku.chat15.Demo6$T.run(Demo6.java:<span class="number">38</span>)</span><br><span class="line">---------------大家太皮了，请大家按规则来------------------</span><br><span class="line">员工<span class="number">1</span>到了！</span><br><span class="line">员工<span class="number">2</span>到了！</span><br><span class="line">员工<span class="number">3</span>到了！</span><br><span class="line">员工<span class="number">4</span>到了！</span><br><span class="line">员工<span class="number">5</span>到了！</span><br><span class="line">员工<span class="number">6</span>到了！</span><br><span class="line">员工<span class="number">7</span>到了！</span><br><span class="line">员工<span class="number">8</span>到了！</span><br><span class="line">员工<span class="number">9</span>到了！</span><br><span class="line">员工<span class="number">10</span>到了！</span><br><span class="line">员工<span class="number">10</span>,sleep:<span class="number">10</span> 等待了<span class="number">0</span>(ms),开始吃饭了！</span><br><span class="line">员工<span class="number">1</span>,sleep:<span class="number">1</span> 等待了<span class="number">9000</span>(ms),开始吃饭了！</span><br><span class="line">员工<span class="number">2</span>,sleep:<span class="number">2</span> 等待了<span class="number">8000</span>(ms),开始吃饭了！</span><br><span class="line">员工<span class="number">3</span>,sleep:<span class="number">3</span> 等待了<span class="number">6999</span>(ms),开始吃饭了！</span><br><span class="line">员工<span class="number">7</span>,sleep:<span class="number">7</span> 等待了<span class="number">3000</span>(ms),开始吃饭了！</span><br><span class="line">员工<span class="number">6</span>,sleep:<span class="number">6</span> 等待了<span class="number">4000</span>(ms),开始吃饭了！</span><br><span class="line">员工<span class="number">5</span>,sleep:<span class="number">5</span> 等待了<span class="number">5000</span>(ms),开始吃饭了！</span><br><span class="line">员工<span class="number">4</span>,sleep:<span class="number">4</span> 等待了<span class="number">6000</span>(ms),开始吃饭了！</span><br><span class="line">员工<span class="number">9</span>,sleep:<span class="number">9</span> 等待了<span class="number">999</span>(ms),开始吃饭了！</span><br><span class="line">员工<span class="number">8</span>,sleep:<span class="number">8</span> 等待了<span class="number">1999</span>(ms),开始吃饭了！</span><br></pre></td></tr></table></figure><p>第一次规则被打乱了，过了一会导游重建了规则（<code>cyclicBarrier.reset();</code>），接着又重来来了一次模拟等待吃饭的操作，正常了。</p><h4 id="CountDownLatch和CyclicBarrier的区别"><a href="#CountDownLatch和CyclicBarrier的区别" class="headerlink" title="CountDownLatch和CyclicBarrier的区别"></a>CountDownLatch和CyclicBarrier的区别</h4><p>还是举例子说明一下：</p><p><strong>CountDownLatch示例</strong></p><p>主管相当于 <strong>CountDownLatch</strong>，干活的小弟相当于做事情的线程。</p><p>老板交给主管了一个任务，让主管搞完之后立即上报给老板。主管下面有10个小弟，接到任务之后将任务划分为10个小任务分给每个小弟去干，主管一直处于等待状态（主管会调用<code>await()</code>方法，此方法会阻塞当前线程），让每个小弟干完之后通知一下主管（调用<code>countDown()</code>方法通知主管，此方法会立即返回），主管等到所有的小弟都做完了，会被唤醒，从await()方法上苏醒，然后将结果反馈给老板。期间主管会等待，会等待所有小弟将结果汇报给自己。</p><p><strong>而CyclicBarrier是一批线程让自己等待，等待所有的线程都准备好了，自己才能继续。</strong></p><h3 id="3、Semaphore信号灯"><a href="#3、Semaphore信号灯" class="headerlink" title="3、Semaphore信号灯"></a>3、Semaphore信号灯</h3><p>Semaphore（信号量）为多线程协作提供了更为强大的控制方法，前面的文章中我们学了synchronized和重入锁ReentrantLock，这2种锁一次都只能允许一个线程访问一个资源，而信号量可以控制有多少个线程可以<strong>同时访问</strong>特定的资源。</p><p><strong>Semaphore常用场景：限流</strong></p><p>举个例子：</p><p>比如有个停车场，有5个空位，门口有个门卫，手中5把钥匙分别对应5个车位上面的锁，来一辆车，门卫会给司机一把钥匙，然后进去找到对应的车位停下来，出去的时候司机将钥匙归还给门卫。停车场生意比较好，同时来了100两车，门卫手中只有5把钥匙，同时只能放5辆车进入，其他车只能等待，等有人将钥匙归还给门卫之后，才能让其他车辆进入。</p><p>上面的例子中门卫就相当于Semaphore，车钥匙就相当于许可证，车就相当于线程。</p><h4 id="1、Semaphore主要方法"><a href="#1、Semaphore主要方法" class="headerlink" title="1、Semaphore主要方法"></a>1、Semaphore主要方法</h4><ul><li>**Semaphore(int permits)**：构造方法，参数表示许可证数量，用来创建信号量</li><li>**Semaphore(int permits,boolean fair)**：构造方法，当fair等于true时，创建具有给定许可数的计数信号量并设置为公平信号量</li><li><strong>void acquire() throws InterruptedException</strong>：从此信号量获取1个许可前线程将一直阻塞，相当于一辆车占了一个车位，此方法会响应线程中断，表示调用线程的interrupt方法，会使该方法抛出InterruptedException异常</li><li><strong>void acquire(int permits) throws InterruptedException</strong> ：和acquire()方法类似，参数表示需要获取许可的数量；比如一个大卡车要入停车场，由于车比较大，需要申请3个车位才可以停放</li><li><strong>void acquireUninterruptibly(int permits)</strong> ：和acquire(int permits) 方法类似，只是不会响应线程中断</li><li>**boolean tryAcquire()**：尝试获取1个许可，不管是否能够获取成功，都立即返回，true表示获取成功，false表示获取失败</li><li>**boolean tryAcquire(int permits)**：和tryAcquire()，表示尝试获取permits个许可</li><li><strong>boolean tryAcquire(long timeout, TimeUnit unit) throws InterruptedException</strong>：尝试在指定的时间内获取1个许可，获取成功返回true，指定的时间过后还是无法获取许可，返回false</li><li><strong>boolean tryAcquire(int permits, long timeout, TimeUnit unit) throws InterruptedException</strong>：和tryAcquire(long timeout, TimeUnit unit)类似，多了一个permits参数，表示尝试获取permits个许可</li><li>**void release()**：释放一个许可，将其返回给信号量，相当于车从停车场出去时将钥匙归还给门卫</li><li>**void release(int n)**：释放n个许可</li><li>**int availablePermits()**：当前可用的许可数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xue.thread;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: TODO(这里用一句话描述这个类的作用)  </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 在信号量上我们定义两种操作：</span></span><br><span class="line"><span class="comment"> * acquire（获取） 当一个线程调用acquire操作时，它要么通过成功获取信号量（信号量减1），</span></span><br><span class="line"><span class="comment"> *             要么一直等下去，直到有线程释放信号量，或超时。</span></span><br><span class="line"><span class="comment"> * release（释放）实际上会将信号量的值加1，然后唤醒等待的线程。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 信号量主要用于两个目的，一个是用于多个共享资源的互斥使用，另一个用于并发线程数的控制。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SemaphoreDemo</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">  &#123;</span><br><span class="line">     <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>);<span class="comment">//模拟3个停车位</span></span><br><span class="line">     </span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">6</span>; i++) <span class="comment">//模拟6部汽车</span></span><br><span class="line">     &#123;</span><br><span class="line">       <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">          <span class="keyword">try</span> </span><br><span class="line">          &#123;</span><br><span class="line">            semaphore.acquire();</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t 抢到了车位&quot;</span>);</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">5</span>));</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t------- 离开&quot;</span>);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">          &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            semaphore.release();</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;, String.valueOf(i)).start();</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在信号量上我们定义两种操作：</p><ul><li>acquire（获取） 当一个线程调用acquire操作时，它要么通过成功获取信号量（信号量减1），要么一直等下去，直到有线程释放信号量，或超时。</li><li>release（释放）实际上会将信号量的值加1，然后唤醒等待的线程。</li><li>信号量主要用于两个目的，一个是用于多个共享资源的互斥使用，另一个用于并发线程数的控制。</li></ul><h4 id="2、Semaphore简单的使用"><a href="#2、Semaphore简单的使用" class="headerlink" title="2、Semaphore简单的使用"></a>2、Semaphore简单的使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">T</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">T</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                semaphore.acquire();</span><br><span class="line">                System.out.println(System.currentTimeMillis() + <span class="string">&quot;,&quot;</span> + thread.getName() + <span class="string">&quot;,获取许可!&quot;</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                semaphore.release();</span><br><span class="line">                System.out.println(System.currentTimeMillis() + <span class="string">&quot;,&quot;</span> + thread.getName() + <span class="string">&quot;,释放许可!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">T</span>(<span class="string">&quot;t-&quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中<code>new Semaphore(2)</code>创建了许可数量为2的信号量，每个线程获取1个许可，同时允许两个线程获取许可，从输出中也可以看出，同时有两个线程可以获取许可，其他线程需要等待已获取许可的线程释放许可之后才能运行。为获取到许可的线程会阻塞在<code>acquire()</code>方法上，直到获取到许可才能继续。</p><h4 id="3、获取许可之后不释放"><a href="#3、获取许可之后不释放" class="headerlink" title="3、获取许可之后不释放"></a>3、获取许可之后不释放</h4><p>门卫（Semaphore）有点呆，司机进去的时候给了钥匙，出来的时候不归还，门卫也不会说什么。最终结果就是其他车辆都无法进入了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo2</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">T</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">T</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                semaphore.acquire();</span><br><span class="line">                System.out.println(System.currentTimeMillis() + <span class="string">&quot;,&quot;</span> + thread.getName() + <span class="string">&quot;,获取许可!&quot;</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                System.out.println(System.currentTimeMillis() + <span class="string">&quot;,&quot;</span> + thread.getName() + <span class="string">&quot;,运行结束!&quot;</span>);</span><br><span class="line">                System.out.println(System.currentTimeMillis() + <span class="string">&quot;,&quot;</span> + thread.getName() + <span class="string">&quot;,当前可用许可数量:&quot;</span> + semaphore.availablePermits());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">T</span>(<span class="string">&quot;t-&quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面程序运行后一直无法结束，观察一下代码，代码中获取许可后，没有释放许可的代码，最终导致，可用许可数量为0，其他线程无法获取许可，会在<code>semaphore.acquire();</code>处等待，导致程序无法结束。</p><h4 id="4、释放许可正确的姿势"><a href="#4、释放许可正确的姿势" class="headerlink" title="4、释放许可正确的姿势"></a>4、释放许可正确的姿势</h4><p>示例1中，在finally里面释放锁，会有问题么？</p><p>如果获取锁的过程中发生异常，导致获取锁失败，最后finally里面也释放了许可，最终会怎么样，导致许可数量凭空增长了。</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo3</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">T</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">T</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                semaphore.acquire();</span><br><span class="line">                System.out.println(System.currentTimeMillis() + <span class="string">&quot;,&quot;</span> + thread.getName() + <span class="string">&quot;,获取许可,当前可用许可数量:&quot;</span> + semaphore.availablePermits());</span><br><span class="line">                <span class="comment">//休眠100秒</span></span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">                System.out.println(System.currentTimeMillis() + <span class="string">&quot;,&quot;</span> + thread.getName() + <span class="string">&quot;,运行结束!&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                semaphore.release();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(System.currentTimeMillis() + <span class="string">&quot;,&quot;</span> + thread.getName() + <span class="string">&quot;,当前可用许可数量:&quot;</span> + semaphore.availablePermits());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>(<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="comment">//休眠1秒</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="type">T</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>(<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="comment">//休眠1秒</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="type">T</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>(<span class="string">&quot;t3&quot;</span>);</span><br><span class="line">        t3.start();</span><br><span class="line">        <span class="comment">//给t2和t3发送中断信号</span></span><br><span class="line">        t2.interrupt();</span><br><span class="line">        t3.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序中信号量许可数量为1，创建了3个线程获取许可，线程t1获取成功了，然后休眠100秒。其他两个线程阻塞在<code>semaphore.acquire();</code>方法处，代码中对线程t2、t3发送中断信号，我们看一下Semaphore中acquire的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span><br></pre></td></tr></table></figure><p>这个方法会响应线程中断，主线程中对t2、t3发送中断信号之后，<code>acquire()</code>方法会触发<code>InterruptedException</code>异常，t2、t3最终没有获取到许可，但是他们都执行了finally中的释放许可的操作，最后导致许可数量变为了2，导致许可数量增加了。所以程序中释放许可的方式有问题。需要改进一下，获取许可成功才去释放锁。</p><p><strong>正确的释放锁的方式，如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo4</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">T</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">T</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">            <span class="comment">//获取许可是否成功</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">acquireSuccess</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                semaphore.acquire();</span><br><span class="line">                acquireSuccess = <span class="literal">true</span>;</span><br><span class="line">                System.out.println(System.currentTimeMillis() + <span class="string">&quot;,&quot;</span> + thread.getName() + <span class="string">&quot;,获取许可,当前可用许可数量:&quot;</span> + semaphore.availablePermits());</span><br><span class="line">                <span class="comment">//休眠100秒</span></span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">                System.out.println(System.currentTimeMillis() + <span class="string">&quot;,&quot;</span> + thread.getName() + <span class="string">&quot;,运行结束!&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (acquireSuccess) &#123;</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(System.currentTimeMillis() + <span class="string">&quot;,&quot;</span> + thread.getName() + <span class="string">&quot;,当前可用许可数量:&quot;</span> + semaphore.availablePermits());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>(<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="comment">//休眠1秒</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="type">T</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>(<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="comment">//休眠1秒</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="type">T</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>(<span class="string">&quot;t3&quot;</span>);</span><br><span class="line">        t3.start();</span><br><span class="line">        <span class="comment">//给t2和t3发送中断信号</span></span><br><span class="line">        t2.interrupt();</span><br><span class="line">        t3.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序中增加了一个变量<code>acquireSuccess</code>用来标记获取许可是否成功，在finally中根据这个变量是否为true，来确定是否释放许可。</p><h4 id="5、在规定的时间内希望获取许可"><a href="#5、在规定的时间内希望获取许可" class="headerlink" title="5、在规定的时间内希望获取许可"></a>5、在规定的时间内希望获取许可</h4><p>司机来到停车场，发现停车场已经满了，只能在外等待内部的车出来之后才能进去，但是要等多久，他自己也不知道，他希望等10分钟，如果还是无法进去，就不到这里停车了。</p><p>Semaphore内部2个方法可以提供超时获取许可的功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> permits, <span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException</span><br></pre></td></tr></table></figure><p>在指定的时间内去尝试获取许可，如果能够获取到，返回true，获取不到返回false。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo5</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">T</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">T</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">            <span class="comment">//获取许可是否成功</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">acquireSuccess</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//尝试在1秒内获取许可，获取成功返回true，否则返回false</span></span><br><span class="line">                System.out.println(System.currentTimeMillis() + <span class="string">&quot;,&quot;</span> + thread.getName() + <span class="string">&quot;,尝试获取许可,当前可用许可数量:&quot;</span> + semaphore.availablePermits());</span><br><span class="line">                acquireSuccess = semaphore.tryAcquire(<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">                <span class="comment">//获取成功执行业务代码</span></span><br><span class="line">                <span class="keyword">if</span> (acquireSuccess) &#123;</span><br><span class="line">                    System.out.println(System.currentTimeMillis() + <span class="string">&quot;,&quot;</span> + thread.getName() + <span class="string">&quot;,获取许可成功,当前可用许可数量:&quot;</span> + semaphore.availablePermits());</span><br><span class="line">                    <span class="comment">//休眠5秒</span></span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(System.currentTimeMillis() + <span class="string">&quot;,&quot;</span> + thread.getName() + <span class="string">&quot;,获取许可失败,当前可用许可数量:&quot;</span> + semaphore.availablePermits());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (acquireSuccess) &#123;</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>(<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="comment">//休眠1秒</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="type">T</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>(<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="comment">//休眠1秒</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="type">T</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>(<span class="string">&quot;t3&quot;</span>);</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中许可数量为1，<code>semaphore.tryAcquire(1, TimeUnit.SECONDS);</code>：表示尝试在1秒内获取许可，获取成功立即返回true，超过1秒还是获取不到，返回false。线程t1获取许可成功，之后休眠了5秒，从输出中可以看出t2和t3都尝试了1秒，获取失败。</p><h4 id="6、其他一些使用说明"><a href="#6、其他一些使用说明" class="headerlink" title="6、其他一些使用说明"></a>6、其他一些使用说明</h4><ol><li>Semaphore默认创建的是非公平的信号量，什么意思呢？这个涉及到公平与非公平。举个例子：5个车位，允许5个车辆进去，来了100辆车，只能进去5辆，其他95在外面排队等着。里面刚好出来了1辆，此时刚好又来了10辆车，这10辆车是直接插队到其他95辆前面去，还是到95辆后面去排队呢？排队就表示公平，直接去插队争抢第一个，就表示不公平。对于停车场，排队肯定更好一些咯。不过对于信号量来说不公平的效率更高一些，所以默认是不公平的。</li><li>建议阅读以下Semaphore的源码，对常用的方法有个了解，不需要都记住，用的时候也方便查询就好。</li><li>方法中带有<code>throws InterruptedException</code>声明的，表示这个方法会响应线程中断信号，什么意思？表示调用线程的<code>interrupt()</code>方法，会让这些方法触发<code>InterruptedException</code>异常，即使这些方法处于阻塞状态，也会立即返回，并抛出<code>InterruptedException</code>异常，线程中断信号也会被清除。</li></ol><h2 id="九、Java内存模型之JMM"><a href="#九、Java内存模型之JMM" class="headerlink" title="九、Java内存模型之JMM"></a>九、Java内存模型之JMM</h2><p>JMM(java内存模型)，由于并发程序要比串行程序复杂很多，其中一个重要原因是并发程序中数据访问<strong>一致性</strong>和<strong>安全性</strong>将会受到严重挑战。<strong>如何保证一个线程可以看到正确的数据呢？</strong>这个问题看起来很白痴。对于串行程序来说，根本就是小菜一碟，如果你读取一个变量，这个变量的值是1，那么你读取到的一定是1，就是这么简单的问题在并行程序中居然变得复杂起来。事实上，如果不加控制地任由线程胡乱并行，即使原本是1的数值，你也可能读到2。因此我们需要在深入了解并行机制的前提下，再定义一种规则，保证多个线程间可以有小弟，正确地协同工作。而JMM也就是为此而生的。</p><h3 id="1、计算机硬件存储体系"><a href="#1、计算机硬件存储体系" class="headerlink" title="1、计算机硬件存储体系"></a>1、计算机硬件存储体系</h3><p> 计算机存储结构，从本地磁盘到主存到CPU缓存，也就是从硬盘到内存，到CPU。一般对应的程序的操作就是从数据库查数据到内存然后到CPU进行计算</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210917214130116.png" alt="image-20210917214130116"></p><p>​因为有这么多级的缓存(cpu和物理主内存的速度不一致的)，CPU的运行并不是直接操作内存而是先把内存里边的数据读到缓存，而内存的读和写操作的时候就会造成不一致的问题</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210917214254898.png" alt="image-20210917214254898"></p><p>​Java虚拟机规范中试图定义一种Java内存模型（java Memory Model，简称JMM) 来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。推导出我们需要知道JMM</p><h3 id="2、Java内存模型Java-Memory-Model"><a href="#2、Java内存模型Java-Memory-Model" class="headerlink" title="2、Java内存模型Java Memory Model"></a>2、Java内存模型Java Memory Model</h3><p>​JMM(Java内存模型Java Memory Model，简称JMM)本身是一种抽象的概念并不真实存在它仅仅描述的是一组约定或规范，通过这组规范定义了程序中(尤其是多线程)各个变量的读写访问方式并决定一个线程对共享变量的写入何时以及如何变成对另一个线程可见，关键技术点都是围绕多线程的原子性、可见性和有序性展开的。</p><p> 原则：<br> JMM的关键技术点都是围绕多线程的原子性、可见性和有序性展开的</p><p>能干嘛？<br>1 通过JMM来实现线程和主内存之间的抽象关系。<br>2 屏蔽各个硬件平台和操作系统的内存访问差异以实现让Java程序在各种平台下都能达到一致的内存访问效果。</p><h3 id="3、JMM规范下，三大特性"><a href="#3、JMM规范下，三大特性" class="headerlink" title="3、JMM规范下，三大特性"></a>3、JMM规范下，三大特性</h3><h4 id="1、可见性"><a href="#1、可见性" class="headerlink" title="1、可见性"></a>1、可见性</h4><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210917214426713.png" alt="image-20210917214426713"></p><p>​Java中普通的共享变量不保证可见性，因为数据修改被写入内存的时机是不确定的，多线程并发下很可能出现”脏读”，所以每个线程都有自己的工作内存，线程自己的工作内存中保存了该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取，赋值等 ）都必需在线程自己的工作内存中进行，而不能够直接读写主内存中的变量。不同线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210917214441440.png" alt="image-20210917214441440"></p><p> 线程脏读：如果没有可见性保证</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210917214501491.png" alt="image-20210917214501491"></p><h4 id="2、原子性"><a href="#2、原子性" class="headerlink" title="2、原子性"></a>2、原子性</h4><p>指一个操作是不可中断的，即多线程环境下，操作不能被其他线程干扰</p><p>原子性是指<strong>操作是不可分的</strong>，要么全部一起执行，要么不执行。在java中，其表现在对于共享变量的某些操作，是不可分的，必须连续的完成。比如a++，对于共享变量a的操作，实际上会执行3个步骤：</p><p>1.读取变量a的值，假如a&#x3D;1<br>2.a的值+1，为2<br>3.将2值赋值给变量a，此时a的值应该为2</p><p>这三个操作中任意一个操作，a的值如果被其他线程篡改了，那么都会出现我们不希望出现的结果。所以必须保证这3个操作是原子性的，在操作a++的过程中，其他线程不会改变a的值，如果在上面的过程中出现其他线程修改了a的值，在满足原子性的原则下，上面的操作应该失败。</p><h4 id="3、有序性"><a href="#3、有序性" class="headerlink" title="3、有序性"></a>3、有序性</h4><p>对于一个线程的执行代码而言，我们总是习惯性认为代码的执行总是从上到下，有序执行。<br>但为了提供性能，编译器和处理器通常会对指令序列进行重新排序。<br>指令重排可以保证串行语义一致，但没有义务保证多线程间的语义也一致，即可能产生”脏读”，简单说，<br>两行以上不相干的代码在执行的时候有可能先执行的不是第一条，不见得是从上到下顺序执行，执行顺序会被优化。</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210917214606690.png" alt="image-20210917214606690"></p><p>单线程环境里面确保程序最终执行结果和代码顺序执行的结果一致。<br>处理器在进行重排序时必须要考虑指令之间的数据依赖性<br>多线程环境中线程交替执行,由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性是无法确定的,结果无法预测</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210917214623939.png" alt="image-20210917214623939"></p><h3 id="4、JMM规范下，多线程对变量的读写过程"><a href="#4、JMM规范下，多线程对变量的读写过程" class="headerlink" title="4、JMM规范下，多线程对变量的读写过程"></a>4、JMM规范下，多线程对变量的读写过程</h3><h4 id="1、读取过程"><a href="#1、读取过程" class="headerlink" title="1、读取过程"></a>1、读取过程</h4><p>​由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存(有些地方称为栈空间)，工作内存是每个线程的私有数据区域，而Java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作(读取赋值等)必须在工作内存中进行，首先要将变量从主内存拷贝到的线程自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，各个线程中的工作内存中存储着主内存中的变量副本拷贝，因此不同的线程间无法访问对方的工作内存，线程间的通信(传值)必须通过主内存来完成，其简要访问过程如下图:</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210917214744040.png" alt="image-20210917214744040"></p><p>JMM定义了线程和主内存之间的抽象关系<br>1 线程之间的共享变量存储在主内存中(从硬件角度来说就是内存条)<br>2 每个线程都有一个私有的本地工作内存，本地工作内存中存储了该线程用来读&#x2F;写共享变量的副本(从硬件角度来说就是CPU的缓存，比如寄存器、L1、L2、L3缓存等)</p><h4 id="2、小总结"><a href="#2、小总结" class="headerlink" title="2、小总结"></a>2、小总结</h4><ul><li>我们定义的所有共享变量都储存在物理主内存中</li><li>每个线程都有自己独立的工作内存，里面保存该线程使用到的变量的副本(主内存中该变量的一份拷贝)</li><li>线程对共享变量所有的操作都必须先在线程自己的工作内存中进行后写回主内存，不能直接从主内存中读写(不能越级)</li><li>不同线程之间也无法直接访问其他线程的工作内存中的变量，线程间变量值的传递需要通过主内存来进行(同级不能相互访问)</li></ul><h3 id="5、JMM规范下，多线程先行发生原则之happens-before"><a href="#5、JMM规范下，多线程先行发生原则之happens-before" class="headerlink" title="5、JMM规范下，多线程先行发生原则之happens-before"></a>5、JMM规范下，多线程先行发生原则之happens-before</h3><p>在JMM中，如果一个操作执行的结果需要对另一个操作可见性或者 代码重排序，那么这两个操作之间必须存在happens-before关系。</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210917214911737.png" alt="image-20210917214911737"></p><h4 id="1、先行发生原则说明"><a href="#1、先行发生原则说明" class="headerlink" title="1、先行发生原则说明"></a>1、先行发生原则说明</h4><p>​如果Java内存模型中所有的有序性都仅靠volatile和synchronized来完成，那么有很多操作都将会变得非常啰嗦，<br>但是我们在编写Java并发代码的时候并没有察觉到这一点。</p><p>​我们没有时时、处处、次次，添加volatile和synchronized来完成程序，这是因为Java语言中JMM原则下有一个“先行发生”(Happens-Before)的原则限制和规矩</p><p>这个原则非常重要：<br>        它是判断数据是否存在竞争，线程是否安全的非常有用的手段。依赖这个原则，我们可以通过几条简单规则一揽子解决并发环境下两个操<br>作之间是否可能存在冲突的所有问题，而不需要陷入Java内存模型苦涩难懂的底层编译原理之中。</p><h4 id="2、happens-before总原则"><a href="#2、happens-before总原则" class="headerlink" title="2、happens-before总原则"></a>2、happens-before总原则</h4><ul><li>如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。</li><li>两个操作之间存在happens-before关系，并不意味着一定要按照happens-before原则制定的顺序来执行。如果重排序之后的执行结果与按照happens-before关系来执行的结果一致，那么这种重排序并不非法。<ul><li>1+2+3 &#x3D; 3+2+1</li><li>周一张三周二李四，假如有事情调换班可以的</li></ul></li></ul><h3 id="6、happens-before之8条"><a href="#6、happens-before之8条" class="headerlink" title="6、happens-before之8条"></a>6、happens-before之8条</h3><h4 id="1、次序规则"><a href="#1、次序规则" class="headerlink" title="1、次序规则"></a>1、次序规则</h4><p>一个线程内，按照代码顺序，写在前面的操作先行发生于写在后面的操作；</p><p>前一个操作的结果可以被后续的操作获取。讲白点就是前面一个操作把变量X赋值为1，那后面一个操作肯定能知道X已经变成了1。</p><h4 id="2、锁定规则"><a href="#2、锁定规则" class="headerlink" title="2、锁定规则"></a>2、锁定规则</h4><p>一个unLock操作先行发生于后面((这里的“后面”是指时间上的先后))对同一个锁的lock操作；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HappenBeforeDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">objectLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//对于同一把锁objectLock，threadA一定先unlock同一把锁后B才能获得该锁，   A 先行发生于B</span></span><br><span class="line">        <span class="keyword">synchronized</span> (objectLock)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、volatile变量规则"><a href="#3、volatile变量规则" class="headerlink" title="3、volatile变量规则"></a>3、volatile变量规则</h4><p>对一个volatile变量的写操作先行发生于后面对这个变量的读操作，前面的写对后面的读是可见的，这里的“后面”同样是指时间上的先后。</p><h4 id="4、传递规则"><a href="#4、传递规则" class="headerlink" title="4、传递规则"></a>4、传递规则</h4><p>如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C；</p><h4 id="5、线程启动规则-Thread-Start-Rule"><a href="#5、线程启动规则-Thread-Start-Rule" class="headerlink" title="5、线程启动规则(Thread Start Rule)"></a>5、线程启动规则(Thread Start Rule)</h4><p>Thread对象的start()方法先行发生于此线程的每一个动作</p><h4 id="6、线程中断规则-Thread-Interruption-Rule"><a href="#6、线程中断规则-Thread-Interruption-Rule" class="headerlink" title="6、线程中断规则(Thread Interruption Rule)"></a>6、线程中断规则(Thread Interruption Rule)</h4><p>对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生；</p><p>可以通过Thread.interrupted()检测到是否发生中断</p><h4 id="7、线程终止规则-Thread-Termination-Rule"><a href="#7、线程终止规则-Thread-Termination-Rule" class="headerlink" title="7、线程终止规则(Thread Termination Rule)"></a>7、线程终止规则(Thread Termination Rule)</h4><p>线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread::join()方法是否结束、<br>Thread::isAlive()的返回值等手段检测线程是否已经终止执行。</p><h4 id="8、对象终结规则-Finalizer-Rule"><a href="#8、对象终结规则-Finalizer-Rule" class="headerlink" title="8、对象终结规则(Finalizer Rule)"></a>8、对象终结规则(Finalizer Rule)</h4><p>一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始</p><p>对象没有完成初始化之前，是不能调用finalized()方法的</p><h3 id="7、案例说明"><a href="#7、案例说明" class="headerlink" title="7、案例说明"></a>7、案例说明</h3><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210917215555073.png" alt="image-20210917215555073"></p><p>​假设存在线程A和B，线程A先（时间上的先后）调用了setValue(1)，然后线程B调用了同一个对象的getValue()，那么线程B收到的返回值是什么？</p><p>我们就这段简单的代码一次分析happens-before的规则（规则5、6、7、8 可以忽略，因为他们和这段代码毫无关系）：<br>1 由于两个方法是由不同的线程调用，不在同一个线程中，所以肯定不满足程序次序规则；<br>2 两个方法都没有使用锁，所以不满足锁定规则；<br>3 变量不是用volatile修饰的，所以volatile变量规则不满足；<br>4 传递规则肯定不满足；</p><p>​所以我们无法通过happens-before原则推导出线程A happens-before线程B，虽然可以确认在时间上线程A优先于线程B指定，但就是无法确认线程B获得的结果是什么，所以这段代码不是线程安全的。那么怎么修复这段代码呢？</p><ul><li>把getter&#x2F;setter方法都定义为synchronized方法</li><li>把value定义为volatile变量，由于setter方法对value的修改不依赖value的原值，满足volatile关键字使用场景</li></ul><h2 id="十、volatile与Java内存模型"><a href="#十、volatile与Java内存模型" class="headerlink" title="十、volatile与Java内存模型"></a>十、volatile与Java内存模型</h2><h3 id="1、被volatile修改的变量有2大特点"><a href="#1、被volatile修改的变量有2大特点" class="headerlink" title="1、被volatile修改的变量有2大特点"></a>1、被volatile修改的变量有2大特点</h3><ul><li>可见性</li><li>有序性</li></ul><h3 id="2、volatile的内存语义"><a href="#2、volatile的内存语义" class="headerlink" title="2、volatile的内存语义"></a>2、volatile的内存语义</h3><ul><li>当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值立即刷新回主内存中。</li><li>当读一个volatile变量时，JMM会把该线程对应的本地内存设置为无效，直接从主内存中读取共享变量</li><li>所以volatile的写内存语义是直接刷新到主内存中，读的内存语义是直接从主内存中读取。</li></ul><h3 id="3、内存屏障（重点）"><a href="#3、内存屏障（重点）" class="headerlink" title="3、内存屏障（重点）"></a>3、内存屏障（重点）</h3><h4 id="1、生活case"><a href="#1、生活case" class="headerlink" title="1、生活case"></a>1、生活case</h4><ul><li><p>没有管控，顺序难保</p></li><li><p>设定规则，禁止乱序</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210922203923024.png" alt="image-20210922203923024"></p><p>上海南京路步行街武警“人墙”当红灯</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210922204024363.png" alt="image-20210922204024363"></p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210922204027690.png" alt="image-20210922204027690"></p><h4 id="2、内存屏障是什么"><a href="#2、内存屏障是什么" class="headerlink" title="2、内存屏障是什么"></a>2、内存屏障是什么</h4><p>​内存屏障（也称内存栅栏，内存栅障，屏障指令等，是一类同步屏障指令，是CPU或编译器在对内存随机访问的操作中的一个同步点，使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作），避免代码重排序。内存屏障其实就是一种JVM指令，Java内存模型的重排规则会要求Java编译器在生成JVM指令时插入特定的内存屏障指令，通过这些内存屏障指令，volatile实现了Java内存模型中的可见性和有序性，但volatile无法保证原子性。</p><p>​内存屏障之前的所有写操作都要回写到主内存，内存屏障之后的所有读操作都能获得内存屏障之前的所有写操作的最新结果(实现了可见性)。</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210922204126528.png" alt="image-20210922204126528"></p><p>因此重排序时，不允许把内存屏障之后的指令重排序到内存屏障之前。<br>一句话：对一个 volatile 域的写, happens-before 于任意后续对这个 volatile 域的读，也叫写后读。</p><h4 id="3、volatile凭什么可以保证可见性和有序性？？？"><a href="#3、volatile凭什么可以保证可见性和有序性？？？" class="headerlink" title="3、volatile凭什么可以保证可见性和有序性？？？"></a>3、volatile凭什么可以保证可见性和有序性？？？</h4><p>内存屏障 (Memory Barriers &#x2F; Fences)</p><h4 id="4、JVM中提供了四类内存屏障指令"><a href="#4、JVM中提供了四类内存屏障指令" class="headerlink" title="4、JVM中提供了四类内存屏障指令"></a>4、JVM中提供了四类内存屏障指令</h4><p>Unsafe.class</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210922204301539.png" alt="image-20210922204301539"></p><p>Unsafe.java</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210922204320477.png" alt="image-20210922204320477"></p><p>Unsafe.cpp</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210922204329642.png" alt="image-20210922204329642"></p><p>OrderAccess.hpp</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210922204339917.png" alt="image-20210922204339917"></p><p>orderAccess_linux_x86.inline.hpp</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210922204349150.png" alt="image-20210922204349150"></p><h4 id="5、四大屏障分别是什么意思"><a href="#5、四大屏障分别是什么意思" class="headerlink" title="5、四大屏障分别是什么意思"></a>5、四大屏障分别是什么意思</h4><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210922204417963.png" alt="image-20210922204417963"></p><p>orderAccess_linux_x86.inline.hpp</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210922204432078.png" alt="image-20210922204432078"></p><h4 id="6、happens-before-之-volatile-变量规则"><a href="#6、happens-before-之-volatile-变量规则" class="headerlink" title="6、happens-before 之 volatile 变量规则"></a>6、happens-before 之 volatile 变量规则</h4><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210922204533258.png" alt="image-20210922204533258"></p><table><thead><tr><th>当第一个操作为volatile读时，不论第二个操作是什么，都不能重排序。这个操作保证了volatile读之后的操作不会被重排到volatile读之前。</th></tr></thead><tbody><tr><td>当第二个操作为volatile写时，不论第一个操作是什么，都不能重排序。这个操作保证了volatile写之前的操作不会被重排到volatile写之后。</td></tr><tr><td>当第一个操作为volatile写时，第二个操作为volatile读时，不能重排。</td></tr></tbody></table><h4 id="7、JMM-就将内存屏障插⼊策略分为-4-种"><a href="#7、JMM-就将内存屏障插⼊策略分为-4-种" class="headerlink" title="7、JMM 就将内存屏障插⼊策略分为 4 种"></a>7、JMM 就将内存屏障插⼊策略分为 4 种</h4><ul><li><p>写</p><ul><li>在每个 volatile 写操作的前⾯插⼊⼀个 StoreStore 屏障</li><li>在每个 volatile 写操作的后⾯插⼊⼀个 StoreLoad 屏障</li></ul></li><li><p>读</p><ul><li>在每个 volatile 读操作的后⾯插⼊⼀个 LoadLoad 屏障</li><li>在每个 volatile 读操作的后⾯插⼊⼀个 LoadStore 屏障</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210922204820482.png" alt="image-20210922204820482"></p><h3 id="4、volatile特性"><a href="#4、volatile特性" class="headerlink" title="4、volatile特性"></a>4、volatile特性</h3><h4 id="1、保证可见性"><a href="#1、保证可见性" class="headerlink" title="1、保证可见性"></a>1、保证可见性</h4><p>保证不同线程对这个变量进行操作时的可见性，即变量一旦改变所有线程立即可见</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileSeeDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span>          <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;       <span class="comment">//不加volatile，没有可见性</span></span><br><span class="line">    <span class="comment">//static volatile boolean flag = true;       //加了volatile，保证可见性</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t come in&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (flag)</span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t flag被修改为false,退出.....&quot;</span>);</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//暂停2秒钟后让main线程修改flag值</span></span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">2</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line"></span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;main线程修改完成&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不加volatile，没有可见性，程序无法停止</li><li>加了volatile，保证可见性，程序可以停止</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">线程t1中为何看不到被主线程main修改为false的flag的值？</span><br><span class="line"> </span><br><span class="line">问题可能:</span><br><span class="line">1. 主线程修改了flag之后没有将其刷新到主内存，所以t1线程看不到。</span><br><span class="line">2. 主线程将flag刷新到了主内存，但是t1一直读取的是自己工作内存中flag的值，没有去主内存中更新获取flag最新的值。</span><br><span class="line"> </span><br><span class="line">我们的诉求：</span><br><span class="line">1.线程中修改了工作内存中的副本之后，立即将其刷新到主内存；</span><br><span class="line">2.工作内存中每次读取共享变量时，都去主内存中重新读取，然后拷贝到工作内存。</span><br><span class="line"> </span><br><span class="line">解决：</span><br><span class="line">使用volatile修饰共享变量，就可以达到上面的效果，被volatile修改的变量有以下特点：</span><br><span class="line">1. 线程中读取的时候，每次读取都会去主内存中读取共享变量最新的值，然后将其复制到工作内存</span><br><span class="line">2. 线程中修改了工作内存中变量的副本，修改之后会立即刷新到主内存</span><br></pre></td></tr></table></figure><h5 id="1、volatile变量的读写过程"><a href="#1、volatile变量的读写过程" class="headerlink" title="1、volatile变量的读写过程"></a>1、volatile变量的读写过程</h5><p>Java内存模型中定义的8种工作内存与主内存之间的原子操作<br>read(读取)→load(加载)→use(使用)→assign(赋值)→store(存储)→write(写入)→lock(锁定)→unlock(解锁)</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210922205210267.png" alt="image-20210922205210267"></p><p>read: 作用于主内存，将变量的值从主内存传输到工作内存，主内存到工作内存<br>load: 作用于工作内存，将read从主内存传输的变量值放入工作内存变量副本中，即数据加载<br>use: 作用于工作内存，将工作内存变量副本的值传递给执行引擎，每当JVM遇到需要该变量的字节码指令时会执行该操作<br>assign: 作用于工作内存，将从执行引擎接收到的值赋值给工作内存变量，每当JVM遇到一个给变量赋值字节码指令时会执行该操作<br>store: 作用于工作内存，将赋值完毕的工作变量的值写回给主内存<br>write: 作用于主内存，将store传输过来的变量值赋值给主内存中的变量<br>由于上述只能保证单条指令的原子性，针对多条指令的组合性原子保证，没有大面积加锁，所以，JVM提供了另外两个原子指令：<br>lock: 作用于主内存，将一个变量标记为一个线程独占的状态，只是写时候加锁，就只是锁了写变量的过程。<br>unlock: 作用于主内存，把一个处于锁定状态的变量释放，然后才能被其他线程占用</p><h4 id="2、没有原子性"><a href="#2、没有原子性" class="headerlink" title="2、没有原子性"></a>2、没有原子性</h4><h5 id="1、volatile变量的复合操作-如i-不具有原子性"><a href="#1、volatile变量的复合操作-如i-不具有原子性" class="headerlink" title="1、volatile变量的复合操作(如i++)不具有原子性"></a>1、volatile变量的复合操作(如i++)不具有原子性</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyNumber</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addPlusPlus</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        number++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileNoAtomicDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">MyNumber</span> <span class="variable">myNumber</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyNumber</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= <span class="number">1000</span>; j++) &#123;</span><br><span class="line">                    myNumber.addPlusPlus();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//暂停几秒钟线程</span></span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">3</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + myNumber.number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从i++的字节码角度说明</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210922205402552.png" alt="image-20210922205402552"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">原子性指的是一个操作是不可中断的，即使是在多线程环境下，一个操作一旦开始就不会被其他线程影响。</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        i++; <span class="comment">//不具备原子性，该操作是先读取值，然后写回一个新值，相当于原来的值加上1，分3步完成</span></span><br><span class="line"> &#125;</span><br><span class="line">如果第二个线程在第一个线程读取旧值和写回新值期间读取i的域值，那么第二个线程就会与第一个线程一起看到同一个值，</span><br><span class="line">并执行相同值的加<span class="number">1</span>操作，这也就造成了线程安全失败，因此对于add方法必须使用<span class="keyword">synchronized</span>修饰，以便保证线程安全.</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210922205426175.png" alt="image-20210922205426175"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">多线程环境下，<span class="string">&quot;数据计算&quot;</span>和<span class="string">&quot;数据赋值&quot;</span>操作可能多次出现，即操作非原子。若数据在加载之后，若主内存count变量发生修改之后，由于线程工作内存中的值在此前已经加载，从而不会对变更操作做出相应变化，即私有内存和公共内存中变量不同步，进而导致数据不一致</span><br><span class="line">对于<span class="keyword">volatile</span>变量，JVM只是保证从主内存加载到线程工作内存的值是最新的，也就是数据加载时是最新的。</span><br><span class="line">由此可见<span class="keyword">volatile</span>解决的是变量读时的可见性问题，但无法保证原子性，对于多线程修改共享变量的场景必须使用加锁同步</span><br></pre></td></tr></table></figure><h5 id="2、读取赋值一个普通变量的情况"><a href="#2、读取赋值一个普通变量的情况" class="headerlink" title="2、读取赋值一个普通变量的情况"></a>2、读取赋值一个普通变量的情况</h5><p>当线程1对主内存对象发起read操作到write操作第一套流程的时间里，线程2随时都有可能对这个主内存对象发起第二套操作</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210922205521467.png" alt="image-20210922205521467"></p><h5 id="3、既然一修改就是可见，为什么还不能保证原子性？"><a href="#3、既然一修改就是可见，为什么还不能保证原子性？" class="headerlink" title="3、既然一修改就是可见，为什么还不能保证原子性？"></a>3、既然一修改就是可见，为什么还不能保证原子性？</h5><p>volatile主要是对其中部分指令做了处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">要use(使用)一个变量的时候必需load(载入），要载入的时候必需从主内存read(读取）这样就解决了读的可见性。 </span><br><span class="line">写操作是把assign和store做了关联(在assign(赋值)后必需store(存储))。store(存储)后write(写入)。</span><br><span class="line">也就是做到了给一个变量赋值的时候一串关联指令直接把变量值写到主内存。</span><br><span class="line">就这样通过用的时候直接从主内存取，在赋值到直接写回主内存做到了内存可见性。注意蓝色框框的间隙。。。。。。o(╥﹏╥)o</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210922205631332.png" alt="image-20210922205631332"></p><h5 id="4、读取赋值一个volatile变量的情况"><a href="#4、读取赋值一个volatile变量的情况" class="headerlink" title="4、读取赋值一个volatile变量的情况"></a>4、读取赋值一个volatile变量的情况</h5><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210922205704525.png" alt="image-20210922205704525"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> read-load-use 和 assign-store-write 成为了两个不可分割的原子操作，但是在use和assign之间依然有极小的一段真空期，有可能变量会被其他线程读取，导致写丢失一次...o(╥﹏╥)o</span><br><span class="line">但是无论在哪一个时间点主内存的变量和任一工作内存的变量的值都是相等的。这个特性就导致了<span class="keyword">volatile</span>变量不适合参与到依赖当前值的运算，如i = i + <span class="number">1</span>; i++;之类的那么依靠可见性的特点<span class="keyword">volatile</span>可以用在哪些地方呢？ 通常<span class="keyword">volatile</span>用做保存某个状态的<span class="type">boolean</span>值or <span class="type">int</span>值。</span><br><span class="line">《深入理解Java虚拟机》提到：</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210922205718122.png" alt="image-20210922205718122"></p><h5 id="5、面试回答"><a href="#5、面试回答" class="headerlink" title="5、面试回答"></a>5、面试回答</h5><p>JVM的字节码，i++分成三步，间隙期不同步非原子操作(i++)</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210922205752322.png" alt="image-20210922205752322"></p><h4 id="3、指令禁重排"><a href="#3、指令禁重排" class="headerlink" title="3、指令禁重排"></a>3、指令禁重排</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">重排序</span><br><span class="line">重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段，有时候会改变程序语句的先后顺序</span><br><span class="line">不存在数据依赖关系，可以重排序；</span><br><span class="line">存在数据依赖关系，禁止重排序</span><br><span class="line">但重排后的指令绝对不能改变原有的串行语义！这点在并发设计中必须要重点考虑！</span><br><span class="line">    </span><br><span class="line">重排序的分类和执行流程</span><br></pre></td></tr></table></figure><p><img src="/images/1.JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20210922205902093.png" alt="image-20210922205902093"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">编译器优化的重排序： 编译器在不改变单线程串行语义的前提下，可以重新调整指令的执行顺序</span><br><span class="line">指令级并行的重排序： 处理器使用指令级并行技术来讲多条指令重叠执行，若不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序</span><br><span class="line">内存系统的重排序： 由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是乱序执行</span><br><span class="line"> </span><br><span class="line">数据依赖性：若两个操作访问同一变量，且这两个操作中有一个为写操作，此时两操作间就存在数据依赖性。</span><br><span class="line"> </span><br><span class="line">案例 ：</span><br><span class="line">不存在数据依赖关系，可以重排序===&gt; 重排序OK 。</span><br></pre></td></tr></table></figure><table><thead><tr><th>重排前</th><th>重排后</th></tr></thead><tbody><tr><td>int a &#x3D; 1;  &#x2F;&#x2F;1<br/>int b &#x3D; 20; &#x2F;&#x2F;2<br/>int c &#x3D; a + b; &#x2F;&#x2F;3</td><td>int b &#x3D; 20;  &#x2F;&#x2F;1<br/>int a &#x3D; 1; &#x2F;&#x2F;2<br/>int c &#x3D; a + b; &#x2F;&#x2F;3</td></tr><tr><td>结论：编译器调整了语句的顺序，但是不影响程序的最终结果。</td><td>重排序OK</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">存在数据依赖关系，禁止重排序===&gt; 重排序发生，会导致程序运行结果不同。</span><br><span class="line">编译器和处理器在重排序时，会遵守数据依赖性，不会改变存在依赖关系的两个操作的执行,但不同处理器和不同线程之间的数据性不会被编译器和处理器考虑，其只会作用于单处理器和单线程环境，下面三种情况，只要重排序两个操作的执行顺序，程序的执行结果就会被改变。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210922210024000.png" alt="image-20210922210024000"></p><h5 id="1、volatile的底层实现是通过内存屏障"><a href="#1、volatile的底层实现是通过内存屏障" class="headerlink" title="1、volatile的底层实现是通过内存屏障"></a>1、volatile的底层实现是通过内存屏障</h5><p>volatile有关的禁止指令重排的行为</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210922210055834.png" alt="image-20210922210055834"></p><table><thead><tr><th>当第一个操作为volatile读时，不论第二个操作是什么，都不能重排序。这个操作保证了volatile读之后的操作不会被重排到volatile读之前。</th></tr></thead><tbody><tr><td>当第二个操作为volatile写时，不论第一个操作是什么，都不能重排序。这个操作保证了volatile写之前的操作不会被重排到volatile写之后。</td></tr><tr><td>当第一个操作为volatile写时，第二个操作为volatile读时，不能重排。</td></tr></tbody></table><p>四大屏障的插入情况</p><ul><li>在每一个volatile写操作前面插入一个StoreStore屏障<ul><li>StoreStore屏障可以保证在volatile写之前，其前面的所有普通写操作都已经刷新到主内存中。</li></ul></li><li>在每一个volatile写操作后面插入一个StoreLoad屏障<ul><li>StoreLoad屏障的作用是避免volatile写与后面可能有的volatile读&#x2F;写操作重排序</li></ul></li><li>在每一个volatile读操作后面插入一个LoadLoad屏障<ul><li>LoadLoad屏障用来禁止处理器把上面的volatile读与下面的普通读重排序。</li></ul></li><li>在每一个volatile读操作后面插入一个LoadStore屏障<ul><li>LoadStore屏障用来禁止处理器把上面的volatile读与下面的普通写重排序。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模拟一个单线程，什么顺序读？什么顺序写？</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileTest</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">()</span>&#123;</span><br><span class="line">        i = <span class="number">2</span>;</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;---i = &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210922210258725.png" alt="image-20210922210258725"></p><h4 id="4、如何正确使用volatile"><a href="#4、如何正确使用volatile" class="headerlink" title="4、如何正确使用volatile"></a>4、如何正确使用volatile</h4><h5 id="1、单一赋值可以，but含复合运算赋值不可以-i-之类"><a href="#1、单一赋值可以，but含复合运算赋值不可以-i-之类" class="headerlink" title="1、单一赋值可以，but含复合运算赋值不可以(i++之类)"></a>1、单一赋值可以，but含复合运算赋值不可以(i++之类)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span> </span><br></pre></td></tr></table></figure><h5 id="2、状态标志，判断业务是否结束"><a href="#2、状态标志，判断业务是否结束" class="headerlink" title="2、状态标志，判断业务是否结束"></a>2、状态标志，判断业务是否结束</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 使用：作为一个布尔状态标志，用于指示发生了一个重要的一次性事件，例如完成初始化或任务结束</span></span><br><span class="line"><span class="comment"> * 理由：状态标志并不依赖于程序内任何其他状态，且通常只有一种状态转换</span></span><br><span class="line"><span class="comment"> * 例子：判断业务是否结束</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UseVolatileDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span>(flag) &#123;</span><br><span class="line">                <span class="comment">//do something......</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//暂停几秒钟线程</span></span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">2L</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3、开销较低的读，写锁策略"><a href="#3、开销较低的读，写锁策略" class="headerlink" title="3、开销较低的读，写锁策略"></a>3、开销较低的读，写锁策略</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UseVolatileDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用：当读远多于写，结合使用内部锁和 volatile 变量来减少同步的开销</span></span><br><span class="line"><span class="comment">     * 理由：利用volatile保证读取操作的可见性；利用synchronized保证复合操作的原子性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> value;   <span class="comment">//利用volatile保证读取操作的可见性</span></span><br><span class="line">              &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">increment</span><span class="params">()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> value++; <span class="comment">//利用synchronized保证复合操作的原子性</span></span><br><span class="line">               &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4、DCL双端锁的发布"><a href="#4、DCL双端锁的发布" class="headerlink" title="4、DCL双端锁的发布"></a>4、DCL双端锁的发布</h5><p>问题代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SafeDoubleCheckSingleton</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SafeDoubleCheckSingleton singleton;</span><br><span class="line">    <span class="comment">//私有化构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SafeDoubleCheckSingleton</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//双重锁设计</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SafeDoubleCheckSingleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//1.多线程并发创建对象时，会通过加锁保证只有一个线程能创建对象</span></span><br><span class="line">            <span class="keyword">synchronized</span> (SafeDoubleCheckSingleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="literal">null</span>)&#123;</span><br><span class="line">                    <span class="comment">//隐患：多线程环境下，由于重排序，该对象可能还未完成初始化就被其他线程读取</span></span><br><span class="line">                    singleton = <span class="keyword">new</span> <span class="title class_">SafeDoubleCheckSingleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.对象创建完毕，执行getInstance()将不需要获取锁，直接返回创建对象</span></span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>单线程看问题代码</strong></p><p>单线程环境下(或者说正常情况下)，在”问题代码处”，会执行如下操作，保证能获取到已完成初始化的实例</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210922210741247.png" alt="image-20210922210741247"></p><p>由于存在指令重排序……</p><p><strong>多线程看问题代码</strong></p><p>隐患：多线程环境下，在”问题代码处”，会执行如下操作，由于重排序导致2,3乱序，后果就是其他线程得到的是null而不是完成初始化的对象</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210922210815931.png" alt="image-20210922210815931"></p><p><strong>解决01</strong></p><p>加volatile修饰</p><p>面试题，反周志明老师的案例，你还有不加volatile的方法吗</p><p><strong>解决02</strong> – 采用静态内部类的方式实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//现在比较好的做法就是采用静态内部内的方式实现</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingletonDemo</span><span class="params">()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonDemoHandler</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">SingletonDemo</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingletonDemo</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingletonDemo <span class="title function_">getInstance</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonDemoHandler.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5、最后的小总结"><a href="#5、最后的小总结" class="headerlink" title="5、最后的小总结"></a>5、最后的小总结</h4><h5 id="1、内存屏障是什么"><a href="#1、内存屏障是什么" class="headerlink" title="1、内存屏障是什么"></a>1、内存屏障是什么</h5><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210922211112799.png" alt="image-20210922211112799"></p><h5 id="2、内存屏障能干嘛"><a href="#2、内存屏障能干嘛" class="headerlink" title="2、内存屏障能干嘛"></a>2、内存屏障能干嘛</h5><ul><li>阻止屏障两边的指令重排序</li><li>写数据时加入屏障，强制将线程私有工作内存的数据刷回主物理内存</li><li>读数据时加入屏障，线程私有工作内存的数据失效，重新到主物理内存中获取最新数据</li></ul><h5 id="3、内存屏障四大指令"><a href="#3、内存屏障四大指令" class="headerlink" title="3、内存屏障四大指令"></a>3、内存屏障四大指令</h5><ul><li>在每一个volatile写操作前面插入一个StoreStore屏障<ul><li><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210922211216698.png" alt="image-20210922211216698"></li></ul></li><li>在每一个volatile写操作后面插入一个StoreLoad屏障<ul><li><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210922211234267.png" alt="image-20210922211234267"></li></ul></li><li>在每一个volatile读操作后面插入一个LoadLoad屏障<ul><li><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210922211247865.png" alt="image-20210922211247865"></li></ul></li><li>在每一个volatile读操作后面插入一个LoadStore屏障<ul><li><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210922211259274.png" alt="image-20210922211259274"></li></ul></li></ul><h5 id="4、凭什么我们java写了一个volatile关键字系统底层加入内存屏障？两者关系怎么勾搭上的"><a href="#4、凭什么我们java写了一个volatile关键字系统底层加入内存屏障？两者关系怎么勾搭上的" class="headerlink" title="4、凭什么我们java写了一个volatile关键字系统底层加入内存屏障？两者关系怎么勾搭上的?"></a>4、凭什么我们java写了一个volatile关键字系统底层加入内存屏障？两者关系怎么勾搭上的?</h5><p>字节码层面</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210922211344635.png" alt="image-20210922211344635"></p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210922211354764.png" alt="image-20210922211354764"></p><h5 id="5、volatile可见性"><a href="#5、volatile可见性" class="headerlink" title="5、volatile可见性"></a>5、volatile可见性</h5><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210922211419405.png" alt="image-20210922211419405"></p><h5 id="6、volatile禁重排"><a href="#6、volatile禁重排" class="headerlink" title="6、volatile禁重排"></a>6、volatile禁重排</h5><p>写指令</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210922211436123.png" alt="image-20210922211436123"></p><p>读指令</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210922211447326.png" alt="image-20210922211447326"></p><h5 id="7、对比java-util-concurrent-locks-Lock来理解"><a href="#7、对比java-util-concurrent-locks-Lock来理解" class="headerlink" title="7、对比java.util.concurrent.locks.Lock来理解"></a>7、对比java.util.concurrent.locks.Lock来理解</h5><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210922211501481.png" alt="image-20210922211501481"></p><h5 id="8、一句话总结"><a href="#8、一句话总结" class="headerlink" title="8、一句话总结"></a>8、一句话总结</h5><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210922211532860.png" alt="image-20210922211532860"></p><h2 id="十一、CAS"><a href="#十一、CAS" class="headerlink" title="十一、CAS"></a>十一、CAS</h2><h3 id="1、没有CAS之前"><a href="#1、没有CAS之前" class="headerlink" title="1、没有CAS之前"></a>1、没有CAS之前</h3><h4 id="1、多线程环境不使用原子类保证线程安全（基本数据类型）"><a href="#1、多线程环境不使用原子类保证线程安全（基本数据类型）" class="headerlink" title="1、多线程环境不使用原子类保证线程安全（基本数据类型）"></a>1、多线程环境不使用原子类保证线程安全（基本数据类型）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">T3</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//读取</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumber</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//写入加锁保证原子性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">setNumber</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        number++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、多线程环境-使用原子类保证线程安全（基本数据类型）"><a href="#2、多线程环境-使用原子类保证线程安全（基本数据类型）" class="headerlink" title="2、多线程环境    使用原子类保证线程安全（基本数据类型）"></a>2、多线程环境    使用原子类保证线程安全（基本数据类型）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">T3</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//读取</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumber</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//写入加锁保证原子性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">setNumber</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        number++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//=================================</span></span><br><span class="line">    <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAtomicInteger</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> atomicInteger.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAtomicInteger</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        atomicInteger.getAndIncrement();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、CAS是什么"><a href="#2、CAS是什么" class="headerlink" title="2、CAS是什么"></a>2、CAS是什么</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">compare and swap的缩写，中文翻译成比较并交换,实现并发算法时常用到的一种技术。它包含三个操作数——内存位置、预期原值及更新值。</span><br><span class="line">执行CAS操作的时候，将内存位置的值与预期原值比较：</span><br><span class="line">如果相匹配，那么处理器会自动将该位置值更新为新值，</span><br><span class="line">如果不匹配，处理器不做任何操作，多个线程同时执行CAS操作只有一个会成功。 </span><br></pre></td></tr></table></figure><p>CAS有3个操作数，位置内存值V，旧的预期值A，要修改的更新值B。<br>当且仅当旧的预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做或重来</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210922211800641.png" alt="image-20210922211800641"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CAS是JDK提供的非阻塞原子性操作，它通过硬件保证了比较-更新的原子性。</span><br><span class="line">它是非阻塞的且自身原子性，也就是说这玩意效率更高且通过硬件保证，说明这玩意更可靠。</span><br><span class="line"> </span><br><span class="line">CAS是一条CPU的原子指令（cmpxchg指令），不会造成所谓的数据不一致问题，Unsafe提供的CAS方法（如compareAndSwapXXX）底层实现即为CPU指令cmpxchg。</span><br><span class="line">执行cmpxchg指令的时候，会判断当前系统是否为多核系统，如果是就给总线加锁，只有一个线程会对总线加锁成功，加锁成功之后会执行cas操作，也就是说CAS的原子性实际上是CPU实现的， 其实在这一点上还是有排他锁的，只是比起用<span class="keyword">synchronized</span>， 这里的排他时间要短的多， 所以在多线程情况下性能会比较好</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CASDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(<span class="number">5</span>, <span class="number">2020</span>)+<span class="string">&quot;\t&quot;</span>+atomicInteger.get());</span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(<span class="number">5</span>, <span class="number">1024</span>)+<span class="string">&quot;\t&quot;</span>+atomicInteger.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1、源码分析compareAndSet-int-expect-int-update"><a href="#1、源码分析compareAndSet-int-expect-int-update" class="headerlink" title="1、源码分析compareAndSet(int expect,int update)"></a>1、源码分析compareAndSet(int expect,int update)</h4><p>compareAndSet()方法的源代码：</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210922211916954.png" alt="image-20210922211916954"></p><p>上面三个方法都是类似的，主要对4个参数做一下说明。<br>var1：表示要操作的对象<br>var2：表示要操作对象中属性地址的偏移量<br>var4：表示需要修改数据的期望的值<br>var5&#x2F;var6：表示需要修改为的新值</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210922211925337.png" alt="image-20210922211925337"></p><h3 id="3、CAS底层原理？如果知道，谈谈你对UnSafe的理解"><a href="#3、CAS底层原理？如果知道，谈谈你对UnSafe的理解" class="headerlink" title="3、CAS底层原理？如果知道，谈谈你对UnSafe的理解"></a>3、CAS底层原理？如果知道，谈谈你对UnSafe的理解</h3><h4 id="1、UnSafe"><a href="#1、UnSafe" class="headerlink" title="1、UnSafe"></a>1、UnSafe</h4><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210922212018603.png" alt="image-20210922212018603"></p><ol><li><p>Unsafe<br>   是CAS的核心类，由于Java方法无法直接访问底层系统，需要通过本地（native）方法来访问，Unsafe相当于一个后门，基于该类可以直接操作特定内存的数据。Unsafe类存在于sun.misc包中，其内部方法操作可以像C的指针一样直接操作内存，因为Java中CAS操作的执行依赖于Unsafe类的方法。<br>注意Unsafe类中的所有方法都是native修饰的，也就是说Unsafe类中的方法都直接调用操作系统底层资源执行相应任务 </p></li><li><p>变量valueOffset，表示该变量值在内存中的偏移地址，因为Unsafe就是根据内存偏移地址获取数据的。</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210922212041394.png" alt="image-20210922212041394"></p><ol start="3"><li>变量value用volatile修饰，保证了多线程之间的内存可见性。</li></ol><h4 id="2、我们知道i-线程不安全的，那atomicInteger-getAndIncrement"><a href="#2、我们知道i-线程不安全的，那atomicInteger-getAndIncrement" class="headerlink" title="2、我们知道i++线程不安全的，那atomicInteger.getAndIncrement()"></a>2、我们知道i++线程不安全的，那atomicInteger.getAndIncrement()</h4><p>CAS的全称为Compare-And-Swap，它是一条CPU并发原语。<br>它的功能是判断内存某个位置的值是否为预期值，如果是则更改为新的值，这个过程是原子的。<br>AtomicInteger 类主要利用 CAS (compare and swap) + volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210922212208816.png" alt="image-20210922212208816"></p><p>new AtomicInteger().getAndIncrement();</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210922212236304.png" alt="image-20210922212236304"></p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210922212248701.png" alt="image-20210922212248701"></p><p>假设线程A和线程B两个线程同时执行getAndAddInt操作（分别跑在不同CPU上）：</p><ol><li><p>AtomicInteger里面的value原始值为3，即主内存中AtomicInteger的value为3，根据JMM模型，线程A和线程B各自持有一份值为3的value的副本分别到各自的工作内存。</p></li><li><p>线程A通过getIntVolatile(var1, var2)拿到value值3，这时线程A被挂起。</p></li><li><p>线程B也通过getIntVolatile(var1, var2)方法获取到value值3，此时刚好线程B没有被挂起并执行compareAndSwapInt方法比较内存值也为3，成功修改内存值为4，线程B打完收工，一切OK。</p></li><li><p>这时线程A恢复，执行compareAndSwapInt方法比较，发现自己手里的值数字3和主内存的值数字4不一致，说明该值已经被其它线程抢先一步修改过了，那A线程本次修改失败，只能重新读取重新来一遍了。</p></li><li><p>线程A重新获取value值，因为变量value被volatile修饰，所以其它线程对它的修改，线程A总是能够看到，线程A继续执行compareAndSwapInt进行比较替换，直到成功。</p></li></ol><h4 id="3、底层汇编"><a href="#3、底层汇编" class="headerlink" title="3、底层汇编"></a>3、底层汇编</h4><p>native修饰的方法代表是底层方法</p><p>Unsafe类中的compareAndSwapInt，是一个本地方法，该方法的实现位于unsafe.cpp中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))</span><br><span class="line">  UnsafeWrapper(<span class="string">&quot;Unsafe_CompareAndSwapInt&quot;</span>);</span><br><span class="line">  oop p = JNIHandles::resolve(obj);</span><br><span class="line"><span class="comment">// 先想办法拿到变量value在内存中的地址，根据偏移量valueOffset，计算 value 的地址</span></span><br><span class="line">  jint* addr = (jint *) index_oop_from_field_offset_long(p, offset);</span><br><span class="line"><span class="comment">// 调用 Atomic 中的函数 cmpxchg来进行比较交换，其中参数x是即将更新的值，参数e是原内存的值</span></span><br><span class="line">  <span class="keyword">return</span> (jint)(Atomic::cmpxchg(x, addr, e)) == e;</span><br><span class="line">UNSAFE_END</span><br></pre></td></tr></table></figure><p>(Atomic::cmpxchg(x, addr, e)) &#x3D;&#x3D; e;</p><p>cmpxchg</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用 Atomic 中的函数 cmpxchg来进行比较交换，其中参数x是即将更新的值，参数e是原内存的值</span></span><br><span class="line">  <span class="keyword">return</span> (jint)(Atomic::cmpxchg(x, addr, e)) == e;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">Atomic::cmpxchg</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> exchange_value,<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span>* dest, <span class="type">unsigned</span> <span class="type">int</span> compare_value)</span> &#123;</span><br><span class="line">    assert(<span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">int</span>) == <span class="keyword">sizeof</span>(jint), <span class="string">&quot;more work to do&quot;</span>);</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 根据操作系统类型调用不同平台下的重载函数，这个在预编译期间编译器会决定调用哪个平台下的重载函数*/</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">int</span>)Atomic::cmpxchg((jint)exchange_value, (<span class="keyword">volatile</span> jint*)dest, (jint)compare_value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在不同的操作系统下会调用不同的cmpxchg重载函数，本次用的是win10系统</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> jint <span class="title function_">Atomic::cmpxchg</span> <span class="params">(jint exchange_value, <span class="keyword">volatile</span> jint* dest, jint compare_value)</span> &#123;</span><br><span class="line">  <span class="comment">//判断是否是多核CPU</span></span><br><span class="line">  <span class="type">int</span> mp = os::is_MP();</span><br><span class="line">  __asm &#123;</span><br><span class="line">    <span class="comment">//三个move指令表示的是将后面的值移动到前面的寄存器上</span></span><br><span class="line">    mov edx, dest</span><br><span class="line">    mov ecx, exchange_value</span><br><span class="line">    mov eax, compare_value</span><br><span class="line">    <span class="comment">//CPU原语级别，CPU触发</span></span><br><span class="line">    LOCK_IF_MP(mp)</span><br><span class="line">    <span class="comment">//比较并交换指令</span></span><br><span class="line">    <span class="comment">//cmpxchg: 即“比较并交换”指令</span></span><br><span class="line">    <span class="comment">//dword: 全称是 double word 表示两个字，一共四个字节</span></span><br><span class="line">    <span class="comment">//ptr: 全称是 pointer，与前面的 dword 连起来使用，表明访问的内存单元是一个双字单元 </span></span><br><span class="line">    <span class="comment">//将 eax 寄存器中的值（compare_value）与 [edx] 双字内存单元中的值进行对比，</span></span><br><span class="line">    <span class="comment">//如果相同，则将 ecx 寄存器中的值（exchange_value）存入 [edx] 内存单元中</span></span><br><span class="line">    cmpxchg dword ptr [edx], ecx</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里应该理解了CAS真正实现的机制了，它最终是由操作系统的汇编指令完成的。</p><h4 id="4、总结-2"><a href="#4、总结-2" class="headerlink" title="4、总结"></a>4、总结</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">你只需要记住：CAS是靠硬件实现的从而在硬件层面提升效率，最底层还是交给硬件来保证原子性和可见性</span><br><span class="line">实现方式是基于硬件平台的汇编指令，在intel的CPU中(X86机器上)，使用的是汇编指令cmpxchg指令。 </span><br><span class="line"> </span><br><span class="line">核心思想就是：比较要更新变量的值V和预期值E（compare），相等才会将V的值设为新值N（swap）如果不相等自旋再来。</span><br></pre></td></tr></table></figure><h3 id="4、原子引用"><a href="#4、原子引用" class="headerlink" title="4、原子引用"></a>4、原子引用</h3><p>AtomicInteger原子整型，可否有其它原子类型？</p><ul><li>AtomicBook</li><li>AtomicOrder</li><li>。。。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span></span><br><span class="line">&#123;</span><br><span class="line">    String userName;</span><br><span class="line">    <span class="type">int</span>    age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@auther</span> zzyy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2018-12-31 17:22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicReferenceDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">z3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;z3&quot;</span>,<span class="number">24</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">li4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;li4&quot;</span>,<span class="number">26</span>);</span><br><span class="line"></span><br><span class="line">        AtomicReference&lt;User&gt; atomicReferenceUser = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        atomicReferenceUser.set(z3);</span><br><span class="line">        System.out.println(atomicReferenceUser.compareAndSet(z3,li4)+<span class="string">&quot;\t&quot;</span>+atomicReferenceUser.get().toString());</span><br><span class="line">        System.out.println(atomicReferenceUser.compareAndSet(z3,li4)+<span class="string">&quot;\t&quot;</span>+atomicReferenceUser.get().toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5、自旋锁，借鉴CAS思想"><a href="#5、自旋锁，借鉴CAS思想" class="headerlink" title="5、自旋锁，借鉴CAS思想"></a>5、自旋锁，借鉴CAS思想</h3><p>自旋锁（spinlock）</p><p>是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，<br>当线程发现锁被占用时，会不断循环判断锁的状态，直到获取。这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210922212914003.png" alt="image-20210922212914003"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题目：实现一个自旋锁</span></span><br><span class="line"><span class="comment"> * 自旋锁好处：循环比较获取没有类似wait的阻塞。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 通过CAS操作完成自旋锁，A线程先进来调用myLock方法自己持有锁5秒钟，B随后进来后发现</span></span><br><span class="line"><span class="comment"> * 当前有线程持有锁，不是null，所以只能通过自旋等待，直到A释放锁后B随后抢到。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpinLockDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    AtomicReference&lt;Thread&gt; atomicReference = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myLock</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t come in&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(!atomicReference.compareAndSet(<span class="literal">null</span>,thread))</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myUnLock</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        atomicReference.compareAndSet(thread,<span class="literal">null</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t myUnLock over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">SpinLockDemo</span> <span class="variable">spinLockDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpinLockDemo</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            spinLockDemo.myLock();</span><br><span class="line">            <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep( <span class="number">5</span> ); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            spinLockDemo.myUnLock();</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//暂停一会儿线程，保证A线程先于B线程启动并完成</span></span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep( <span class="number">1</span> ); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            spinLockDemo.myLock();</span><br><span class="line">            spinLockDemo.myUnLock();</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6、CAS缺点"><a href="#6、CAS缺点" class="headerlink" title="6、CAS缺点"></a>6、CAS缺点</h3><h4 id="1、循环时间长开销很大"><a href="#1、循环时间长开销很大" class="headerlink" title="1、循环时间长开销很大"></a>1、循环时间长开销很大</h4><p>我们可以看到getAndAddInt方法执行时，有个do while</p><p><img src="/images/1.JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20210922213308155.png" alt="image-20210922213308155"></p><p>如果CAS失败，会一直进行尝试。如果CAS长时间一直不成功，可能会给CPU带来很大的开销。</p><h4 id="2、引出来ABA问题？？？"><a href="#2、引出来ABA问题？？？" class="headerlink" title="2、引出来ABA问题？？？"></a>2、引出来ABA问题？？？</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CAS会导致“ABA问题”。</span><br><span class="line"> </span><br><span class="line">CAS算法实现一个重要前提需要取出内存中某时刻的数据并在当下时刻比较并替换，那么在这个时间差类会导致数据的变化。</span><br><span class="line"> </span><br><span class="line">比如说一个线程one从内存位置V中取出A，这时候另一个线程two也从内存中取出A，并且线程two进行了一些操作将值变成了B，</span><br><span class="line">然后线程two又将V位置的数据变成A，这时候线程one进行CAS操作发现内存中仍然是A，然后线程one操作成功。</span><br><span class="line"> </span><br><span class="line">尽管线程one的CAS操作成功，但是不代表这个过程就是没有问题的。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ABADemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="type">AtomicStampedReference</span> <span class="variable">atomicStampedReference</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicStampedReference</span>(<span class="number">100</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            atomicInteger.compareAndSet(<span class="number">100</span>,<span class="number">101</span>);</span><br><span class="line">            atomicInteger.compareAndSet(<span class="number">101</span>,<span class="number">100</span>);</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">//暂停一会儿线程</span></span><br><span class="line">            <span class="keyword">try</span> &#123; Thread.sleep( <span class="number">500</span> ); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;;            System.out.println(atomicInteger.compareAndSet(<span class="number">100</span>, <span class="number">2019</span>)+<span class="string">&quot;\t&quot;</span>+atomicInteger.get());</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//暂停一会儿线程,main彻底等待上面的ABA出现演示完成。</span></span><br><span class="line">        <span class="keyword">try</span> &#123; Thread.sleep( <span class="number">2000</span> ); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;============以下是ABA问题的解决=============================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">stamp</span> <span class="operator">=</span> atomicStampedReference.getStamp();</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t 首次版本号:&quot;</span>+stamp);<span class="comment">//1</span></span><br><span class="line">            <span class="comment">//暂停一会儿线程,</span></span><br><span class="line">            <span class="keyword">try</span> &#123; Thread.sleep( <span class="number">1000</span> ); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            atomicStampedReference.compareAndSet(<span class="number">100</span>,<span class="number">101</span>,atomicStampedReference.getStamp(),atomicStampedReference.getStamp()+<span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t 2次版本号:&quot;</span>+atomicStampedReference.getStamp());</span><br><span class="line">            atomicStampedReference.compareAndSet(<span class="number">101</span>,<span class="number">100</span>,atomicStampedReference.getStamp(),atomicStampedReference.getStamp()+<span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t 3次版本号:&quot;</span>+atomicStampedReference.getStamp());</span><br><span class="line">        &#125;,<span class="string">&quot;t3&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">stamp</span> <span class="operator">=</span> atomicStampedReference.getStamp();</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t 首次版本号:&quot;</span>+stamp);<span class="comment">//1</span></span><br><span class="line">            <span class="comment">//暂停一会儿线程，获得初始值100和初始版本号1，故意暂停3秒钟让t3线程完成一次ABA操作产生问题</span></span><br><span class="line">            <span class="keyword">try</span> &#123; Thread.sleep( <span class="number">3000</span> ); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> atomicStampedReference.compareAndSet(<span class="number">100</span>,<span class="number">2019</span>,stamp,stamp+<span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+result+<span class="string">&quot;\t&quot;</span>+atomicStampedReference.getReference());</span><br><span class="line">        &#125;,<span class="string">&quot;t4&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="十二、原子操作类之18罗汉增强"><a href="#十二、原子操作类之18罗汉增强" class="headerlink" title="十二、原子操作类之18罗汉增强"></a>十二、原子操作类之18罗汉增强</h2><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210922213530641.png" alt="image-20210922213530641"></p><ol><li>AtomicBoolean</li><li>AtomicInteger</li><li>AtomicIntegerArray</li><li>AtomicIntegerFieldUpdater</li><li>AtomicLong</li><li>AtomicLongArray</li><li>AtomicLongFieldUpdater</li><li>AtomicMarkableReference</li><li>AtomicReference</li><li>AtomicReferenceArray</li><li>AtomicReferenceFieldUpdater</li><li>AtomicStampedReference</li><li>DoubleAccumulator</li><li>DoubleAdder</li><li>LongAccumulator</li><li>LongAdder</li></ol><h3 id="1、基本类型原子类"><a href="#1、基本类型原子类" class="headerlink" title="1、基本类型原子类"></a>1、基本类型原子类</h3><ul><li>AtomicInteger</li><li>AtomicBoolean</li><li>AtomicLong</li></ul><h4 id="1、常用API简介"><a href="#1、常用API简介" class="headerlink" title="1、常用API简介"></a>1、常用API简介</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> <span class="comment">//获取当前的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndSet</span><span class="params">(<span class="type">int</span> newValue)</span><span class="comment">//获取当前的值，并设置新的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">()</span><span class="comment">//获取当前的值，并自增</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndDecrement</span><span class="params">()</span> <span class="comment">//获取当前的值，并自减</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAdd</span><span class="params">(<span class="type">int</span> delta)</span> <span class="comment">//获取当前的值，并加上预期的值</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> <span class="comment">//如果输入的数值等于预期值，则以原子方式将该值设置为输入值（update）</span></span><br></pre></td></tr></table></figure><h4 id="2、tsleep→countDownLatch"><a href="#2、tsleep→countDownLatch" class="headerlink" title="2、tsleep→countDownLatch"></a>2、tsleep→countDownLatch</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyNumber</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addPlusPlus</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        atomicInteger.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-07-03 17:16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicIntegerDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">MyNumber</span> <span class="variable">myNumber</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyNumber</span>();</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;=<span class="number">5000</span>; j++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        myNumber.addPlusPlus();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        countDownLatch.await();</span><br><span class="line"></span><br><span class="line">        System.out.println(myNumber.getAtomicInteger().get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、数组类型原子类"><a href="#2、数组类型原子类" class="headerlink" title="2、数组类型原子类"></a>2、数组类型原子类</h3><ul><li>AtomicIntegerArray</li><li>AtomicLongArray</li><li>AtomicReferenceArray</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicIntegerArrayDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">AtomicIntegerArray</span> <span class="variable">atomicIntegerArray</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicIntegerArray</span>(<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>]);</span><br><span class="line">        <span class="comment">//AtomicIntegerArray atomicIntegerArray = new AtomicIntegerArray(5);</span></span><br><span class="line">        <span class="comment">//AtomicIntegerArray atomicIntegerArray = new AtomicIntegerArray(new int[]&#123;1,2,3,4,5&#125;);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;atomicIntegerArray.length(); i++) &#123;</span><br><span class="line">            System.out.println(atomicIntegerArray.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmpInt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        tmpInt = atomicIntegerArray.getAndSet(<span class="number">0</span>,<span class="number">1122</span>);</span><br><span class="line">        System.out.println(tmpInt+<span class="string">&quot;\t&quot;</span>+atomicIntegerArray.get(<span class="number">0</span>));</span><br><span class="line">        atomicIntegerArray.getAndIncrement(<span class="number">1</span>);</span><br><span class="line">        atomicIntegerArray.getAndIncrement(<span class="number">1</span>);</span><br><span class="line">        tmpInt = atomicIntegerArray.getAndIncrement(<span class="number">1</span>);</span><br><span class="line">        System.out.println(tmpInt+<span class="string">&quot;\t&quot;</span>+atomicIntegerArray.get(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、引用类型原子类"><a href="#3、引用类型原子类" class="headerlink" title="3、引用类型原子类"></a>3、引用类型原子类</h3><ul><li>AtomicReference</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span></span><br><span class="line">&#123;</span><br><span class="line">    String userName;</span><br><span class="line">    <span class="type">int</span>    age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicReferenceDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">z3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;z3&quot;</span>,<span class="number">24</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">li4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;li4&quot;</span>,<span class="number">26</span>);</span><br><span class="line"></span><br><span class="line">        AtomicReference&lt;User&gt; atomicReferenceUser = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        atomicReferenceUser.set(z3);</span><br><span class="line">        System.out.println(atomicReferenceUser.compareAndSet(z3,li4)+<span class="string">&quot;\t&quot;</span>+atomicReferenceUser.get().toString());</span><br><span class="line">        System.out.println(atomicReferenceUser.compareAndSet(z3,li4)+<span class="string">&quot;\t&quot;</span>+atomicReferenceUser.get().toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自旋锁SpinLockDemo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题目：实现一个自旋锁</span></span><br><span class="line"><span class="comment"> * 自旋锁好处：循环比较获取没有类似wait的阻塞。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 通过CAS操作完成自旋锁，A线程先进来调用myLock方法自己持有锁5秒钟，B随后进来后发现</span></span><br><span class="line"><span class="comment"> * 当前有线程持有锁，不是null，所以只能通过自旋等待，直到A释放锁后B随后抢到。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpinLockDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    AtomicReference&lt;Thread&gt; atomicReference = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myLock</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t come in&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(!atomicReference.compareAndSet(<span class="literal">null</span>,thread))</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myUnLock</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        atomicReference.compareAndSet(thread,<span class="literal">null</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t myUnLock over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">SpinLockDemo</span> <span class="variable">spinLockDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpinLockDemo</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            spinLockDemo.myLock();</span><br><span class="line">            <span class="comment">//暂停一会儿线程</span></span><br><span class="line">            <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep( <span class="number">5</span> ); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            spinLockDemo.myUnLock();</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="comment">//暂停一会儿线程，保证A线程先于B线程启动并完成</span></span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep( <span class="number">1</span> ); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            spinLockDemo.myLock();</span><br><span class="line">            spinLockDemo.myUnLock();</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>AtomicStampedReference<ul><li>携带版本号的引用类型原子类，可以解决ABA问题</li><li>解决修改过几次</li><li>状态戳原子引用</li></ul></li></ul><p>ABADemo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ABADemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="type">AtomicStampedReference</span> <span class="variable">atomicStampedReference</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicStampedReference</span>(<span class="number">100</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        abaProblem();</span><br><span class="line">        abaResolve();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">abaResolve</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">stamp</span> <span class="operator">=</span> atomicStampedReference.getStamp();</span><br><span class="line">            System.out.println(<span class="string">&quot;t3 ----第1次stamp  &quot;</span>+stamp);</span><br><span class="line">            <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">1</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            atomicStampedReference.compareAndSet(<span class="number">100</span>,<span class="number">101</span>,stamp,stamp+<span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;t3 ----第2次stamp  &quot;</span>+atomicStampedReference.getStamp());</span><br><span class="line">            atomicStampedReference.compareAndSet(<span class="number">101</span>,<span class="number">100</span>,atomicStampedReference.getStamp(),atomicStampedReference.getStamp()+<span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;t3 ----第3次stamp  &quot;</span>+atomicStampedReference.getStamp());</span><br><span class="line">        &#125;,<span class="string">&quot;t3&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">stamp</span> <span class="operator">=</span> atomicStampedReference.getStamp();</span><br><span class="line">            System.out.println(<span class="string">&quot;t4 ----第1次stamp  &quot;</span>+stamp);</span><br><span class="line">            <span class="comment">//暂停几秒钟线程</span></span><br><span class="line">            <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">3</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> atomicStampedReference.compareAndSet(<span class="number">100</span>, <span class="number">20210308</span>, stamp, stamp + <span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+result+<span class="string">&quot;\t&quot;</span>+atomicStampedReference.getReference());</span><br><span class="line">        &#125;,<span class="string">&quot;t4&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">abaProblem</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            atomicInteger.compareAndSet(<span class="number">100</span>,<span class="number">101</span>);</span><br><span class="line">            atomicInteger.compareAndSet(<span class="number">101</span>,<span class="number">100</span>);</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.MILLISECONDS.sleep(<span class="number">200</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            atomicInteger.compareAndSet(<span class="number">100</span>,<span class="number">20210308</span>);</span><br><span class="line">            System.out.println(atomicInteger.get());</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>AtomicMarkableReference<ul><li>原子更新带有标记位的引用类型对象</li><li>解决是否修改过 它的定义就是将状态戳简化为true|false – 类似一次性筷子</li></ul></li></ul><p>状态戳(true&#x2F;false)原子引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ABADemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">static</span> AtomicStampedReference&lt;Integer&gt; stampedReference = <span class="keyword">new</span> <span class="title class_">AtomicStampedReference</span>&lt;&gt;(<span class="number">100</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">static</span> AtomicMarkableReference&lt;Integer&gt; markableReference = <span class="keyword">new</span> <span class="title class_">AtomicMarkableReference</span>&lt;&gt;(<span class="number">100</span>,<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            atomicInteger.compareAndSet(<span class="number">100</span>,<span class="number">101</span>);</span><br><span class="line">            atomicInteger.compareAndSet(<span class="number">101</span>,<span class="number">100</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;update ok&quot;</span>);</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">//暂停几秒钟线程</span></span><br><span class="line">            <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">1</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            atomicInteger.compareAndSet(<span class="number">100</span>,<span class="number">2020</span>);</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//暂停几秒钟线程</span></span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">2</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(atomicInteger.get());</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;============以下是ABA问题的解决,让我们知道引用变量中途被更改了几次=========================&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t 1次版本号&quot;</span>+stampedReference.getStamp());</span><br><span class="line">            <span class="comment">//故意暂停200毫秒，让后面的t4线程拿到和t3一样的版本号</span></span><br><span class="line">            <span class="keyword">try</span> &#123; TimeUnit.MILLISECONDS.sleep(<span class="number">200</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line"></span><br><span class="line">            stampedReference.compareAndSet(<span class="number">100</span>,<span class="number">101</span>,stampedReference.getStamp(),stampedReference.getStamp()+<span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t 2次版本号&quot;</span>+stampedReference.getStamp());</span><br><span class="line">            stampedReference.compareAndSet(<span class="number">101</span>,<span class="number">100</span>,stampedReference.getStamp(),stampedReference.getStamp()+<span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t 3次版本号&quot;</span>+stampedReference.getStamp());</span><br><span class="line">        &#125;,<span class="string">&quot;t3&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">stamp</span> <span class="operator">=</span> stampedReference.getStamp();</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t =======1次版本号&quot;</span>+stamp);</span><br><span class="line">            <span class="comment">//暂停2秒钟,让t3先完成ABA操作了，看看自己还能否修改</span></span><br><span class="line">            <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">2</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> stampedReference.compareAndSet(<span class="number">100</span>, <span class="number">2020</span>, stamp, stamp + <span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t=======2次版本号&quot;</span>+stampedReference.getStamp()+<span class="string">&quot;\t&quot;</span>+stampedReference.getReference());</span><br><span class="line">        &#125;,<span class="string">&quot;t4&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;============AtomicMarkableReference不关心引用变量更改过几次，只关心是否更改过======================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">marked</span> <span class="operator">=</span> markableReference.isMarked();</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t 1次版本号&quot;</span>+marked);</span><br><span class="line">            <span class="keyword">try</span> &#123; TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            markableReference.compareAndSet(<span class="number">100</span>,<span class="number">101</span>,marked,!marked);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t 2次版本号&quot;</span>+markableReference.isMarked());</span><br><span class="line">            markableReference.compareAndSet(<span class="number">101</span>,<span class="number">100</span>,markableReference.isMarked(),!markableReference.isMarked());</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t 3次版本号&quot;</span>+markableReference.isMarked());</span><br><span class="line">        &#125;,<span class="string">&quot;t5&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">marked</span> <span class="operator">=</span> markableReference.isMarked();</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t 1次版本号&quot;</span>+marked);</span><br><span class="line">            <span class="comment">//暂停几秒钟线程</span></span><br><span class="line">            <span class="keyword">try</span> &#123; TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            markableReference.compareAndSet(<span class="number">100</span>,<span class="number">2020</span>,marked,!marked);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+markableReference.getReference()+<span class="string">&quot;\t&quot;</span>+markableReference.isMarked());</span><br><span class="line">        &#125;,<span class="string">&quot;t6&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、对象的属性修改原子类"><a href="#4、对象的属性修改原子类" class="headerlink" title="4、对象的属性修改原子类"></a>4、对象的属性修改原子类</h3><ul><li>AtomicIntegerFieldUpdater<ul><li>原子更新对象中int类型字段的值</li></ul></li><li>AtomicLongFieldUpdater<ul><li>原子更新对象中Long类型字段的值</li></ul></li><li>AtomicReferenceFieldUpdater<ul><li>原子更新引用类型字段的值</li></ul></li></ul><h4 id="1、使用目的"><a href="#1、使用目的" class="headerlink" title="1、使用目的"></a>1、使用目的</h4><p>以一种线程安全的方式操作非线程安全对象内的某些字段</p><h4 id="2、使用要求"><a href="#2、使用要求" class="headerlink" title="2、使用要求"></a>2、使用要求</h4><p>更新的对象属性必须使用 public volatile 修饰符。</p><p>因为对象的属性修改类型原子类都是抽象类，所以每次使用都必须使用静态方法newUpdater()创建一个更新器，并且需要设置想要更新的类和属性。</p><h4 id="3、AtomicIntegerFieldUpdaterDemo"><a href="#3、AtomicIntegerFieldUpdaterDemo" class="headerlink" title="3、AtomicIntegerFieldUpdaterDemo"></a>3、AtomicIntegerFieldUpdaterDemo</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BankAccount</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">bankName</span> <span class="operator">=</span> <span class="string">&quot;CCB&quot;</span>;<span class="comment">//银行</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">money</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//钱数</span></span><br><span class="line">    AtomicIntegerFieldUpdater&lt;BankAccount&gt; accountAtomicIntegerFieldUpdater = AtomicIntegerFieldUpdater.newUpdater(BankAccount.class,<span class="string">&quot;money&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不加锁+性能高，局部微创</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transferMoney</span><span class="params">(BankAccount bankAccount)</span></span><br><span class="line">    &#123;</span><br><span class="line">        accountAtomicIntegerFieldUpdater.incrementAndGet(bankAccount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@auther</span> zzyy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-07-14 18:06</span></span><br><span class="line"><span class="comment"> * 以一种线程安全的方式操作非线程安全对象的某些字段。</span></span><br><span class="line"><span class="comment"> * 需求：</span></span><br><span class="line"><span class="comment"> * 1000个人同时向一个账号转账一元钱，那么累计应该增加1000元，</span></span><br><span class="line"><span class="comment"> * 除了synchronized和CAS,还可以使用AtomicIntegerFieldUpdater来实现。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicIntegerFieldUpdaterDemo</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">BankAccount</span> <span class="variable">bankAccount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BankAccount</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">1000</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">finalI</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                bankAccount.transferMoney(bankAccount);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//暂停毫秒</span></span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(bankAccount.money);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、AtomicReferenceFieldUpdater"><a href="#4、AtomicReferenceFieldUpdater" class="headerlink" title="4、AtomicReferenceFieldUpdater"></a>4、AtomicReferenceFieldUpdater</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyVar</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="type">Boolean</span> <span class="variable">isInit</span> <span class="operator">=</span> Boolean.FALSE;</span><br><span class="line">    AtomicReferenceFieldUpdater&lt;MyVar,Boolean&gt; atomicReferenceFieldUpdater = AtomicReferenceFieldUpdater.newUpdater(MyVar.class,Boolean.class,<span class="string">&quot;isInit&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(MyVar myVar)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(atomicReferenceFieldUpdater.compareAndSet(myVar,Boolean.FALSE,Boolean.TRUE))</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;---init.....&quot;</span>);</span><br><span class="line">            <span class="comment">//暂停几秒钟线程</span></span><br><span class="line">            <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">2</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;---init.....over&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;------其它线程正在初始化&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 多线程并发调用一个类的初始化方法，如果未被初始化过，将执行初始化工作，要求只能初始化一次</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicIntegerFieldUpdaterDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">MyVar</span> <span class="variable">myVar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyVar</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                myVar.init(myVar);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5、你在哪里用了volatile"><a href="#5、你在哪里用了volatile" class="headerlink" title="5、你在哪里用了volatile"></a>5、你在哪里用了volatile</h3><p>AtomicReferenceFieldUpdater</p><h3 id="6、原子操作增强类原理深度解析"><a href="#6、原子操作增强类原理深度解析" class="headerlink" title="6、原子操作增强类原理深度解析"></a>6、原子操作增强类原理深度解析</h3><ul><li>DoubleAccumulator</li><li>DoubleAdder</li><li>LongAccumulator</li><li>LongAdder</li></ul><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210925210537531.png" alt="image-20210925210537531"></p><h4 id="1、点赞计数器，看看性能"><a href="#1、点赞计数器，看看性能" class="headerlink" title="1、点赞计数器，看看性能"></a>1、点赞计数器，看看性能</h4><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210925210601595.png" alt="image-20210925210601595"></p><p>LongAdder只能用来计算加法，且从零开始计算</p><p>LongAccumulator提供了自定义的函数操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//long类型的聚合器，需要传入一个long类型的二元操作，可以用来计算各种聚合操作，包括加乘等</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.LongAccumulator;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.LongAdder;</span><br><span class="line"><span class="keyword">import</span> java.util.function.LongBinaryOperator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LongAccumulatorDemo</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">LongAdder</span> <span class="variable">longAdder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LongAdder</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add_LongAdder</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        longAdder.increment();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//LongAccumulator longAccumulator = new LongAccumulator((x, y) -&gt; x + y,0);</span></span><br><span class="line">    <span class="type">LongAccumulator</span> <span class="variable">longAccumulator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LongAccumulator</span>(<span class="keyword">new</span> <span class="title class_">LongBinaryOperator</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">applyAsLong</span><span class="params">(<span class="type">long</span> left, <span class="type">long</span> right)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> left - right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="number">777</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add_LongAccumulator</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        longAccumulator.accumulate(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">LongAccumulatorDemo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LongAccumulatorDemo</span>();</span><br><span class="line"></span><br><span class="line">        demo.add_LongAccumulator();</span><br><span class="line">        demo.add_LongAccumulator();</span><br><span class="line">        System.out.println(demo.longAccumulator.longValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、LongAdderAPIDemo"><a href="#2、LongAdderAPIDemo" class="headerlink" title="2、LongAdderAPIDemo"></a>2、LongAdderAPIDemo</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LongAdderAPIDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">LongAdder</span> <span class="variable">longAdder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LongAdder</span>();</span><br><span class="line"></span><br><span class="line">        longAdder.increment();</span><br><span class="line">        longAdder.increment();</span><br><span class="line">        longAdder.increment();</span><br><span class="line"></span><br><span class="line">        System.out.println(longAdder.longValue());</span><br><span class="line"></span><br><span class="line">        <span class="type">LongAccumulator</span> <span class="variable">longAccumulator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LongAccumulator</span>((x,y) -&gt; x * y,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        longAccumulator.accumulate(<span class="number">1</span>);</span><br><span class="line">        longAccumulator.accumulate(<span class="number">2</span>);</span><br><span class="line">        longAccumulator.accumulate(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(longAccumulator.longValue());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、LongAdder高性能对比Code演示"><a href="#3、LongAdder高性能对比Code演示" class="headerlink" title="3、LongAdder高性能对比Code演示"></a>3、LongAdder高性能对比Code演示</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClickNumberNet</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">clickBySync</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        number++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">AtomicLong</span> <span class="variable">atomicLong</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clickByAtomicLong</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        atomicLong.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">LongAdder</span> <span class="variable">longAdder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LongAdder</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clickByLongAdder</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        longAdder.increment();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">LongAccumulator</span> <span class="variable">longAccumulator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LongAccumulator</span>((x,y) -&gt; x + y,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clickByLongAccumulator</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        longAccumulator.accumulate(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@auther</span> zzyy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-05-21 22:23</span></span><br><span class="line"><span class="comment"> * 50个线程，每个线程100W次，总点赞数出来</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LongAdderDemo2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">ClickNumberNet</span> <span class="variable">clickNumberNet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClickNumberNet</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> startTime;</span><br><span class="line">        <span class="type">long</span> endTime;</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">50</span>);</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">50</span>);</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">50</span>);</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">50</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;=<span class="number">100</span> * <span class="number">10000</span>; j++) &#123;</span><br><span class="line">                        clickNumberNet.clickBySync();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;----costTime: &quot;</span>+(endTime - startTime) +<span class="string">&quot; 毫秒&quot;</span>+<span class="string">&quot;\t clickBySync result: &quot;</span>+clickNumberNet.number);</span><br><span class="line"></span><br><span class="line">        startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">50</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;=<span class="number">100</span> * <span class="number">10000</span>; j++) &#123;</span><br><span class="line">                        clickNumberNet.clickByAtomicLong();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    countDownLatch2.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch2.await();</span><br><span class="line">        endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;----costTime: &quot;</span>+(endTime - startTime) +<span class="string">&quot; 毫秒&quot;</span>+<span class="string">&quot;\t clickByAtomicLong result: &quot;</span>+clickNumberNet.atomicLong);</span><br><span class="line"></span><br><span class="line">        startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">50</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;=<span class="number">100</span> * <span class="number">10000</span>; j++) &#123;</span><br><span class="line">                        clickNumberNet.clickByLongAdder();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    countDownLatch3.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch3.await();</span><br><span class="line">        endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;----costTime: &quot;</span>+(endTime - startTime) +<span class="string">&quot; 毫秒&quot;</span>+<span class="string">&quot;\t clickByLongAdder result: &quot;</span>+clickNumberNet.longAdder.sum());</span><br><span class="line"></span><br><span class="line">        startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">50</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;=<span class="number">100</span> * <span class="number">10000</span>; j++) &#123;</span><br><span class="line">                        clickNumberNet.clickByLongAccumulator();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    countDownLatch4.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch4.await();</span><br><span class="line">        endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;----costTime: &quot;</span>+(endTime - startTime) +<span class="string">&quot; 毫秒&quot;</span>+<span class="string">&quot;\t clickByLongAccumulator result: &quot;</span>+clickNumberNet.longAccumulator.longValue());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210925210808233.png" alt="image-20210925210808233"></p><h4 id="4、源码、原理分析"><a href="#4、源码、原理分析" class="headerlink" title="4、源码、原理分析"></a>4、源码、原理分析</h4><h5 id="1、架构"><a href="#1、架构" class="headerlink" title="1、架构"></a>1、架构</h5><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210925211148889.png" alt="image-20210925211148889"></p><p>LongAdder是Striped64的子类</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210925211209788.png" alt="image-20210925211209788"></p><h5 id="2、剩下两罗汉"><a href="#2、剩下两罗汉" class="headerlink" title="2、剩下两罗汉"></a>2、剩下两罗汉</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Striped64</span><br><span class="line">Number</span><br></pre></td></tr></table></figure><h5 id="3、原理-LongAdder为什么这么快"><a href="#3、原理-LongAdder为什么这么快" class="headerlink" title="3、原理(LongAdder为什么这么快)"></a>3、原理(LongAdder为什么这么快)</h5><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210925211404913.png" alt="image-20210925211404913"></p><h6 id="1、Striped64有几个比较重要的成员函数"><a href="#1、Striped64有几个比较重要的成员函数" class="headerlink" title="1、Striped64有几个比较重要的成员函数"></a>1、Striped64有几个比较重要的成员函数</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Number of CPUS, to place bound on table size        CPU数量，即cells数组的最大长度 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NCPU</span> <span class="operator">=</span> Runtime.getRuntime().availableProcessors();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Table of cells. When non-null, size is a power of 2.</span></span><br><span class="line"><span class="comment">cells数组，为2的幂，2,4,8,16.....，方便以后位运算</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Cell[] cells;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**基础value值，当并发较低时，只累加该值主要用于没有竞争的情况，通过CAS更新。</span></span><br><span class="line"><span class="comment"> * Base value, used mainly when there is no contention, but also as</span></span><br><span class="line"><span class="comment"> * a fallback during table initialization races. Updated via CAS.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">long</span> base;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**创建或者扩容Cells数组时使用的自旋锁变量调整单元格大小（扩容），创建单元格时使用的锁。</span></span><br><span class="line"><span class="comment"> * Spinlock (locked via CAS) used when resizing and/or creating Cells. </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">int</span> cellsBusy;</span><br></pre></td></tr></table></figure><p>最重要的2个</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210925211458685.png" alt="image-20210925211458685"></p><h6 id="2、Striped64中一些变量或者方法的定义"><a href="#2、Striped64中一些变量或者方法的定义" class="headerlink" title="2、Striped64中一些变量或者方法的定义"></a>2、Striped64中一些变量或者方法的定义</h6><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210925211609167.png" alt="image-20210925211609167"></p><h6 id="3、Cell"><a href="#3、Cell" class="headerlink" title="3、Cell"></a>3、Cell</h6><p>是 java.util.concurrent.atomic 下 Striped64 的一个内部类</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210925211634587.png" alt="image-20210925211634587"></p><h6 id="4、LongAdder为什么这么快"><a href="#4、LongAdder为什么这么快" class="headerlink" title="4、LongAdder为什么这么快"></a>4、LongAdder为什么这么快</h6><p>​LongAdder的基本思路就是分散热点，将value值分散到一个Cell数组中，不同线程会命中到数组的不同槽中，各个线程只对自己槽中的那个值进行CAS操作，这样热点就被分散了，冲突的概率就小很多。如果要获取真正的long值，只要将各个槽中的变量值累加返回。</p><p>​sum()会将所有Cell数组中的value和base累加作为返回值，核心的思想就是将之前AtomicLong一个value的更新压力分散到多个value中去，<br>从而降级更新热点。</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210925211716139.png" alt="image-20210925211716139"></p><p><img src="/images/1.JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20210925211738409.png" alt="image-20210925211738409"></p><p>内部有一个base变量，一个Cell[]数组。</p><p>base变量：非竞态条件下，直接累加到该变量上</p><p>Cell[]数组：竞态条件下，累加个各个线程自己的槽Cell[i]中</p><h5 id="4、源码解读深度分析"><a href="#4、源码解读深度分析" class="headerlink" title="4、源码解读深度分析"></a>4、源码解读深度分析</h5><p>​LongAdder在无竞争的情况，跟AtomicLong一样，对同一个base进行操作，当出现竞争关系时则是采用化整为零的做法，从空间换时间，用一个数组cells，将一个value拆分进这个数组cells。多个线程需要同时对value进行操作时候，可以对线程id进行hash得到hash值，再根据hash值映射到这个数组cells的某个下标，再对该下标所对应的值进行自增操作。当所有线程操作完毕，将数组cells的所有值和无竞争值base都加起来作为最终结果。</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210925211849436.png" alt="image-20210925211849436"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">longAdder.increment()</span><br></pre></td></tr></table></figure><h6 id="1、add-1L"><a href="#1、add-1L" class="headerlink" title="1、add(1L)"></a>1、add(1L)</h6><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210925211939336.png" alt="image-20210925211939336"></p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210925211956219.png" alt="image-20210925211956219"></p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210925212001450.png" alt="image-20210925212001450"></p><ol><li>最初无竞争时只更新base；</li><li>如果更新base失败后，首次新建一个Cell[]数组</li><li>当多个线程竞争同一个Cell比较激烈时，可能就要对Cell[]扩容</li></ol><h6 id="2、longAccumulate"><a href="#2、longAccumulate" class="headerlink" title="2、longAccumulate"></a>2、longAccumulate</h6><p><strong>longAccumulate入参说明</strong></p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210925212131070.png" alt="image-20210925212131070"></p><p><strong>Striped64中一些变量或者方法的定义</strong></p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210925212144634.png" alt="image-20210925212144634"></p><p><strong>线程hash值：probe</strong></p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210925212206841.png" alt="image-20210925212206841"></p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210925212211672.png" alt="image-20210925212211672"></p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210925212214106.png" alt="image-20210925212214106"></p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210925212219015.png" alt="image-20210925212219015"></p><p><strong>总纲</strong></p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210925212236202.png" alt="image-20210925212236202"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">上述代码首先给当前线程分配一个hash值，然后进入一个for(;;)自旋，这个自旋分为三个分支：</span><br><span class="line">CASE1：Cell[]数组已经初始化</span><br><span class="line">CASE2：Cell[]数组未初始化(首次新建)</span><br><span class="line">CASE3：Cell[]数组正在初始化中</span><br></pre></td></tr></table></figure><p>刚刚要初始化Cell[]数组(首次新建)</p><p>未初始化过Cell[]数组，尝试占有锁并首次初始化cells数组</p><p><img src="/images/1.JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20210925212315327.png" alt="image-20210925212315327"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果上面条件都执行成功就会执行数组的初始化及赋值操作， Cell[] rs = new Cell[2]表示数组的长度为2，</span><br><span class="line">rs[h &amp; 1] = new Cell(x) 表示创建一个新的Cell元素，value是x值，默认为1。</span><br><span class="line">h &amp; 1类似于我们之前HashMap常用到的计算散列桶index的算法，通常都是hash &amp; (table.len - 1)。同hashmap一个意思。</span><br></pre></td></tr></table></figure><p><strong>兜底</strong></p><p>多个线程尝试CAS修改失败的线程会走到这个分支</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210925212343899.png" alt="image-20210925212343899"></p><p>该分支实现直接操作base基数，将值累加到base上，也即其它线程正在初始化，多个线程正在更新base的值。</p><p><strong>Cell数组不再为空且可能存在Cell数组扩容</strong></p><p>多个线程同时命中一个cell的竞争</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210925212437808.png" alt="image-20210925212437808"></p><p>1. </p><p>   <img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210925212506154.png" alt="image-20210925212506154"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">上面代码判断当前线程hash后指向的数据位置元素是否为空，</span><br><span class="line">如果为空则将Cell数据放入数组中，跳出循环。</span><br><span class="line">如果不空则继续循环。</span><br></pre></td></tr></table></figure><p>2. </p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210925212521292.png" alt="image-20210925212521292"></p><ol start="3"><li><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210925212535517.png" alt="image-20210925212535517"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">说明当前线程对应的数组中有了数据，也重置过hash值，</span><br><span class="line">这时通过CAS操作尝试对当前数中的value值进行累加x操作，x默认为1，如果CAS成功则直接跳出循环。</span><br></pre></td></tr></table></figure></li><li><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210925212601882.png" alt="image-20210925212601882"></p></li><li><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210925212607291.png" alt="image-20210925212607291"></p></li><li><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210925212613752.png" alt="image-20210925212613752"></p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210925212621738.png" alt="image-20210925212621738"></p><h6 id="3、sum"><a href="#3、sum" class="headerlink" title="3、sum"></a>3、sum</h6><p>sum()会将所有Cell数组中的value和base累加作为返回值。<br>核心的思想就是将之前AtomicLong一个value的更新压力分散到多个value中去，从而降级更新热点。</p><p><strong>为啥在并发情况下sum的值不精确</strong></p><p>sum执行时，并没有限制对base和cells的更新(一句要命的话)。所以LongAdder不是强一致性的，它是最终一致性的。</p><p>​首先，最终返回的sum局部变量，初始被复制为base，而最终返回时，很可能base已经被更新了，而此时局部变量sum不会更新，造成不一致。<br>其次，这里对cell的读取也无法保证是最后一次写入的值。所以，sum方法在没有并发的情况下，可以获得正确的结果。</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210925212713186.png" alt="image-20210925212713186"></p><h4 id="5、使用总结"><a href="#5、使用总结" class="headerlink" title="5、使用总结"></a>5、使用总结</h4><ul><li>AtomicLong<ul><li>线程安全，可允许一些性能损耗，要求高精度时可使用</li><li>保证精度，性能代价</li><li>AtomicLong是多个线程针对单个热点值value进行原子操作</li></ul></li><li>LongAdder<ul><li>当需要在高并发下有较好的性能表现，且对值的精确度要求不高时，可以使用</li><li>保证性能，精度代价</li><li>LongAdder是每个线程拥有自己的槽，各个线程一般只对自己槽中的那个值进行CAS操作</li></ul></li></ul><h3 id="7、总结-1"><a href="#7、总结-1" class="headerlink" title="7、总结"></a>7、总结</h3><h4 id="1、AtomicLong"><a href="#1、AtomicLong" class="headerlink" title="1、AtomicLong"></a>1、AtomicLong</h4><ul><li>原理<ul><li>CAS+自旋</li><li>incrementAndGet</li></ul></li><li>场景<ul><li>低并发下的全局计算</li><li>AtomicLong能保证并发情况下计数的准确性，其内部通过CAS来解决并发安全性的问题。</li></ul></li><li>缺陷<ul><li>高并发后性能急剧下降</li><li>AtomicLong的自旋会成为瓶颈</li><li>N个线程CAS操作修改线程的值，每次只有一个成功过，其它N - 1失败，失败的不停的自旋直到成功，这样大量失败自旋的情况，一下子cpu就打高了。</li></ul></li></ul><h4 id="2、LongAdder"><a href="#2、LongAdder" class="headerlink" title="2、LongAdder"></a>2、LongAdder</h4><ul><li>原理<ul><li>CAS+Base+Cell数组分散</li><li>空间换时间并分散了热点数据</li></ul></li><li>场景<ul><li>高并发下的全局计算</li></ul></li><li>缺陷<ul><li>sum求和后还有计算线程修改结果的话，最后结果不够准确</li></ul></li></ul><h2 id="十三、ThreadLocal、InheritableThreadLocal"><a href="#十三、ThreadLocal、InheritableThreadLocal" class="headerlink" title="十三、ThreadLocal、InheritableThreadLocal"></a>十三、ThreadLocal、InheritableThreadLocal</h2><h3 id="1、ThreadLocal简介"><a href="#1、ThreadLocal简介" class="headerlink" title="1、ThreadLocal简介"></a>1、ThreadLocal简介</h3><p><img src="/images/1.JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20210927222129464.png" alt="image-20210927222129464"></p><p>​稍微翻译一下：<br>​ThreadLocal提供线程局部变量。这些变量与正常的变量不同，因为每一个线程在访问ThreadLocal实例的时候（通过其get或set方法）都有自己的、独立初始化的变量副本。ThreadLocal实例通常是类中的私有静态字段，使用它的目的是希望将状态（例如，用户ID或事务ID）与线程关联起来。</p><p>​实现每一个线程都有自己专属的本地变量副本(自己用自己的变量不麻烦别人，不和其他人共享，人人有份，人各一份)，主要解决了让每个线程绑定自己的值，通过使用get()和set()方法，获取默认值或将其值更改为当前线程所存的副本的值从而避免了线程安全问题。</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210927222231797.png"></p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210927222241804.png" alt="image-20210927222241804"></p><h3 id="2、永远的helloworld"><a href="#2、永远的helloworld" class="headerlink" title="2、永远的helloworld"></a>2、永远的helloworld</h3><p>按照总销售额统计，方便集团公司做计划统计</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MovieTicket</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">saleTicket</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(number &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;号售票员卖出第： &quot;</span>+(number--));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;--------卖完了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 三个售票员卖完50张票务，总量完成即可，吃大锅饭，售票员每个月固定月薪</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">MovieTicket</span> <span class="variable">movieTicket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MovieTicket</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;<span class="number">20</span>; j++) &#123;</span><br><span class="line">                    movieTicket.saleTicket();</span><br><span class="line">                    <span class="keyword">try</span> &#123; TimeUnit.MILLISECONDS.sleep(<span class="number">10</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不参加总和计算，希望各自分灶吃饭，各凭销售本事提成，按照出单数各自统计</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MovieTicket</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">saleTicket</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(number &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;号售票员卖出第： &quot;</span>+(number--));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;--------卖完了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">House</span></span><br><span class="line">&#123;</span><br><span class="line">    ThreadLocal&lt;Integer&gt; threadLocal = ThreadLocal.withInitial(() -&gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saleHouse</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> threadLocal.get();</span><br><span class="line">        value++;</span><br><span class="line">        threadLocal.set(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1  三个售票员卖完50张票务，总量完成即可，吃大锅饭，售票员每个月固定月薪</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2  分灶吃饭，各个销售自己动手，丰衣足食</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*MovieTicket movieTicket = new MovieTicket();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        for (int i = 1; i &lt;=3; i++) &#123;</span></span><br><span class="line"><span class="comment">            new Thread(() -&gt; &#123;</span></span><br><span class="line"><span class="comment">                for (int j = 0; j &lt;20; j++) &#123;</span></span><br><span class="line"><span class="comment">                    movieTicket.saleTicket();</span></span><br><span class="line"><span class="comment">                    try &#123; TimeUnit.MILLISECONDS.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;,String.valueOf(i)).start();</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//===========================================</span></span><br><span class="line">        <span class="type">House</span> <span class="variable">house</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">House</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">3</span>; i++) &#123;</span><br><span class="line">                    house.saleHouse();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;---&quot;</span>+house.threadLocal.get());</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                house.threadLocal.remove();<span class="comment">//如果不清理自定义的 ThreadLocal 变量，可能会影响后续业务逻辑和造成内存泄露等问题</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">2</span>; i++) &#123;</span><br><span class="line">                    house.saleHouse();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;---&quot;</span>+house.threadLocal.get());</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                house.threadLocal.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">                    house.saleHouse();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;---&quot;</span>+house.threadLocal.get());</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                house.threadLocal.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t3&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;---&quot;</span>+house.threadLocal.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1、小总结"><a href="#1、小总结" class="headerlink" title="1、小总结"></a>1、小总结</h4><p>因为每个 Thread 内有自己的实例副本且该副本只由当前线程自己使用</p><p>既然其它 Thread 不可访问，那就不存在多线程间共享的问题。</p><p>统一设置初始值，但是每个线程对这个值的修改都是各自线程互相独立的</p><ol><li><p>加入synchronized或者Lock控制资源的访问顺序</p></li><li><p>人手一份，大家各自安好，没必要抢夺</p></li></ol><h3 id="3、从阿里ThreadLocal规范开始"><a href="#3、从阿里ThreadLocal规范开始" class="headerlink" title="3、从阿里ThreadLocal规范开始"></a>3、从阿里ThreadLocal规范开始</h3><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210927222614201.png" alt="image-20210927222614201"></p><h4 id="1、非线程安全的SimpleDateFormat"><a href="#1、非线程安全的SimpleDateFormat" class="headerlink" title="1、非线程安全的SimpleDateFormat"></a>1、非线程安全的SimpleDateFormat</h4><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210927222646376.png" alt="image-20210927222646376"></p><p>​上述翻译：SimpleDateFormat中的日期格式不是同步的。推荐（建议）为每个线程创建独立的格式实例。如果多个线程同时访问一个格式，则它必须保持外部同步。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DateUtils</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟并发环境下使用SimpleDateFormat的parse方法将字符串转换成Date对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> stringDate</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title function_">parseDate</span><span class="params">(String stringDate)</span><span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="keyword">return</span> sdf.parse(stringDate);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">30</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(DateUtils.parseDate(<span class="string">&quot;2020-11-11 11:11:11&quot;</span>));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">java.lang.NumberFormatException: For input string: <span class="string">&quot;&quot;</span></span><br><span class="line">at java.lang.NumberFormatException.forInputString(NumberFormatException.java:<span class="number">65</span>)</span><br><span class="line">at java.lang.Long.parseLong(Long.java:<span class="number">601</span>)</span><br><span class="line">at java.lang.Long.parseLong(Long.java:<span class="number">631</span>)</span><br><span class="line">at java.text.DigitList.getLong(DigitList.java:<span class="number">195</span>)</span><br><span class="line">at java.text.DecimalFormat.parse(DecimalFormat.java:<span class="number">2082</span>)</span><br><span class="line">at java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:<span class="number">1869</span>)</span><br><span class="line">at java.text.SimpleDateFormat.parse(SimpleDateFormat.java:<span class="number">1514</span>)</span><br><span class="line">at java.text.DateFormat.parse(DateFormat.java:<span class="number">364</span>)</span><br><span class="line">at com.zdww.tcm.utils.DateTimeUtil.parseDate(DateTimeUtil.java:<span class="number">1129</span>)</span><br><span class="line">at com.zdww.tcm.utils.DateTimeUtil.lambda$main$<span class="number">0</span>(DateTimeUtil.java:<span class="number">1137</span>)</span><br><span class="line">at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line">java.lang.NumberFormatException: For input string: <span class="string">&quot;.20202E.20202E44&quot;</span></span><br><span class="line">at sun.misc.FloatingDecimal.readJavaFormatString(FloatingDecimal.java:<span class="number">2043</span>)</span><br><span class="line">at sun.misc.FloatingDecimal.parseDouble(FloatingDecimal.java:<span class="number">110</span>)</span><br><span class="line">at java.lang.Double.parseDouble(Double.java:<span class="number">538</span>)</span><br><span class="line">at java.text.DigitList.getDouble(DigitList.java:<span class="number">169</span>)</span><br><span class="line">at java.text.DecimalFormat.parse(DecimalFormat.java:<span class="number">2087</span>)</span><br><span class="line">at java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:<span class="number">1869</span>)</span><br><span class="line">at java.text.SimpleDateFormat.parse(SimpleDateFormat.java:<span class="number">1514</span>)</span><br><span class="line">at java.text.DateFormat.parse(DateFormat.java:<span class="number">364</span>)</span><br><span class="line">at com.zdww.tcm.utils.DateTimeUtil.parseDate(DateTimeUtil.java:<span class="number">1129</span>)</span><br><span class="line">at com.zdww.tcm.utils.DateTimeUtil.lambda$main$<span class="number">0</span>(DateTimeUtil.java:<span class="number">1137</span>)</span><br></pre></td></tr></table></figure><p>​SimpleDateFormat类内部有一个Calendar对象引用,它用来储存和这个SimpleDateFormat相关的日期信息,例如sdf.parse(dateStr),sdf.format(date) 诸如此类的方法参数传入的日期相关String,Date等等, 都是交由Calendar引用来储存的.这样就会导致一个问题如果你的SimpleDateFormat是个static的, 那么多个thread 之间就会共享这个SimpleDateFormat, 同时也是共享这个Calendar引用。</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210927222827543.png" alt="image-20210927222827543"></p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210927222831591.png" alt="image-20210927222831591"></p><h4 id="2、解决1"><a href="#2、解决1" class="headerlink" title="2、解决1"></a>2、解决1</h4><p>将SimpleDateFormat定义成局部变量。</p><p>缺点：每调用一次方法就会创建一个SimpleDateFormat对象，方法结束又要作为垃圾回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DateUtils</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟并发环境下使用SimpleDateFormat的parse方法将字符串转换成Date对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> stringDate</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title function_">parseDate</span><span class="params">(String stringDate)</span><span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="keyword">return</span> sdf.parse(stringDate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">30</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">                    System.out.println(sdf.parse(<span class="string">&quot;2020-11-11 11:11:11&quot;</span>));</span><br><span class="line">                    sdf = <span class="literal">null</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、解决2"><a href="#3、解决2" class="headerlink" title="3、解决2"></a>3、解决2</h4><p>ThreadLocal，也叫做线程本地变量或者线程本地存储</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DateUtils</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;SimpleDateFormat&gt;  sdf_threadLocal =</span><br><span class="line">            ThreadLocal.withInitial(()-&gt; <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ThreadLocal可以确保每个线程都可以得到各自单独的一个SimpleDateFormat的对象，那么自然也就不存在竞争问题了。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> stringDate</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title function_">parseDateTL</span><span class="params">(String stringDate)</span><span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="keyword">return</span> sdf_threadLocal.get().parse(stringDate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">30</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(DateUtils.parseDateTL(<span class="string">&quot;2020-11-11 11:11:11&quot;</span>));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DateUtils</span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1   SimpleDateFormat如果多线程共用是线程不安全的类</span></span><br><span class="line"><span class="comment">    public static final SimpleDateFormat SIMPLE_DATE_FORMAT = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public static String format(Date date)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        return SIMPLE_DATE_FORMAT.format(date);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public static Date parse(String datetime) throws ParseException</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        return SIMPLE_DATE_FORMAT.parse(datetime);</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2   ThreadLocal可以确保每个线程都可以得到各自单独的一个SimpleDateFormat的对象，那么自然也就不存在竞争问题了。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;SimpleDateFormat&gt; SIMPLE_DATE_FORMAT_THREAD_LOCAL = ThreadLocal.withInitial(() -&gt; <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">format</span><span class="params">(Date date)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SIMPLE_DATE_FORMAT_THREAD_LOCAL.get().format(date);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title function_">parse</span><span class="params">(String datetime)</span> <span class="keyword">throws</span> ParseException&#123;</span><br><span class="line">        <span class="keyword">return</span> SIMPLE_DATE_FORMAT_THREAD_LOCAL.get().parse(datetime);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3 DateTimeFormatter 代替 SimpleDateFormat</span></span><br><span class="line">    <span class="comment">/*public static final DateTimeFormatter DATE_TIME_FORMAT = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public static String format(LocalDateTime localDateTime)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        return DATE_TIME_FORMAT.format(localDateTime);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public static LocalDateTime parse(String dateString)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        return LocalDateTime.parse(dateString,DATE_TIME_FORMAT);</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、ThreadLocal源码分析"><a href="#4、ThreadLocal源码分析" class="headerlink" title="4、ThreadLocal源码分析"></a>4、ThreadLocal源码分析</h3><h4 id="1、Thread，ThreadLocal，ThreadLocalMap-关系"><a href="#1、Thread，ThreadLocal，ThreadLocalMap-关系" class="headerlink" title="1、Thread，ThreadLocal，ThreadLocalMap 关系"></a>1、Thread，ThreadLocal，ThreadLocalMap 关系</h4><p>Thread和ThreadLocal</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210927223107547.png" alt="image-20210927223107547"></p><p>再次体会，各自线程，人手一份</p><p>ThreadLocal和ThreadLocalMap</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210927223131768.png" alt="image-20210927223131768"></p><p>All三者总概括</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210927223141071.png" alt="image-20210927223141071"></p><p>​threadLocalMap实际上就是一个以threadLocal实例为key，任意对象为value的Entry对象。<br>当我们为threadLocal变量赋值，实际上就是以当前threadLocal实例为key，值为value的Entry往这个threadLocalMap中存放</p><p>近似的可以理解为:<br>ThreadLocalMap从字面上就可以看出这是一个保存ThreadLocal对象的map(其实是以ThreadLocal为Key)，不过是经过了两层包装的ThreadLocal对象：</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210927223215319.png" alt="image-20210927223215319"></p><p>​JVM内部维护了一个线程版的Map&lt;Thread,T&gt;(通过ThreadLocal对象的set方法，结果把ThreadLocal对象自己当做key，放进了ThreadLoalMap中),每个线程要用到这个T的时候，用当前的线程去Map里面获取，通过这样让每个线程都拥有了自己独立的变量，人手一份，竞争条件被彻底消除，在并发模式下是绝对安全的变量。</p><h3 id="5、ThreadLocal内存泄露问题"><a href="#5、ThreadLocal内存泄露问题" class="headerlink" title="5、ThreadLocal内存泄露问题"></a>5、ThreadLocal内存泄露问题</h3><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210927223726167.png" alt="image-20210927223726167"></p><h4 id="1、什么是内存泄漏"><a href="#1、什么是内存泄漏" class="headerlink" title="1、什么是内存泄漏"></a>1、什么是内存泄漏</h4><p>不再会被使用的对象或者变量占用的内存不能被回收，就是内存泄露。</p><h4 id="2、谁惹的祸？"><a href="#2、谁惹的祸？" class="headerlink" title="2、谁惹的祸？"></a>2、谁惹的祸？</h4><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210927223802332.png" alt="image-20210927223802332"></p><h4 id="3、强引用、软引用、弱引用、虚引用分别是什么？"><a href="#3、强引用、软引用、弱引用、虚引用分别是什么？" class="headerlink" title="3、强引用、软引用、弱引用、虚引用分别是什么？"></a>3、强引用、软引用、弱引用、虚引用分别是什么？</h4><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210927223927641.png" alt="image-20210927223927641"></p><p>ThreadLocalMap从字面上就可以看出这是一个保存ThreadLocal对象的map(其实是以它为Key)，不过是经过了两层包装的ThreadLocal对象：<br>（1）第一层包装是使用 WeakReference&lt;ThreadLocal<?>> 将ThreadLocal对象变成一个弱引用的对象；（2）第二层包装是定义了一个专门的类 Entry 来扩展 WeakReference<ThreadLocal<?>&gt;</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210927223943383.png" alt="image-20210927223943383"></p><p>java 技术允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。</p><h5 id="1、强引用-默认支持模式"><a href="#1、强引用-默认支持模式" class="headerlink" title="1、强引用(默认支持模式)"></a>1、强引用(默认支持模式)</h5><p>当内存不足，JVM开始垃圾回收，对于强引用的对象，就算是出现了OOM也不会对该对象进行回收，死都不收。</p><p>​强引用是我们最常见的普通对象引用，只要还有强引用指向一个对象，就能表明对象还“活着”，垃圾收集器不会碰这种对象。在 Java 中最常见的就是强引用，把一个对象赋给一个引用变量，这个引用变量就是一个强引用。当一个对象被强引用变量引用时，它处于可达状态，它是不可能被垃圾回收机制回收的，即使该对象以后永远都不会被用到JVM也不会回收。因此强引用是造成Java内存泄漏的主要原因之一。</p><p>​对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为 null，一般认为就是可以被垃圾收集的了(当然具体回收时机还是要看垃圾收集策略)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">strongReference</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">MyObject</span> <span class="variable">myObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyObject</span>();</span><br><span class="line">    System.out.println(<span class="string">&quot;-----gc before: &quot;</span>+myObject);</span><br><span class="line"></span><br><span class="line">    myObject = <span class="literal">null</span>;</span><br><span class="line">    System.gc();</span><br><span class="line">    <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">1</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;-----gc after: &quot;</span>+myObject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2、软引用"><a href="#2、软引用" class="headerlink" title="2、软引用"></a>2、软引用</h5><p>软引用是一种相对强引用弱化了一些的引用，需要用java.lang.ref.SoftReference类来实现，可以让对象豁免一些垃圾收集。</p><p>对于只有软引用的对象来说，</p><p>当系统内存充足时它      不会     被回收，</p><p>当系统内存不足时它     会     被回收。</p><p>软引用通常用在对内存敏感的程序中，比如高速缓存就有用到软引用，内存够用的时候就保留，不够用就回收！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyObject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//一般开发中不用调用这个方法，本次只是为了演示</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;---finalize method invoked....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReferenceDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//当我们内存不够用的时候，soft会被回收的情况，设置我们的内存大小：-Xms10m -Xmx10m</span></span><br><span class="line">        SoftReference&lt;MyObject&gt; softReference = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">MyObject</span>());</span><br><span class="line"></span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">1</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;-----gc after内存够用: &quot;</span>+softReference.get());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">9</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;-----gc after内存不够: &quot;</span>+softReference.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">strongReference</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">MyObject</span> <span class="variable">myObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyObject</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;-----gc before: &quot;</span>+myObject);</span><br><span class="line"></span><br><span class="line">        myObject = <span class="literal">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">1</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-----gc after: &quot;</span>+myObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3、弱引用"><a href="#3、弱引用" class="headerlink" title="3、弱引用"></a>3、弱引用</h5><p>​弱引用需要用java.lang.ref.WeakReference类来实现，它比软引用的生存期更短，对于只有弱引用的对象来说，只要垃圾回收机制一运行，不管JVM的内存空间是否足够，都会回收该对象占用的内存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyObject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//一般开发中不用调用这个方法，本次只是为了演示</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;---finalize method invoked....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReferenceDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        WeakReference&lt;MyObject&gt; weakReference = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">MyObject</span>());</span><br><span class="line">        System.out.println(<span class="string">&quot;-----gc before内存够用: &quot;</span>+weakReference.get());</span><br><span class="line"></span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">1</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-----gc after内存够用: &quot;</span>+weakReference.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">softReference</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//当我们内存不够用的时候，soft会被回收的情况，设置我们的内存大小：-Xms10m -Xmx10m</span></span><br><span class="line">        SoftReference&lt;MyObject&gt; softReference = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">MyObject</span>());</span><br><span class="line"></span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">1</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;-----gc after内存够用: &quot;</span>+softReference.get());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">9</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;-----gc after内存不够: &quot;</span>+softReference.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">strongReference</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">MyObject</span> <span class="variable">myObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyObject</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;-----gc before: &quot;</span>+myObject);</span><br><span class="line"></span><br><span class="line">        myObject = <span class="literal">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">1</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-----gc after: &quot;</span>+myObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>软引用和弱引用的适用场景</strong></p><p>假如有一个应用需要读取大量的本地图片:</p><p>如果每次读取图片都从硬盘读取则会严重影响性能,</p><p>如果一次性全部加载到内存中又可能造成内存溢出。</p><p>此时使用软引用可以解决这个问题。</p><p>　　设计思路是：用一个HashMap来保存图片的路径和相应图片对象关联的软引用之间的映射关系，在内存不足时，JVM会自动回收这些缓存图片对象所占用的空间，从而有效地避免了OOM的问题。</p><p>Map&lt;String, SoftReference<Bitmap>&gt; imageCache &#x3D; new HashMap&lt;String, SoftReference<Bitmap>&gt;();</p><h5 id="4、虚引用"><a href="#4、虚引用" class="headerlink" title="4、虚引用"></a>4、虚引用</h5><p>虚引用需要java.lang.ref.PhantomReference类来实现。</p><p>​顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收，它不能单独使用也不能通过它访问对象，虚引用必须和引用队列 (ReferenceQueue)联合使用。</p><p>​虚引用的主要作用是跟踪对象被垃圾回收的状态。 仅仅是提供了一种确保对象被 finalize以后，做某些事情的机制。 PhantomReference的get方法总是返回null，因此无法访问对应的引用对象。</p><p>其意义在于：说明一个对象已经进入finalization阶段，可以被gc回收，用来实现比finalization机制更灵活的回收操作。</p><p>换句话说，设置虚引用关联的唯一目的，就是在这个对象被收集器回收的时候收到一个系统通知或者后续添加进一步的处理。</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210927224455350.png" alt="image-20210927224455350"></p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210927224500569.png" alt="image-20210927224500569"></p><p>我被回收前需要被引用队列保存下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyObject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//一般开发中不用调用这个方法，本次只是为了演示</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;---finalize method invoked....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReferenceDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        ReferenceQueue&lt;MyObject&gt; referenceQueue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>();</span><br><span class="line">        PhantomReference&lt;MyObject&gt; phantomReference = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">MyObject</span>(),referenceQueue);</span><br><span class="line">        <span class="comment">//System.out.println(phantomReference.get());</span></span><br><span class="line"></span><br><span class="line">        List&lt;<span class="type">byte</span>[]&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                list.add(<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1</span> * <span class="number">1024</span> * <span class="number">1024</span>]);</span><br><span class="line">                <span class="keyword">try</span> &#123; TimeUnit.MILLISECONDS.sleep(<span class="number">600</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">                System.out.println(phantomReference.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Reference&lt;? <span class="keyword">extends</span> <span class="title class_">MyObject</span>&gt; reference = referenceQueue.poll();</span><br><span class="line">                <span class="keyword">if</span> (reference != <span class="literal">null</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;***********有虚对象加入队列了&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//暂停几秒钟线程</span></span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">5</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">weakReference</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        WeakReference&lt;MyObject&gt; weakReference = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">MyObject</span>());</span><br><span class="line">        System.out.println(<span class="string">&quot;-----gc before内存够用: &quot;</span>+weakReference.get());</span><br><span class="line"></span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">1</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-----gc after内存够用: &quot;</span>+weakReference.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">softReference</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//当我们内存不够用的时候，soft会被回收的情况，设置我们的内存大小：-Xms10m -Xmx10m</span></span><br><span class="line">        SoftReference&lt;MyObject&gt; softReference = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">MyObject</span>());</span><br><span class="line"></span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">1</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;-----gc after内存够用: &quot;</span>+softReference.get());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">9</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;-----gc after内存不够: &quot;</span>+softReference.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">strongReference</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">MyObject</span> <span class="variable">myObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyObject</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;-----gc before: &quot;</span>+myObject);</span><br><span class="line"></span><br><span class="line">        myObject = <span class="literal">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">1</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-----gc after: &quot;</span>+myObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5、GCRoots和四大引用小总结"><a href="#5、GCRoots和四大引用小总结" class="headerlink" title="5、GCRoots和四大引用小总结"></a>5、GCRoots和四大引用小总结</h5><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210927224539900.png" alt="image-20210927224539900"></p><h4 id="4、关系"><a href="#4、关系" class="headerlink" title="4、关系"></a>4、关系</h4><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210927224633866.png" alt="image-20210927224633866"></p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210927224637416.png" alt="image-20210927224637416"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">每个Thread对象维护着一个ThreadLocalMap的引用</span><br><span class="line">ThreadLocalMap是ThreadLocal的内部类，用Entry来进行存储</span><br><span class="line">调用ThreadLocal的set()方法时，实际上就是往ThreadLocalMap设置值，key是ThreadLocal对象，值Value是传递进来的对象</span><br><span class="line">调用ThreadLocal的get()方法时，实际上就是往ThreadLocalMap获取值，key是ThreadLocal对象</span><br><span class="line">ThreadLocal本身并不存储值，它只是自己作为一个key来让线程从ThreadLocalMap获取value，正因为这个原理，所以ThreadLocal能够实现“数据隔离”，获取当前线程的局部变量值，不受其他线程影响～</span><br></pre></td></tr></table></figure><h3 id="6、为什么要用弱引用-不用如何？"><a href="#6、为什么要用弱引用-不用如何？" class="headerlink" title="6、为什么要用弱引用?不用如何？"></a>6、为什么要用弱引用?不用如何？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">function01</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">ThreadLocal</span> <span class="variable">tl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;Integer&gt;();    <span class="comment">//line1</span></span><br><span class="line">    tl.set(<span class="number">2021</span>);                                   <span class="comment">//line2</span></span><br><span class="line">    tl.get();                                       <span class="comment">//line3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//line1新建了一个ThreadLocal对象，t1 是强引用指向这个对象；</span></span><br><span class="line"><span class="comment">//line2调用set()方法后新建一个Entry，通过源码可知Entry对象里的k是弱引用指向这个对象。</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210927224731712.png" alt="image-20210927224731712"></p><p>​当function01方法执行完毕后，栈帧销毁强引用 tl 也就没有了。但此时线程的ThreadLocalMap里某个entry的key引用还指向这个对象,若这个key引用是强引用，就会导致key指向的ThreadLocal对象及v指向的对象不能被gc回收，造成内存泄漏；若这个key引用是弱引用就大概率会减少内存泄漏的问题(还有一个key为null的雷)。使用弱引用，就可以使ThreadLocal对象在方法执行完毕后顺利被回收且Entry的key引用指向为null。</p><p><strong>此后我们调用get,set或remove方法时，就会尝试删除key为null的entry，可以释放value对象所占用的内存。</strong></p><h5 id="1、弱引用就万事大吉了吗？"><a href="#1、弱引用就万事大吉了吗？" class="headerlink" title="1、弱引用就万事大吉了吗？"></a>1、弱引用就万事大吉了吗？</h5><ol><li><p>当我们为threadLocal变量赋值，实际上就是当前的Entry(threadLocal实例为key，值为value)往这个threadLocalMap中存放。Entry中的key是弱引用，当threadLocal外部强引用被置为null(tl&#x3D;null),那么系统 GC 的时候，根据可达性分析，这个threadLocal实例就没有任何一条链路能够引用到它，这个ThreadLocal势必会被回收，这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链：Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value永远无法回收，造成内存泄漏。</p></li><li><p>当然，如果当前thread运行结束，threadLocal，threadLocalMap,Entry没有引用链可达，在垃圾回收的时候都会被系统进行回收。</p></li><li><p>但在实际使用中我们有时候会用线程池去维护我们的线程，比如在Executors.newFixedThreadPool()时创建线程的时候，为了复用线程是不会结束的，所以threadLocal内存泄漏就值得我们小心</p></li></ol><h5 id="2、key为null的entry，原理解析"><a href="#2、key为null的entry，原理解析" class="headerlink" title="2、key为null的entry，原理解析"></a>2、key为null的entry，原理解析</h5><p><img src="C:\Users\Administrator\Desktop\JUC并发编程\images\1.JUC并发编程\image-20210927224633866.png" alt="image-20210927224633866"></p><p>​ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal没有外部强引用引用他，那么系统gc的时候，这个ThreadLocal势必会被回收，这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，如果当前线程再迟迟不结束的话(比如正好用在线程池)，这些key为null的Entry的value就会一直存在一条强引用链。</p><p>​虽然弱引用，保证了key指向的ThreadLocal对象能被及时回收，但是v指向的value对象是需要ThreadLocalMap调用get、set时发现key为null时才会去回收整个entry、value，因此弱引用不能100%保证内存不泄露。我们要在不使用某个ThreadLocal对象后，手动调用remoev方法来删除它，尤其是在线程池中，不仅仅是内存泄露的问题，因为线程池中的线程是重复使用的，意味着这个线程的ThreadLocalMap对象也是重复使用的，如果我们不手动调用remove方法，那么后面的线程就有可能获取到上个线程遗留下来的value值，造成bug。</p><h5 id="3、set、get方法会去检查所有键为null的Entry对象"><a href="#3、set、get方法会去检查所有键为null的Entry对象" class="headerlink" title="3、set、get方法会去检查所有键为null的Entry对象"></a>3、set、get方法会去检查所有键为null的Entry对象</h5><p>set()</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210927224959196.png" alt="image-20210927224959196"></p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210927225002054.png" alt="image-20210927225002054"></p><p>get()</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210927225105228.png"></p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210927225110265.png" alt="image-20210927225110265"></p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210927225059412.png" alt="image-20210927225059412"></p><p>remove()</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210927225121559.png" alt="image-20210927225121559"></p><p>结论</p><p>​从前面的set,getEntry,remove方法看出，在threadLocal的生命周期里，针对threadLocal存在的内存泄漏的问题，<br>都会通过expungeStaleEntry，cleanSomeSlots,replaceStaleEntry这三个方法清理掉key为null的脏entry。</p><h5 id="4、结论"><a href="#4、结论" class="headerlink" title="4、结论"></a>4、结论</h5><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210927225235846.png" alt="image-20210927225235846"></p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210927225238663.png" alt="image-20210927225238663"></p><h3 id="7、最佳实践"><a href="#7、最佳实践" class="headerlink" title="7、最佳实践"></a>7、最佳实践</h3><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210927225409632.png" alt="image-20210927225409632"></p><p>用完记得手动remove</p><h3 id="8、小总结"><a href="#8、小总结" class="headerlink" title="8、小总结"></a>8、小总结</h3><ul><li>ThreadLocal 并不解决线程间共享数据的问题</li><li>ThreadLocal 适用于变量在线程间隔离且在方法间共享的场景</li><li>ThreadLocal 通过隐式的在不同线程内创建独立实例副本避免了实例线程安全的问题</li><li>每个线程持有一个只属于自己的专属Map并维护了ThreadLocal对象与具体实例的映射，该Map由于只被持有它的线程访问，故不存在线程安全以及锁的问题</li><li>ThreadLocalMap的Entry对ThreadLocal的引用为弱引用，避免了ThreadLocal对象无法被回收的问题</li><li>都会通过expungeStaleEntry，cleanSomeSlots,replaceStaleEntry这三个方法回收键为 null 的 Entry 对象的值（即为具体实例）以及 Entry 对象本身从而防止内存泄漏，属于安全加固的方法</li><li>群雄逐鹿起纷争，人各一份天下安</li></ul><h3 id="9、ThreadLocal和InheritableThreadLocal"><a href="#9、ThreadLocal和InheritableThreadLocal" class="headerlink" title="9、ThreadLocal和InheritableThreadLocal"></a>9、ThreadLocal和InheritableThreadLocal</h3><p>需要解决的问题</p><blockquote><p>我们还是以解决问题的方式来引出<code>ThreadLocal</code>、<code>InheritableThreadLocal</code>，这样印象会深刻一些。</p></blockquote><p>目前java开发web系统一般有3层，controller、service、dao，请求到达controller，controller调用service，service调用dao，然后进行处理。</p><p>我们写一个简单的例子，有3个方法分别模拟controller、service、dao。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingDeque;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">threadIndex</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//创建处理请求的线程池子</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">ThreadPoolExecutor</span> <span class="variable">disposeRequestExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">3</span>,</span><br><span class="line">            <span class="number">3</span>,</span><br><span class="line">            <span class="number">60</span>,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">LinkedBlockingDeque</span>&lt;&gt;(),</span><br><span class="line">            r -&gt; &#123;</span><br><span class="line">                <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">                thread.setName(<span class="string">&quot;disposeRequestThread-&quot;</span> + threadIndex.getAndIncrement());</span><br><span class="line">                <span class="keyword">return</span> thread;</span><br><span class="line">            &#125;);</span><br><span class="line">    <span class="comment">//记录日志</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        StackTraceElement stack[] = (<span class="keyword">new</span> <span class="title class_">Throwable</span>()).getStackTrace();</span><br><span class="line">        System.out.println(<span class="string">&quot;****&quot;</span> + System.currentTimeMillis() + <span class="string">&quot;,[线程:&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;],&quot;</span> + stack[<span class="number">1</span>] + <span class="string">&quot;:&quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//模拟controller</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">controller</span><span class="params">(List&lt;String&gt; dataList)</span> &#123;</span><br><span class="line">        log(<span class="string">&quot;接受请求&quot;</span>);</span><br><span class="line">        service(dataList);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//模拟service</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(List&lt;String&gt; dataList)</span> &#123;</span><br><span class="line">        log(<span class="string">&quot;执行业务&quot;</span>);</span><br><span class="line">        dao(dataList);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//模拟dao</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dao</span><span class="params">(List&lt;String&gt; dataList)</span> &#123;</span><br><span class="line">        log(<span class="string">&quot;执行数据库操作&quot;</span>);</span><br><span class="line">        <span class="comment">//模拟插入数据</span></span><br><span class="line">        <span class="keyword">for</span> (String s : dataList) &#123;</span><br><span class="line">            log(<span class="string">&quot;插入数据&quot;</span> + s + <span class="string">&quot;成功&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//需要插入的数据</span></span><br><span class="line">        List&lt;String&gt; dataList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            dataList.add(<span class="string">&quot;数据&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//模拟5个请求</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">requestCount</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; requestCount; i++) &#123;</span><br><span class="line">            disposeRequestExecutor.execute(() -&gt; &#123;</span><br><span class="line">                controller(dataList);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        disposeRequestExecutor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">****<span class="number">1565338891286</span>,[线程:disposeRequestThread-<span class="number">2</span>],com.itsoku.chat24.Demo1.controller(Demo1.java:<span class="number">36</span>):接受请求</span><br><span class="line">****<span class="number">1565338891286</span>,[线程:disposeRequestThread-<span class="number">1</span>],com.itsoku.chat24.Demo1.controller(Demo1.java:<span class="number">36</span>):接受请求</span><br><span class="line">****<span class="number">1565338891287</span>,[线程:disposeRequestThread-<span class="number">2</span>],com.itsoku.chat24.Demo1.service(Demo1.java:<span class="number">42</span>):执行业务</span><br><span class="line">****<span class="number">1565338891287</span>,[线程:disposeRequestThread-<span class="number">1</span>],com.itsoku.chat24.Demo1.service(Demo1.java:<span class="number">42</span>):执行业务</span><br><span class="line">****<span class="number">1565338891287</span>,[线程:disposeRequestThread-<span class="number">3</span>],com.itsoku.chat24.Demo1.controller(Demo1.java:<span class="number">36</span>):接受请求</span><br><span class="line">****<span class="number">1565338891287</span>,[线程:disposeRequestThread-<span class="number">1</span>],com.itsoku.chat24.Demo1.dao(Demo1.java:<span class="number">48</span>):执行数据库操作</span><br><span class="line">****<span class="number">1565338891287</span>,[线程:disposeRequestThread-<span class="number">1</span>],com.itsoku.chat24.Demo1.dao(Demo1.java:<span class="number">51</span>):插入数据数据<span class="number">0</span>成功</span><br><span class="line">****<span class="number">1565338891287</span>,[线程:disposeRequestThread-<span class="number">1</span>],com.itsoku.chat24.Demo1.dao(Demo1.java:<span class="number">51</span>):插入数据数据<span class="number">1</span>成功</span><br><span class="line">****<span class="number">1565338891287</span>,[线程:disposeRequestThread-<span class="number">2</span>],com.itsoku.chat24.Demo1.dao(Demo1.java:<span class="number">48</span>):执行数据库操作</span><br><span class="line">****<span class="number">1565338891287</span>,[线程:disposeRequestThread-<span class="number">1</span>],com.itsoku.chat24.Demo1.dao(Demo1.java:<span class="number">51</span>):插入数据数据<span class="number">2</span>成功</span><br><span class="line">****<span class="number">1565338891287</span>,[线程:disposeRequestThread-<span class="number">3</span>],com.itsoku.chat24.Demo1.service(Demo1.java:<span class="number">42</span>):执行业务</span><br><span class="line">****<span class="number">1565338891288</span>,[线程:disposeRequestThread-<span class="number">1</span>],com.itsoku.chat24.Demo1.controller(Demo1.java:<span class="number">36</span>):接受请求</span><br><span class="line">****<span class="number">1565338891287</span>,[线程:disposeRequestThread-<span class="number">2</span>],com.itsoku.chat24.Demo1.dao(Demo1.java:<span class="number">51</span>):插入数据数据<span class="number">0</span>成功</span><br><span class="line">****<span class="number">1565338891288</span>,[线程:disposeRequestThread-<span class="number">1</span>],com.itsoku.chat24.Demo1.service(Demo1.java:<span class="number">42</span>):执行业务</span><br><span class="line">****<span class="number">1565338891288</span>,[线程:disposeRequestThread-<span class="number">3</span>],com.itsoku.chat24.Demo1.dao(Demo1.java:<span class="number">48</span>):执行数据库操作</span><br><span class="line">****<span class="number">1565338891288</span>,[线程:disposeRequestThread-<span class="number">1</span>],com.itsoku.chat24.Demo1.dao(Demo1.java:<span class="number">48</span>):执行数据库操作</span><br><span class="line">****<span class="number">1565338891288</span>,[线程:disposeRequestThread-<span class="number">2</span>],com.itsoku.chat24.Demo1.dao(Demo1.java:<span class="number">51</span>):插入数据数据<span class="number">1</span>成功</span><br><span class="line">****<span class="number">1565338891288</span>,[线程:disposeRequestThread-<span class="number">1</span>],com.itsoku.chat24.Demo1.dao(Demo1.java:<span class="number">51</span>):插入数据数据<span class="number">0</span>成功</span><br><span class="line">****<span class="number">1565338891288</span>,[线程:disposeRequestThread-<span class="number">3</span>],com.itsoku.chat24.Demo1.dao(Demo1.java:<span class="number">51</span>):插入数据数据<span class="number">0</span>成功</span><br><span class="line">****<span class="number">1565338891288</span>,[线程:disposeRequestThread-<span class="number">1</span>],com.itsoku.chat24.Demo1.dao(Demo1.java:<span class="number">51</span>):插入数据数据<span class="number">1</span>成功</span><br><span class="line">****<span class="number">1565338891288</span>,[线程:disposeRequestThread-<span class="number">2</span>],com.itsoku.chat24.Demo1.dao(Demo1.java:<span class="number">51</span>):插入数据数据<span class="number">2</span>成功</span><br><span class="line">****<span class="number">1565338891288</span>,[线程:disposeRequestThread-<span class="number">1</span>],com.itsoku.chat24.Demo1.dao(Demo1.java:<span class="number">51</span>):插入数据数据<span class="number">2</span>成功</span><br><span class="line">****<span class="number">1565338891288</span>,[线程:disposeRequestThread-<span class="number">3</span>],com.itsoku.chat24.Demo1.dao(Demo1.java:<span class="number">51</span>):插入数据数据<span class="number">1</span>成功</span><br><span class="line">****<span class="number">1565338891288</span>,[线程:disposeRequestThread-<span class="number">2</span>],com.itsoku.chat24.Demo1.controller(Demo1.java:<span class="number">36</span>):接受请求</span><br><span class="line">****<span class="number">1565338891288</span>,[线程:disposeRequestThread-<span class="number">3</span>],com.itsoku.chat24.Demo1.dao(Demo1.java:<span class="number">51</span>):插入数据数据<span class="number">2</span>成功</span><br><span class="line">****<span class="number">1565338891288</span>,[线程:disposeRequestThread-<span class="number">2</span>],com.itsoku.chat24.Demo1.service(Demo1.java:<span class="number">42</span>):执行业务</span><br><span class="line">****<span class="number">1565338891289</span>,[线程:disposeRequestThread-<span class="number">2</span>],com.itsoku.chat24.Demo1.dao(Demo1.java:<span class="number">48</span>):执行数据库操作</span><br><span class="line">****<span class="number">1565338891289</span>,[线程:disposeRequestThread-<span class="number">2</span>],com.itsoku.chat24.Demo1.dao(Demo1.java:<span class="number">51</span>):插入数据数据<span class="number">0</span>成功</span><br><span class="line">****<span class="number">1565338891289</span>,[线程:disposeRequestThread-<span class="number">2</span>],com.itsoku.chat24.Demo1.dao(Demo1.java:<span class="number">51</span>):插入数据数据<span class="number">1</span>成功</span><br><span class="line">****<span class="number">1565338891289</span>,[线程:disposeRequestThread-<span class="number">2</span>],com.itsoku.chat24.Demo1.dao(Demo1.java:<span class="number">51</span>):插入数据数据<span class="number">2</span>成功</span><br></pre></td></tr></table></figure><p>代码中调用controller、service、dao 3个方法时，来模拟处理一个请求。main方法中循环了5次模拟发起5次请求，然后交给线程池去处理请求，dao中模拟循环插入传入的dataList数据。</p><p><strong>问题来了：开发者想看一下哪些地方耗时比较多，想通过日志来分析耗时情况，想追踪某个请求的完整日志，怎么搞？</strong></p><p>上面的请求采用线程池的方式处理的，多个请求可能会被一个线程处理，通过日志很难看出那些日志是同一个请求，我们能不能给请求加一个唯一标志，日志中输出这个唯一标志，当然可以。</p><p>如果我们的代码就只有上面示例这么简单，我想还是很容易的，上面就3个方法，给每个方法加个traceId参数，log方法也加个traceId参数，就解决了，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingDeque;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo2</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">threadIndex</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//创建处理请求的线程池子</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">ThreadPoolExecutor</span> <span class="variable">disposeRequestExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">3</span>,</span><br><span class="line">            <span class="number">3</span>,</span><br><span class="line">            <span class="number">60</span>,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">LinkedBlockingDeque</span>&lt;&gt;(),</span><br><span class="line">            r -&gt; &#123;</span><br><span class="line">                <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">                thread.setName(<span class="string">&quot;disposeRequestThread-&quot;</span> + threadIndex.getAndIncrement());</span><br><span class="line">                <span class="keyword">return</span> thread;</span><br><span class="line">            &#125;);</span><br><span class="line">    <span class="comment">//记录日志</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String msg, String traceId)</span> &#123;</span><br><span class="line">        StackTraceElement stack[] = (<span class="keyword">new</span> <span class="title class_">Throwable</span>()).getStackTrace();</span><br><span class="line">        System.out.println(<span class="string">&quot;****&quot;</span> + System.currentTimeMillis() + <span class="string">&quot;[traceId:&quot;</span> + traceId + <span class="string">&quot;],[线程:&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;],&quot;</span> + stack[<span class="number">1</span>] + <span class="string">&quot;:&quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//模拟controller</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">controller</span><span class="params">(List&lt;String&gt; dataList, String traceId)</span> &#123;</span><br><span class="line">        log(<span class="string">&quot;接受请求&quot;</span>, traceId);</span><br><span class="line">        service(dataList, traceId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//模拟service</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(List&lt;String&gt; dataList, String traceId)</span> &#123;</span><br><span class="line">        log(<span class="string">&quot;执行业务&quot;</span>, traceId);</span><br><span class="line">        dao(dataList, traceId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//模拟dao</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dao</span><span class="params">(List&lt;String&gt; dataList, String traceId)</span> &#123;</span><br><span class="line">        log(<span class="string">&quot;执行数据库操作&quot;</span>, traceId);</span><br><span class="line">        <span class="comment">//模拟插入数据</span></span><br><span class="line">        <span class="keyword">for</span> (String s : dataList) &#123;</span><br><span class="line">            log(<span class="string">&quot;插入数据&quot;</span> + s + <span class="string">&quot;成功&quot;</span>, traceId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//需要插入的数据</span></span><br><span class="line">        List&lt;String&gt; dataList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            dataList.add(<span class="string">&quot;数据&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//模拟5个请求</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">requestCount</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; requestCount; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">traceId</span> <span class="operator">=</span> String.valueOf(i);</span><br><span class="line">            disposeRequestExecutor.execute(() -&gt; &#123;</span><br><span class="line">                controller(dataList, traceId);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        disposeRequestExecutor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">****<span class="number">1565339559773</span>[traceId:<span class="number">0</span>],[线程:disposeRequestThread-<span class="number">1</span>],com.itsoku.chat24.Demo2.controller(Demo2.java:<span class="number">36</span>):接受请求</span><br><span class="line">****<span class="number">1565339559773</span>[traceId:<span class="number">1</span>],[线程:disposeRequestThread-<span class="number">2</span>],com.itsoku.chat24.Demo2.controller(Demo2.java:<span class="number">36</span>):接受请求</span><br><span class="line">****<span class="number">1565339559773</span>[traceId:<span class="number">2</span>],[线程:disposeRequestThread-<span class="number">3</span>],com.itsoku.chat24.Demo2.controller(Demo2.java:<span class="number">36</span>):接受请求</span><br><span class="line">****<span class="number">1565339559774</span>[traceId:<span class="number">1</span>],[线程:disposeRequestThread-<span class="number">2</span>],com.itsoku.chat24.Demo2.service(Demo2.java:<span class="number">42</span>):执行业务</span><br><span class="line">****<span class="number">1565339559774</span>[traceId:<span class="number">0</span>],[线程:disposeRequestThread-<span class="number">1</span>],com.itsoku.chat24.Demo2.service(Demo2.java:<span class="number">42</span>):执行业务</span><br><span class="line">****<span class="number">1565339559774</span>[traceId:<span class="number">1</span>],[线程:disposeRequestThread-<span class="number">2</span>],com.itsoku.chat24.Demo2.dao(Demo2.java:<span class="number">48</span>):执行数据库操作</span><br><span class="line">****<span class="number">1565339559774</span>[traceId:<span class="number">2</span>],[线程:disposeRequestThread-<span class="number">3</span>],com.itsoku.chat24.Demo2.service(Demo2.java:<span class="number">42</span>):执行业务</span><br><span class="line">****<span class="number">1565339559774</span>[traceId:<span class="number">1</span>],[线程:disposeRequestThread-<span class="number">2</span>],com.itsoku.chat24.Demo2.dao(Demo2.java:<span class="number">51</span>):插入数据数据<span class="number">0</span>成功</span><br><span class="line">****<span class="number">1565339559774</span>[traceId:<span class="number">0</span>],[线程:disposeRequestThread-<span class="number">1</span>],com.itsoku.chat24.Demo2.dao(Demo2.java:<span class="number">48</span>):执行数据库操作</span><br><span class="line">****<span class="number">1565339559774</span>[traceId:<span class="number">1</span>],[线程:disposeRequestThread-<span class="number">2</span>],com.itsoku.chat24.Demo2.dao(Demo2.java:<span class="number">51</span>):插入数据数据<span class="number">1</span>成功</span><br><span class="line">****<span class="number">1565339559774</span>[traceId:<span class="number">2</span>],[线程:disposeRequestThread-<span class="number">3</span>],com.itsoku.chat24.Demo2.dao(Demo2.java:<span class="number">48</span>):执行数据库操作</span><br><span class="line">****<span class="number">1565339559774</span>[traceId:<span class="number">1</span>],[线程:disposeRequestThread-<span class="number">2</span>],com.itsoku.chat24.Demo2.dao(Demo2.java:<span class="number">51</span>):插入数据数据<span class="number">2</span>成功</span><br><span class="line">****<span class="number">1565339559774</span>[traceId:<span class="number">0</span>],[线程:disposeRequestThread-<span class="number">1</span>],com.itsoku.chat24.Demo2.dao(Demo2.java:<span class="number">51</span>):插入数据数据<span class="number">0</span>成功</span><br><span class="line">****<span class="number">1565339559775</span>[traceId:<span class="number">3</span>],[线程:disposeRequestThread-<span class="number">2</span>],com.itsoku.chat24.Demo2.controller(Demo2.java:<span class="number">36</span>):接受请求</span><br><span class="line">****<span class="number">1565339559775</span>[traceId:<span class="number">2</span>],[线程:disposeRequestThread-<span class="number">3</span>],com.itsoku.chat24.Demo2.dao(Demo2.java:<span class="number">51</span>):插入数据数据<span class="number">0</span>成功</span><br><span class="line">****<span class="number">1565339559775</span>[traceId:<span class="number">3</span>],[线程:disposeRequestThread-<span class="number">2</span>],com.itsoku.chat24.Demo2.service(Demo2.java:<span class="number">42</span>):执行业务</span><br><span class="line">****<span class="number">1565339559775</span>[traceId:<span class="number">0</span>],[线程:disposeRequestThread-<span class="number">1</span>],com.itsoku.chat24.Demo2.dao(Demo2.java:<span class="number">51</span>):插入数据数据<span class="number">1</span>成功</span><br><span class="line">****<span class="number">1565339559775</span>[traceId:<span class="number">3</span>],[线程:disposeRequestThread-<span class="number">2</span>],com.itsoku.chat24.Demo2.dao(Demo2.java:<span class="number">48</span>):执行数据库操作</span><br><span class="line">****<span class="number">1565339559775</span>[traceId:<span class="number">2</span>],[线程:disposeRequestThread-<span class="number">3</span>],com.itsoku.chat24.Demo2.dao(Demo2.java:<span class="number">51</span>):插入数据数据<span class="number">1</span>成功</span><br><span class="line">****<span class="number">1565339559775</span>[traceId:<span class="number">3</span>],[线程:disposeRequestThread-<span class="number">2</span>],com.itsoku.chat24.Demo2.dao(Demo2.java:<span class="number">51</span>):插入数据数据<span class="number">0</span>成功</span><br><span class="line">****<span class="number">1565339559775</span>[traceId:<span class="number">0</span>],[线程:disposeRequestThread-<span class="number">1</span>],com.itsoku.chat24.Demo2.dao(Demo2.java:<span class="number">51</span>):插入数据数据<span class="number">2</span>成功</span><br><span class="line">****<span class="number">1565339559775</span>[traceId:<span class="number">3</span>],[线程:disposeRequestThread-<span class="number">2</span>],com.itsoku.chat24.Demo2.dao(Demo2.java:<span class="number">51</span>):插入数据数据<span class="number">1</span>成功</span><br><span class="line">****<span class="number">1565339559775</span>[traceId:<span class="number">2</span>],[线程:disposeRequestThread-<span class="number">3</span>],com.itsoku.chat24.Demo2.dao(Demo2.java:<span class="number">51</span>):插入数据数据<span class="number">2</span>成功</span><br><span class="line">****<span class="number">1565339559775</span>[traceId:<span class="number">3</span>],[线程:disposeRequestThread-<span class="number">2</span>],com.itsoku.chat24.Demo2.dao(Demo2.java:<span class="number">51</span>):插入数据数据<span class="number">2</span>成功</span><br><span class="line">****<span class="number">1565339559775</span>[traceId:<span class="number">4</span>],[线程:disposeRequestThread-<span class="number">1</span>],com.itsoku.chat24.Demo2.controller(Demo2.java:<span class="number">36</span>):接受请求</span><br><span class="line">****<span class="number">1565339559776</span>[traceId:<span class="number">4</span>],[线程:disposeRequestThread-<span class="number">1</span>],com.itsoku.chat24.Demo2.service(Demo2.java:<span class="number">42</span>):执行业务</span><br><span class="line">****<span class="number">1565339559776</span>[traceId:<span class="number">4</span>],[线程:disposeRequestThread-<span class="number">1</span>],com.itsoku.chat24.Demo2.dao(Demo2.java:<span class="number">48</span>):执行数据库操作</span><br><span class="line">****<span class="number">1565339559776</span>[traceId:<span class="number">4</span>],[线程:disposeRequestThread-<span class="number">1</span>],com.itsoku.chat24.Demo2.dao(Demo2.java:<span class="number">51</span>):插入数据数据<span class="number">0</span>成功</span><br><span class="line">****<span class="number">1565339559776</span>[traceId:<span class="number">4</span>],[线程:disposeRequestThread-<span class="number">1</span>],com.itsoku.chat24.Demo2.dao(Demo2.java:<span class="number">51</span>):插入数据数据<span class="number">1</span>成功</span><br><span class="line">****<span class="number">1565339559776</span>[traceId:<span class="number">4</span>],[线程:disposeRequestThread-<span class="number">1</span>],com.itsoku.chat24.Demo2.dao(Demo2.java:<span class="number">51</span>):插入数据数据<span class="number">2</span>成功</span><br></pre></td></tr></table></figure><p>上面我们通过修改代码的方式，把问题解决了，但前提是你们的系统都像上面这么简单，功能很少，需要改的代码很少，可以这么去改。但事与愿违，我们的系统一般功能都是比较多的，如果我们都一个个去改，岂不是要疯掉，改代码还涉及到重新测试，风险也不可控。那有什么好办法么？</p><p><strong>ThreadLocal</strong></p><p>还是拿上面的问题，我们来分析一下，每个请求都是由一个线程处理的，线程就相当于一个人一样，每个请求相当于一个任务，任务来了，人来处理，处理完毕之后，再处理下一个请求任务。人身上是不是有很多口袋，人刚开始准备处理任务的时候，我们把任务的编号放在处理者的口袋中，然后处理中一路携带者，处理过程中如果需要用到这个编号，直接从口袋中获取就可以了。那么刚好java中线程设计的时候也考虑到了这些问题，Thread对象中就有很多口袋，用来放东西。Thread类中有这么一个变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">threadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>如何来操作Thread中的这些口袋呢，java为我们提供了一个类<code>ThreadLocal</code>，ThreadLocal对象用来操作Thread中的某一个口袋，可以向这个口袋中放东西、获取里面的东西、清除里面的东西，这个口袋一次性只能放一个东西，重复放东西会将里面已经存在的东西覆盖掉。</p><p>常用的3个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//向Thread中某个口袋中放东西</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span>;</span><br><span class="line"><span class="comment">//获取这个口袋中目前放的东西</span></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//清空这个口袋中放的东西</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span></span><br></pre></td></tr></table></figure><p>我们使用ThreadLocal来改造一下上面的代码，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingDeque;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo3</span> &#123;</span><br><span class="line">    <span class="comment">//创建一个操作Thread中存放请求任务追踪id口袋的对象</span></span><br><span class="line">    <span class="keyword">static</span> ThreadLocal&lt;String&gt; traceIdKD = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">threadIndex</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//创建处理请求的线程池子</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">ThreadPoolExecutor</span> <span class="variable">disposeRequestExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">3</span>,</span><br><span class="line">            <span class="number">3</span>,</span><br><span class="line">            <span class="number">60</span>,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">LinkedBlockingDeque</span>&lt;&gt;(),</span><br><span class="line">            r -&gt; &#123;</span><br><span class="line">                <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">                thread.setName(<span class="string">&quot;disposeRequestThread-&quot;</span> + threadIndex.getAndIncrement());</span><br><span class="line">                <span class="keyword">return</span> thread;</span><br><span class="line">            &#125;);</span><br><span class="line">    <span class="comment">//记录日志</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        StackTraceElement stack[] = (<span class="keyword">new</span> <span class="title class_">Throwable</span>()).getStackTrace();</span><br><span class="line">        <span class="comment">//获取当前线程存放tranceId口袋中的内容</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">traceId</span> <span class="operator">=</span> traceIdKD.get();</span><br><span class="line">        System.out.println(<span class="string">&quot;****&quot;</span> + System.currentTimeMillis() + <span class="string">&quot;[traceId:&quot;</span> + traceId + <span class="string">&quot;],[线程:&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;],&quot;</span> + stack[<span class="number">1</span>] + <span class="string">&quot;:&quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//模拟controller</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">controller</span><span class="params">(List&lt;String&gt; dataList)</span> &#123;</span><br><span class="line">        log(<span class="string">&quot;接受请求&quot;</span>);</span><br><span class="line">        service(dataList);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//模拟service</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(List&lt;String&gt; dataList)</span> &#123;</span><br><span class="line">        log(<span class="string">&quot;执行业务&quot;</span>);</span><br><span class="line">        dao(dataList);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//模拟dao</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dao</span><span class="params">(List&lt;String&gt; dataList)</span> &#123;</span><br><span class="line">        log(<span class="string">&quot;执行数据库操作&quot;</span>);</span><br><span class="line">        <span class="comment">//模拟插入数据</span></span><br><span class="line">        <span class="keyword">for</span> (String s : dataList) &#123;</span><br><span class="line">            log(<span class="string">&quot;插入数据&quot;</span> + s + <span class="string">&quot;成功&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//需要插入的数据</span></span><br><span class="line">        List&lt;String&gt; dataList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            dataList.add(<span class="string">&quot;数据&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//模拟5个请求</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">requestCount</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; requestCount; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">traceId</span> <span class="operator">=</span> String.valueOf(i);</span><br><span class="line">            disposeRequestExecutor.execute(() -&gt; &#123;</span><br><span class="line">                <span class="comment">//把traceId放入口袋中</span></span><br><span class="line">                traceIdKD.set(traceId);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    controller(dataList);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//将tranceId从口袋中移除</span></span><br><span class="line">                    traceIdKD.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        disposeRequestExecutor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">****<span class="number">1565339644214</span>[traceId:<span class="number">1</span>],[线程:disposeRequestThread-<span class="number">2</span>],com.itsoku.chat24.Demo3.controller(Demo3.java:<span class="number">41</span>):接受请求</span><br><span class="line">****<span class="number">1565339644214</span>[traceId:<span class="number">2</span>],[线程:disposeRequestThread-<span class="number">3</span>],com.itsoku.chat24.Demo3.controller(Demo3.java:<span class="number">41</span>):接受请求</span><br><span class="line">****<span class="number">1565339644214</span>[traceId:<span class="number">0</span>],[线程:disposeRequestThread-<span class="number">1</span>],com.itsoku.chat24.Demo3.controller(Demo3.java:<span class="number">41</span>):接受请求</span><br><span class="line">****<span class="number">1565339644214</span>[traceId:<span class="number">2</span>],[线程:disposeRequestThread-<span class="number">3</span>],com.itsoku.chat24.Demo3.service(Demo3.java:<span class="number">47</span>):执行业务</span><br><span class="line">****<span class="number">1565339644214</span>[traceId:<span class="number">1</span>],[线程:disposeRequestThread-<span class="number">2</span>],com.itsoku.chat24.Demo3.service(Demo3.java:<span class="number">47</span>):执行业务</span><br><span class="line">****<span class="number">1565339644214</span>[traceId:<span class="number">2</span>],[线程:disposeRequestThread-<span class="number">3</span>],com.itsoku.chat24.Demo3.dao(Demo3.java:<span class="number">53</span>):执行数据库操作</span><br><span class="line">****<span class="number">1565339644214</span>[traceId:<span class="number">0</span>],[线程:disposeRequestThread-<span class="number">1</span>],com.itsoku.chat24.Demo3.service(Demo3.java:<span class="number">47</span>):执行业务</span><br><span class="line">****<span class="number">1565339644214</span>[traceId:<span class="number">2</span>],[线程:disposeRequestThread-<span class="number">3</span>],com.itsoku.chat24.Demo3.dao(Demo3.java:<span class="number">56</span>):插入数据数据<span class="number">0</span>成功</span><br><span class="line">****<span class="number">1565339644214</span>[traceId:<span class="number">0</span>],[线程:disposeRequestThread-<span class="number">1</span>],com.itsoku.chat24.Demo3.dao(Demo3.java:<span class="number">53</span>):执行数据库操作</span><br><span class="line">****<span class="number">1565339644214</span>[traceId:<span class="number">1</span>],[线程:disposeRequestThread-<span class="number">2</span>],com.itsoku.chat24.Demo3.dao(Demo3.java:<span class="number">53</span>):执行数据库操作</span><br><span class="line">****<span class="number">1565339644215</span>[traceId:<span class="number">0</span>],[线程:disposeRequestThread-<span class="number">1</span>],com.itsoku.chat24.Demo3.dao(Demo3.java:<span class="number">56</span>):插入数据数据<span class="number">0</span>成功</span><br><span class="line">****<span class="number">1565339644215</span>[traceId:<span class="number">2</span>],[线程:disposeRequestThread-<span class="number">3</span>],com.itsoku.chat24.Demo3.dao(Demo3.java:<span class="number">56</span>):插入数据数据<span class="number">1</span>成功</span><br><span class="line">****<span class="number">1565339644215</span>[traceId:<span class="number">0</span>],[线程:disposeRequestThread-<span class="number">1</span>],com.itsoku.chat24.Demo3.dao(Demo3.java:<span class="number">56</span>):插入数据数据<span class="number">1</span>成功</span><br><span class="line">****<span class="number">1565339644215</span>[traceId:<span class="number">1</span>],[线程:disposeRequestThread-<span class="number">2</span>],com.itsoku.chat24.Demo3.dao(Demo3.java:<span class="number">56</span>):插入数据数据<span class="number">0</span>成功</span><br><span class="line">****<span class="number">1565339644215</span>[traceId:<span class="number">0</span>],[线程:disposeRequestThread-<span class="number">1</span>],com.itsoku.chat24.Demo3.dao(Demo3.java:<span class="number">56</span>):插入数据数据<span class="number">2</span>成功</span><br><span class="line">****<span class="number">1565339644215</span>[traceId:<span class="number">2</span>],[线程:disposeRequestThread-<span class="number">3</span>],com.itsoku.chat24.Demo3.dao(Demo3.java:<span class="number">56</span>):插入数据数据<span class="number">2</span>成功</span><br><span class="line">****<span class="number">1565339644215</span>[traceId:<span class="number">1</span>],[线程:disposeRequestThread-<span class="number">2</span>],com.itsoku.chat24.Demo3.dao(Demo3.java:<span class="number">56</span>):插入数据数据<span class="number">1</span>成功</span><br><span class="line">****<span class="number">1565339644215</span>[traceId:<span class="number">4</span>],[线程:disposeRequestThread-<span class="number">3</span>],com.itsoku.chat24.Demo3.controller(Demo3.java:<span class="number">41</span>):接受请求</span><br><span class="line">****<span class="number">1565339644215</span>[traceId:<span class="number">3</span>],[线程:disposeRequestThread-<span class="number">1</span>],com.itsoku.chat24.Demo3.controller(Demo3.java:<span class="number">41</span>):接受请求</span><br><span class="line">****<span class="number">1565339644215</span>[traceId:<span class="number">4</span>],[线程:disposeRequestThread-<span class="number">3</span>],com.itsoku.chat24.Demo3.service(Demo3.java:<span class="number">47</span>):执行业务</span><br><span class="line">****<span class="number">1565339644215</span>[traceId:<span class="number">1</span>],[线程:disposeRequestThread-<span class="number">2</span>],com.itsoku.chat24.Demo3.dao(Demo3.java:<span class="number">56</span>):插入数据数据<span class="number">2</span>成功</span><br><span class="line">****<span class="number">1565339644215</span>[traceId:<span class="number">4</span>],[线程:disposeRequestThread-<span class="number">3</span>],com.itsoku.chat24.Demo3.dao(Demo3.java:<span class="number">53</span>):执行数据库操作</span><br><span class="line">****<span class="number">1565339644215</span>[traceId:<span class="number">3</span>],[线程:disposeRequestThread-<span class="number">1</span>],com.itsoku.chat24.Demo3.service(Demo3.java:<span class="number">47</span>):执行业务</span><br><span class="line">****<span class="number">1565339644215</span>[traceId:<span class="number">4</span>],[线程:disposeRequestThread-<span class="number">3</span>],com.itsoku.chat24.Demo3.dao(Demo3.java:<span class="number">56</span>):插入数据数据<span class="number">0</span>成功</span><br><span class="line">****<span class="number">1565339644215</span>[traceId:<span class="number">3</span>],[线程:disposeRequestThread-<span class="number">1</span>],com.itsoku.chat24.Demo3.dao(Demo3.java:<span class="number">53</span>):执行数据库操作</span><br><span class="line">****<span class="number">1565339644215</span>[traceId:<span class="number">4</span>],[线程:disposeRequestThread-<span class="number">3</span>],com.itsoku.chat24.Demo3.dao(Demo3.java:<span class="number">56</span>):插入数据数据<span class="number">1</span>成功</span><br><span class="line">****<span class="number">1565339644215</span>[traceId:<span class="number">3</span>],[线程:disposeRequestThread-<span class="number">1</span>],com.itsoku.chat24.Demo3.dao(Demo3.java:<span class="number">56</span>):插入数据数据<span class="number">0</span>成功</span><br><span class="line">****<span class="number">1565339644215</span>[traceId:<span class="number">4</span>],[线程:disposeRequestThread-<span class="number">3</span>],com.itsoku.chat24.Demo3.dao(Demo3.java:<span class="number">56</span>):插入数据数据<span class="number">2</span>成功</span><br><span class="line">****<span class="number">1565339644215</span>[traceId:<span class="number">3</span>],[线程:disposeRequestThread-<span class="number">1</span>],com.itsoku.chat24.Demo3.dao(Demo3.java:<span class="number">56</span>):插入数据数据<span class="number">1</span>成功</span><br><span class="line">****<span class="number">1565339644215</span>[traceId:<span class="number">3</span>],[线程:disposeRequestThread-<span class="number">1</span>],com.itsoku.chat24.Demo3.dao(Demo3.java:<span class="number">56</span>):插入数据数据<span class="number">2</span>成功</span><br></pre></td></tr></table></figure><p>可以看出输出和刚才使用traceId参数的方式结果一致，但是却简单了很多。不用去修改controller、service、dao代码了，风险也减少了很多。</p><p>代码中创建了一个<code>ThreadLocal traceIdKD</code>，这个对象用来操作Thread中一个口袋，用这个口袋来存放tranceId。在main方法中通过<code>traceIdKD.set(traceId)</code>方法将traceId放入口袋，log方法中通<code>traceIdKD.get()</code>获取口袋中的traceId，最后任务处理完之后，main中的finally中调用<code>traceIdKD.remove();</code>将口袋中的traceId清除。</p><p><strong>ThreadLocal的官方API解释为：</strong></p><blockquote><p>“该类提供了线程局部 (thread-local) 变量。这些变量不同于它们的普通对应物，因为访问某个变量（通过其 get 或 set 方法）的每个线程都有自己的局部变量，它独立于变量的初始化副本。ThreadLocal 实例通常是类中的 private static 字段，它们希望将状态与某一个线程（例如，用户 ID 或事务 ID）相关联。”</p></blockquote><p><strong>InheritableThreadLocal</strong></p><p>继续上面的实例，dao中循环处理dataList的内容，假如dataList处理比较耗时，我们想加快处理速度有什么办法么？大家已经想到了，用多线程并行处理<code>dataList</code>，那么我们把代码改一下，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingDeque;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo4</span> &#123;</span><br><span class="line">    <span class="comment">//创建一个操作Thread中存放请求任务追踪id口袋的对象</span></span><br><span class="line">    <span class="keyword">static</span> ThreadLocal&lt;String&gt; traceIdKD = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">threadIndex</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//创建处理请求的线程池子</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">ThreadPoolExecutor</span> <span class="variable">disposeRequestExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">3</span>,</span><br><span class="line">            <span class="number">3</span>,</span><br><span class="line">            <span class="number">60</span>,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">LinkedBlockingDeque</span>&lt;&gt;(),</span><br><span class="line">            r -&gt; &#123;</span><br><span class="line">                <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">                thread.setName(<span class="string">&quot;disposeRequestThread-&quot;</span> + threadIndex.getAndIncrement());</span><br><span class="line">                <span class="keyword">return</span> thread;</span><br><span class="line">            &#125;);</span><br><span class="line">    <span class="comment">//记录日志</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        StackTraceElement stack[] = (<span class="keyword">new</span> <span class="title class_">Throwable</span>()).getStackTrace();</span><br><span class="line">        <span class="comment">//获取当前线程存放tranceId口袋中的内容</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">traceId</span> <span class="operator">=</span> traceIdKD.get();</span><br><span class="line">        System.out.println(<span class="string">&quot;****&quot;</span> + System.currentTimeMillis() + <span class="string">&quot;[traceId:&quot;</span> + traceId + <span class="string">&quot;],[线程:&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;],&quot;</span> + stack[<span class="number">1</span>] + <span class="string">&quot;:&quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//模拟controller</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">controller</span><span class="params">(List&lt;String&gt; dataList)</span> &#123;</span><br><span class="line">        log(<span class="string">&quot;接受请求&quot;</span>);</span><br><span class="line">        service(dataList);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//模拟service</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(List&lt;String&gt; dataList)</span> &#123;</span><br><span class="line">        log(<span class="string">&quot;执行业务&quot;</span>);</span><br><span class="line">        dao(dataList);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//模拟dao</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dao</span><span class="params">(List&lt;String&gt; dataList)</span> &#123;</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(dataList.size());</span><br><span class="line">        log(<span class="string">&quot;执行数据库操作&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">threadName</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">        <span class="comment">//模拟插入数据</span></span><br><span class="line">        <span class="keyword">for</span> (String s : dataList) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//模拟数据库操作耗时100毫秒</span></span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">                    log(<span class="string">&quot;插入数据&quot;</span> + s + <span class="string">&quot;成功,主线程：&quot;</span> + threadName);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//等待上面的dataList处理完毕</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            countDownLatch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//需要插入的数据</span></span><br><span class="line">        List&lt;String&gt; dataList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            dataList.add(<span class="string">&quot;数据&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//模拟5个请求</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">requestCount</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; requestCount; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">traceId</span> <span class="operator">=</span> String.valueOf(i);</span><br><span class="line">            disposeRequestExecutor.execute(() -&gt; &#123;</span><br><span class="line">                <span class="comment">//把traceId放入口袋中</span></span><br><span class="line">                traceIdKD.set(traceId);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    controller(dataList);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//将tranceId从口袋中移除</span></span><br><span class="line">                    traceIdKD.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        disposeRequestExecutor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下上面的输出，有些traceId为null，这是为什么呢？这是因为dao中为了提升处理速度，创建了子线程来并行处理，子线程调用log的时候，去自己的存放traceId的口袋中拿去东西，肯定是空的了。</p><p>那有什么办法么？可不可以这样？</p><p>父线程相当于主管，子线程相当于干活的小弟，主管让小弟们干活的时候，将自己兜里面的东西复制一份给小弟们使用，主管兜里面可能有很多牛逼的工具，为了提升小弟们的工作效率，给小弟们都复制一个，丢到小弟们的兜里，然后小弟就可以从自己的兜里拿去这些东西使用了，也可以清空自己兜里面的东西。</p><p><code>Thread</code>对象中有个<code>inheritableThreadLocals</code>变量，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">inheritableThreadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>inheritableThreadLocals相当于线程中另外一种兜，这种兜有什么特征呢，当创建子线程的时候，子线程会将父线程这种类型兜的东西全部复制一份放到自己的<code>inheritableThreadLocals</code>兜中，使用<code>InheritableThreadLocal</code>对象可以操作线程中的<code>inheritableThreadLocals</code>兜。</p><p><code>InheritableThreadLocal</code>常用的方法也有3个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//向Thread中某个口袋中放东西</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span>;</span><br><span class="line"><span class="comment">//获取这个口袋中目前放的东西</span></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//清空这个口袋中放的东西</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span></span><br></pre></td></tr></table></figure><p>使用<code>InheritableThreadLocal</code>解决上面子线程中无法输出traceId的问题，只需要将上一个示例代码中的<code>ThreadLocal</code>替换成<code>InheritableThreadLocal</code>即可，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingDeque;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 跟着阿里p7学并发，微信公众号：javacode2018</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo4</span> &#123;</span><br><span class="line">    <span class="comment">//创建一个操作Thread中存放请求任务追踪id口袋的对象,子线程可以继承父线程中内容</span></span><br><span class="line">    <span class="keyword">static</span> InheritableThreadLocal&lt;String&gt; traceIdKD = <span class="keyword">new</span> <span class="title class_">InheritableThreadLocal</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">threadIndex</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//创建处理请求的线程池子</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">ThreadPoolExecutor</span> <span class="variable">disposeRequestExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">3</span>,</span><br><span class="line">            <span class="number">3</span>,</span><br><span class="line">            <span class="number">60</span>,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">LinkedBlockingDeque</span>&lt;&gt;(),</span><br><span class="line">            r -&gt; &#123;</span><br><span class="line">                <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">                thread.setName(<span class="string">&quot;disposeRequestThread-&quot;</span> + threadIndex.getAndIncrement());</span><br><span class="line">                <span class="keyword">return</span> thread;</span><br><span class="line">            &#125;);</span><br><span class="line">    <span class="comment">//记录日志</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        StackTraceElement stack[] = (<span class="keyword">new</span> <span class="title class_">Throwable</span>()).getStackTrace();</span><br><span class="line">        <span class="comment">//获取当前线程存放tranceId口袋中的内容</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">traceId</span> <span class="operator">=</span> traceIdKD.get();</span><br><span class="line">        System.out.println(<span class="string">&quot;****&quot;</span> + System.currentTimeMillis() + <span class="string">&quot;[traceId:&quot;</span> + traceId + <span class="string">&quot;],[线程:&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;],&quot;</span> + stack[<span class="number">1</span>] + <span class="string">&quot;:&quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//模拟controller</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">controller</span><span class="params">(List&lt;String&gt; dataList)</span> &#123;</span><br><span class="line">        log(<span class="string">&quot;接受请求&quot;</span>);</span><br><span class="line">        service(dataList);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//模拟service</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(List&lt;String&gt; dataList)</span> &#123;</span><br><span class="line">        log(<span class="string">&quot;执行业务&quot;</span>);</span><br><span class="line">        dao(dataList);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//模拟dao</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dao</span><span class="params">(List&lt;String&gt; dataList)</span> &#123;</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(dataList.size());</span><br><span class="line">        log(<span class="string">&quot;执行数据库操作&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">threadName</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">        <span class="comment">//模拟插入数据</span></span><br><span class="line">        <span class="keyword">for</span> (String s : dataList) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//模拟数据库操作耗时100毫秒</span></span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">                    log(<span class="string">&quot;插入数据&quot;</span> + s + <span class="string">&quot;成功,主线程：&quot;</span> + threadName);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//等待上面的dataList处理完毕</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            countDownLatch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//需要插入的数据</span></span><br><span class="line">        List&lt;String&gt; dataList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            dataList.add(<span class="string">&quot;数据&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//模拟5个请求</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">requestCount</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; requestCount; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">traceId</span> <span class="operator">=</span> String.valueOf(i);</span><br><span class="line">            disposeRequestExecutor.execute(() -&gt; &#123;</span><br><span class="line">                <span class="comment">//把traceId放入口袋中</span></span><br><span class="line">                traceIdKD.set(traceId);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    controller(dataList);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//将tranceId从口袋中移除</span></span><br><span class="line">                    traceIdKD.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        disposeRequestExecutor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="十四、Java对象内存布局和对象头"><a href="#十四、Java对象内存布局和对象头" class="headerlink" title="十四、Java对象内存布局和对象头"></a>十四、Java对象内存布局和对象头</h2><h3 id="1、对象在堆内存中布局"><a href="#1、对象在堆内存中布局" class="headerlink" title="1、对象在堆内存中布局"></a>1、对象在堆内存中布局</h3><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210927225655948.png" alt="image-20210927225655948"></p><h4 id="1、对象在堆内存中的存储布局"><a href="#1、对象在堆内存中的存储布局" class="headerlink" title="1、对象在堆内存中的存储布局"></a>1、对象在堆内存中的存储布局</h4><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210927225734825.png" alt="image-20210927225734825"></p><p>对象内部结构分为：对象头、实例数据、对齐填充（保证8个字节的倍数）。<br>对象头分为对象标记（markOop）和类元信息（klassOop），类元信息存储的是指向该对象类元数据（klass）的首地址。</p><h4 id="2、对象头"><a href="#2、对象头" class="headerlink" title="2、对象头"></a>2、对象头</h4><h5 id="1、对象标记Mark-Word"><a href="#1、对象标记Mark-Word" class="headerlink" title="1、对象标记Mark Word"></a>1、对象标记Mark Word</h5><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210927225858356.png" alt="image-20210927225858356"></p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210927225903931.png" alt="image-20210927225903931"></p><p>在64位系统中，Mark Word占了8个字节，类型指针占了8个字节，一共是16个字节</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210927225919957.png" alt="image-20210927225919957"></p><p>​默认存储对象的HashCode、分代年龄和锁标志位等信息。这些信息都是与对象自身定义无关的数据，所以MarkWord被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据。它会根据对象的状态复用自己的存储空间，也就是说在运行期间MarkWord里存储的数据会随着锁标志位的变化而变化。</p><h5 id="2、类元信息-又叫类型指针"><a href="#2、类元信息-又叫类型指针" class="headerlink" title="2、类元信息(又叫类型指针)"></a>2、类元信息(又叫类型指针)</h5><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210927230011055.png" alt="image-20210927230011055"></p><p>对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p><h5 id="3、对象头多大"><a href="#3、对象头多大" class="headerlink" title="3、对象头多大"></a>3、对象头多大</h5><p>在64位系统中，Mark Word占了8个字节，类型指针占了8个字节，一共是16个字节。</p><h4 id="3、实例数据"><a href="#3、实例数据" class="headerlink" title="3、实例数据"></a>3、实例数据</h4><p>存放类的属性(Field)数据信息，包括父类的属性信息，如果是数组的实例部分还包括数组的长度，这部分内存按4字节对齐。</p><h4 id="4、对齐填充"><a href="#4、对齐填充" class="headerlink" title="4、对齐填充"></a>4、对齐填充</h4><p>虚拟机要求对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐这部分内存按8字节补充对齐。</p><p><a href="http://openjdk.java.net/groups/hotspot/docs/HotSpotGlossary.html">http://openjdk.java.net/groups/hotspot/docs/HotSpotGlossary.html</a></p><p><a href="http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/89fb452b3688/src/share/vm/oops/oop.hpp">http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/89fb452b3688/src/share/vm/oops/oop.hpp</a></p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210927230137020.png" alt="image-20210927230137020"></p><p>_mark字段是mark word，_metadata是类指针klass pointer，<br>对象头（object header）即是由这两个字段组成，这些术语可以参考Hotspot术语表，</p><p><img src="/images/1.JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20210927230150668.png" alt="image-20210927230150668"></p><h3 id="2、MarkWord"><a href="#2、MarkWord" class="headerlink" title="2、MarkWord"></a>2、MarkWord</h3><h4 id="1、oop-hpp"><a href="#1、oop-hpp" class="headerlink" title="1、oop.hpp"></a>1、oop.hpp</h4><p><img src="C:\Users\Administrator\Desktop\JUC并发编程\images\1.JUC并发编程\image-20210927230137020.png" alt="image-20210927230137020"></p><h4 id="2、markOop-hpp"><a href="#2、markOop-hpp" class="headerlink" title="2、markOop.hpp"></a>2、markOop.hpp</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hash： 保存对象的哈希码</span><br><span class="line">age： 保存对象的分代年龄</span><br><span class="line">biased_lock： 偏向锁标识位</span><br><span class="line">lock： 锁状态标识位</span><br><span class="line">JavaThread* ：保存持有偏向锁的线程ID</span><br><span class="line">epoch： 保存偏向时间戳</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210927230308057.png" alt="image-20210927230308057"></p><p>markword(64位)分布图，对象布局、GC回收和后面的锁升级就是对象标记MarkWord里面标志位的变化</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210927230321279.png" alt="image-20210927230321279"></p><h3 id="3、聊聊Object-obj-x3D-new-Object"><a href="#3、聊聊Object-obj-x3D-new-Object" class="headerlink" title="3、聊聊Object obj &#x3D; new Object()"></a>3、聊聊Object obj &#x3D; new Object()</h3><h4 id="1、JOL证明"><a href="#1、JOL证明" class="headerlink" title="1、JOL证明"></a>1、JOL证明</h4><p><a href="http://openjdk.java.net/projects/code-tools/jol/">http://openjdk.java.net/projects/code-tools/jol/</a></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">官网：http://openjdk.java.net/projects/code-tools/jol/</span></span><br><span class="line"><span class="comment">定位：分析对象在JVM的大小和分布</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jol<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jol-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyObject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//VM的细节详细情况</span></span><br><span class="line">        System.out.println(VM.current().details());</span><br><span class="line">        <span class="comment">//所有的对象分配的字节都是8的整数倍。</span></span><br><span class="line">        System.out.println(VM.current().objectAlignment());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210927230415577.png" alt="image-20210927230415577"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JOLDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        System.out.println( ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210927230442184.png" alt="image-20210927230442184"></p><table><thead><tr><th>OFFSET</th><th>偏移量，也就是到这个字段位置所占用的byte数</th></tr></thead><tbody><tr><td>SIZE</td><td>后面类型的字节大小</td></tr><tr><td>TYPE</td><td>是Class中定义的类型</td></tr><tr><td>DESCRIPTION</td><td>DESCRIPTION是类型的描述</td></tr><tr><td>VALUE</td><td>VALUE是TYPE在内存中的值</td></tr></tbody></table><p><strong>GC年龄采用4位bit存储，最大为15，例如MaxTenuringThreshold参数默认值就是15</strong></p><p>-XX:MaxTenuringThreshold&#x3D;16</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210927230617433.png" alt="image-20210927230617433"></p><h4 id="2、默认开启压缩说明"><a href="#2、默认开启压缩说明" class="headerlink" title="2、默认开启压缩说明"></a>2、默认开启压缩说明</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+PrintCommandLineFlags -version</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210927230700348.png" alt="image-20210927230700348"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseCompressedClassPointers</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210927230717948.png" alt="image-20210927230717948"></p><p>上述表示开启了类型指针的压缩，以节约空间，假如不加压缩？？？</p><p><strong>手动关闭压缩再看看</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:-UseCompressedClassPointers</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210927230743485.png" alt="image-20210927230743485"></p><h3 id="4、换成其他对象试试"><a href="#4、换成其他对象试试" class="headerlink" title="4、换成其他对象试试"></a>4、换成其他对象试试</h3><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210927230805766.png" alt="image-20210927230805766"></p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210927230808775.png" alt="image-20210927230808775"></p><h2 id="十五、Synchronized与锁升级"><a href="#十五、Synchronized与锁升级" class="headerlink" title="十五、Synchronized与锁升级"></a>十五、Synchronized与锁升级</h2><h3 id="1、Synchronized-锁优化的背景"><a href="#1、Synchronized-锁优化的背景" class="headerlink" title="1、Synchronized 锁优化的背景"></a>1、Synchronized 锁优化的背景</h3><p>用锁能够实现数据的安全性，但是会带来性能下降。<br>无锁能够基于线程并行提升程序性能，但是会带来安全性下降。</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210929210812273.png" alt="image-20210929210812273"></p><p>synchronized锁：由对象头中的Mark Word根据锁标志位的不同而被复用及锁升级策略</p><h3 id="2、Synchronized的性能变化"><a href="#2、Synchronized的性能变化" class="headerlink" title="2、Synchronized的性能变化"></a>2、Synchronized的性能变化</h3><p>java5以前，只有Synchronized，这个是操作系统级别的重量级操作，重量级锁，假如锁的竞争比较激烈的话，性能下降</p><h4 id="1、Java5之前，用户态和内核态之间的切换"><a href="#1、Java5之前，用户态和内核态之间的切换" class="headerlink" title="1、Java5之前，用户态和内核态之间的切换"></a>1、Java5之前，用户态和内核态之间的切换</h4><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210929210932836.png" alt="image-20210929210932836"></p><p>​java的线程是映射到操作系统原生线程之上的，如果要阻塞或唤醒一个线程就需要操作系统介入，需要在户态与核心态之间切换，这种切换会消耗大量的系统资源，因为用户态与内核态都有各自专用的内存空间，专用的寄存器等，用户态切换至内核态需要传递给许多变量、参数给内核，内核也需要保护好用户态在切换时的一些寄存器值、变量等，以便内核态调用结束后切换回用户态继续工作。</p><p>​在Java早期版本中，synchronized属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的Mutex Lock来实现的，挂起线程和恢复线程都需要转入内核态去完成，阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态切换需要耗费处理器时间，如果同步代码块中内容过于简单，这种切换的时间可能比用户代码执行的时间还长”，时间成本相对较高，这也是为什么早期的synchronized效率低的原因<br>Java 6之后，为了减少获得锁和释放锁所带来的性能消耗，引入了轻量级锁和偏向锁</p><h4 id="2、为什么每一个对象都可以成为一个锁？？？？"><a href="#2、为什么每一个对象都可以成为一个锁？？？？" class="headerlink" title="2、为什么每一个对象都可以成为一个锁？？？？"></a>2、为什么每一个对象都可以成为一个锁？？？？</h4><p>markOop.hpp</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210929211015422.png" alt="image-20210929211015422"></p><p>​Monitor可以理解为一种同步工具，也可理解为一种同步机制，常常被描述为一个Java对象。Java对象是天生的Monitor，每一个Java对象都有成为Monitor的潜质，因为在Java的设计中 ，每一个Java对象自打娘胎里出来就带了一把看不见的锁，它叫做内部锁或者Monitor锁。</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210929211037543.png" alt="image-20210929211037543"></p><p>Monitor的本质是依赖于底层操作系统的Mutex Lock实现，操作系统实现线程之间的切换需要从用户态到内核态的转换，成本非常高。</p><p>Monitor(监视器锁)</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210929211107964.png" alt="image-20210929211107964"></p><p>Mutex Lock<br>Monitor是在jvm底层实现的，底层代码是c++。本质是依赖于底层操作系统的Mutex Lock实现，操作系统实现线程之间的切换需要从用户态到内核态的转换，状态转换需要耗费很多的处理器时间成本非常高。所以synchronized是Java语言中的一个重量级操作。</p><p>Monitor与java对象以及线程是如何关联 ？<br>1.如果一个java对象被某个线程锁住，则该java对象的Mark Word字段中LockWord指向monitor的起始地址<br>2.Monitor的Owner字段会存放拥有相关联对象锁的线程id</p><p>Mutex Lock 的切换需要从用户态转换到核心态中，因此状态转换需要耗费很多的处理器时间。</p><h4 id="3、java6开始，优化Synchronized"><a href="#3、java6开始，优化Synchronized" class="headerlink" title="3、java6开始，优化Synchronized"></a>3、java6开始，优化Synchronized</h4><p>Java 6之后，为了减少获得锁和释放锁所带来的性能消耗，引入了轻量级锁和偏向锁</p><p>需要有个逐步升级的过程，别一开始就捅到重量级锁</p><h3 id="3、Synchronized锁种类及升级步骤"><a href="#3、Synchronized锁种类及升级步骤" class="headerlink" title="3、Synchronized锁种类及升级步骤"></a>3、Synchronized锁种类及升级步骤</h3><h4 id="1、多线程访问情况，3种"><a href="#1、多线程访问情况，3种" class="headerlink" title="1、多线程访问情况，3种"></a>1、多线程访问情况，3种</h4><ul><li>只有一个线程来访问，有且唯一Only One</li><li>有2个线程A、B来交替访问</li><li>竞争激烈，多个线程来访问</li></ul><h4 id="2、升级流程"><a href="#2、升级流程" class="headerlink" title="2、升级流程"></a>2、升级流程</h4><p>synchronized用的锁是存在Java对象头里的Mark Word中锁升级功能主要依赖MarkWord中锁标志位和释放偏向锁标志位</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210929211353978.png" alt="image-20210929211353978"></p><h4 id="3、无锁"><a href="#3、无锁" class="headerlink" title="3、无锁"></a>3、无锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyObject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;10进制hash码：&quot;</span>+o.hashCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;16进制hash码：&quot;</span>+Integer.toHexString(o.hashCode()));</span><br><span class="line">        System.out.println(<span class="string">&quot;2进制hash码：&quot;</span>+Integer.toBinaryString(o.hashCode()));</span><br><span class="line"></span><br><span class="line">        System.out.println( ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210929211429008.png" alt="image-20210929211429008"></p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210929211444490.png" alt="image-20210929211444490"></p><h4 id="4、偏向锁"><a href="#4、偏向锁" class="headerlink" title="4、偏向锁"></a>4、偏向锁</h4><ul><li>当一段同步代码一直被同一个线程多次访问，由于只有一个线程那么该线程在后续访问时便会自动获得锁</li><li>同一个老顾客来访，直接老规矩行方便</li></ul><blockquote><p>Hotspot 的作者经过研究发现，大多数情况下：</p><p>多线程的情况下，锁不仅不存在多线程竞争，还存在锁由同一线程多次获得的情况，</p><p>偏向锁就是在这种情况下出现的，它的出现是为了解决只有在一个线程执行同步时提高性能。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210929211553962.png" alt="image-20210929211553962"></p><p>通过CAS方式修改markword中的线程ID</p><h5 id="1、偏向锁的持有"><a href="#1、偏向锁的持有" class="headerlink" title="1、偏向锁的持有"></a>1、偏向锁的持有</h5><p>理论落地：<br>      在实际应用运行过程中发现，“锁总是同一个线程持有，很少发生竞争”，也就是说锁总是被第一个占用他的线程拥有，这个线程就是锁的偏向线程。</p><p>​      那么只需要在锁第一次被拥有的时候，记录下偏向线程ID。这样偏向线程就一直持有着锁(后续这个线程进入和退出这段加了同步锁的代码块时，不需要再次加锁和释放锁。而是直接比较对象头里面是否存储了指向当前线程的偏向锁)。<br>如果相等表示偏向锁是偏向于当前线程的，就不需要再尝试获得锁了，直到竞争发生才释放锁。以后每次同步，检查锁的偏向线程ID与当前线程ID是否一致，如果一致直接进入同步。无需每次加锁解锁都去CAS更新对象头。如果自始至终使用锁的线程只有一个，很明显偏向锁几乎没有额外开销，性能极高。</p><p>​      假如不一致意味着发生了竞争，锁已经不是总是偏向于同一个线程了，这时候可能需要升级变为轻量级锁，才能保证线程间公平竞争锁。偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程是不会主动释放偏向锁的。</p><p>技术实现：<br>        一个synchronized方法被一个线程抢到了锁时，那这个方法所在的对象就会在其所在的Mark Word中将偏向锁修改状态位，同时还<br>会有占用前54位来存储线程指针作为标识。若该线程再次访问同一个synchronized方法时，该线程只需去对象头的Mark Word 中去判断一下是否有偏向锁指向本身的ID，无需再进入 Monitor 去竞争对象了。</p><h5 id="2、细化案例Account对象举例说明"><a href="#2、细化案例Account对象举例说明" class="headerlink" title="2、细化案例Account对象举例说明"></a>2、细化案例Account对象举例说明</h5><p>偏向锁的操作不用直接捅到操作系统，不涉及用户到内核转换，不必要直接升级为最高级，我们以一个account对象的“对象头”为例，</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210929211754329.png" alt="image-20210929211754329"></p><p>​假如有一个线程执行到synchronized代码块的时候，JVM使用CAS操作把线程指针ID记录到Mark Word当中，并修改标偏向标示，标示当前线程就获得该锁。锁对象变成偏向锁（通过CAS修改对象头里的锁标志位），字面意思是“偏向于第一个获得它的线程”的锁。执行完同步代码块后，线程并不会主动释放偏向锁。</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210929211803269.png" alt="image-20210929211803269"></p><p>​这时线程获得了锁，可以执行同步代码块。当该线程第二次到达同步代码块时会判断此时持有锁的线程是否还是自己（持有锁的线程ID也在对象头里），JVM通过account对象的Mark Word判断：当前线程ID还在，说明还持有着这个对象的锁，就可以继续进入临界区工作。由于之前没有释放锁，这里也就不需要重新加锁。 如果自始至终使用锁的线程只有一个，很明显偏向锁几乎没有额外开销，性能极高。</p><p>​<strong>结论</strong>：JVM不用和操作系统协商设置Mutex(争取内核)，它只需要记录下线程ID就标示自己获得了当前锁，不用操作系统接入。<br>上述就是偏向锁：在没有其他线程竞争的时候，一直偏向偏心当前线程，当前线程可以一直执行。</p><h5 id="3、偏向锁JVM命令"><a href="#3、偏向锁JVM命令" class="headerlink" title="3、偏向锁JVM命令"></a>3、偏向锁JVM命令</h5><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+PrintFlagsInitial |grep BiasedLock*</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210929211909262.png" alt="image-20210929211909262"></p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210929211918843.png" alt="image-20210929211918843"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">* 实际上偏向锁在JDK1.6之后是默认开启的，但是启动时间有延迟，</span><br><span class="line">* 所以需要添加参数-XX:BiasedLockingStartupDelay=0，让其在程序启动时立刻启动。</span><br><span class="line">*</span><br><span class="line">* 开启偏向锁：</span><br><span class="line">* -XX:+UseBiasedLocking -XX:BiasedLockingStartupDelay=0</span><br><span class="line">*</span><br><span class="line">* 关闭偏向锁：关闭之后程序默认会直接进入------------------------------------------&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;   轻量级锁状态。</span><br><span class="line">* -XX:-UseBiasedLocking</span><br></pre></td></tr></table></figure><h5 id="4、Code演示"><a href="#4、Code演示" class="headerlink" title="4、Code演示"></a>4、Code演示</h5> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyObject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (o)&#123;</span><br><span class="line">                System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210929212100730.png" alt="image-20210929212100730"></p><p>一切默认，演示无效果,因为参数系统默认开启</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210929212916026.png" alt="image-20210929212916026"></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseBiasedLocking                       <span class="comment"># 开启偏向锁(默认)           </span></span><br><span class="line">-XX:-UseBiasedLocking                       <span class="comment"># 关闭偏向锁</span></span><br><span class="line">-XX:BiasedLockingStartupDelay=0             <span class="comment"># 关闭延迟(演示偏向锁时需要开启)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#参数说明：</span></span><br><span class="line"><span class="comment">#偏向锁在JDK1.6以上默认开启，开启后程序启动几秒后才会被激活，可以使用JVM参数来关闭延迟 -XX:BiasedLockingStartupDelay=0</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#如果确定锁通常处于竞争状态则可通过JVM参数 -XX:-UseBiasedLocking 关闭偏向锁，那么默认会进入轻量级锁</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>关闭延时参数，启用该功能</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:BiasedLockingStartupDelay=0</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210929212953054.png" alt="image-20210929212953054"></p><h5 id="5、偏向锁的撤销"><a href="#5、偏向锁的撤销" class="headerlink" title="5、偏向锁的撤销"></a>5、偏向锁的撤销</h5><p>当有另外线程逐步来竞争锁的时候，就不能再使用偏向锁了，要升级为轻量级锁</p><p>竞争线程尝试CAS更新对象头失败，会等待到全局安全点（此时不会执行任何代码）撤销偏向锁。</p><blockquote><p>偏向锁使用一种等到竞争出现才释放锁的机制，只有当其他线程竞争锁时，持有偏向锁的原来线程才会被撤销。<br>撤销需要等待全局安全点(该时间点上没有字节码正在执行)，同时检查持有偏向锁的线程是否还在执行： </p><p>①  第一个线程正在执行synchronized方法(处于同步块)，它还没有执行完，其它线程来抢夺，该偏向锁会被取消掉并出现锁升级。<br>此时轻量级锁由原持有偏向锁的线程持有，继续执行其同步代码，而正在竞争的线程会进入自旋等待获得该轻量级锁。<br>②  第一个线程执行完成synchronized方法(退出同步块)，则将对象头设置成无锁状态并撤销偏向锁，重新偏向 。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210929213113133.png"></p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210929213128855.png" alt="image-20210929213128855"></p><h4 id="5、轻锁"><a href="#5、轻锁" class="headerlink" title="5、轻锁"></a>5、轻锁</h4><p>有线程来参与锁的竞争，但是获取锁的冲突时间极短</p><p>本质就是自旋锁</p><h5 id="1、轻量级锁的获取"><a href="#1、轻量级锁的获取" class="headerlink" title="1、轻量级锁的获取"></a>1、轻量级锁的获取</h5><p>轻量级锁是为了在线程近乎交替执行同步块时提高性能。<br>主要目的： 在没有多线程竞争的前提下，通过CAS减少重量级锁使用操作系统互斥量产生的性能消耗，说白了先自旋再阻塞。<br>升级时机： 当关闭偏向锁功能或多线程竞争偏向锁会导致偏向锁升级为轻量级锁</p><p>假如线程A已经拿到锁，这时线程B又来抢该对象的锁，由于该对象的锁已经被线程A拿到，当前该锁已是偏向锁了。<br>而线程B在争抢时发现对象头Mark Word中的线程ID不是线程B自己的线程ID(而是线程A)，那线程B就会进行CAS操作希望能获得锁。<br>此时线程B操作中有两种情况：<br>如果锁获取成功，直接替换Mark Word中的线程ID为B自己的ID(A → B)，重新偏向于其他线程(即将偏向锁交给其他线程，相当于当前线程”被”释放了锁)，该锁会保持偏向锁状态，A线程Over，B线程上位；</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210929213253052.png" alt="image-20210929213253052"></p><p>​如果锁获取失败，则偏向锁升级为轻量级锁，此时轻量级锁由原持有偏向锁的线程持有，继续执行其同步代码，而正在竞争的线程B会进入自旋等待获得该轻量级锁。</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210929213304246.png" alt="image-20210929213304246"></p><h5 id="2、Code演示"><a href="#2、Code演示" class="headerlink" title="2、Code演示"></a>2、Code演示</h5><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210929213324762.png" alt="image-20210929213324762"></p><p>如果关闭偏向锁，就可以直接进入轻量级锁</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:-UseBiasedLocking</span><br></pre></td></tr></table></figure><h5 id="3、自旋达到一定次数和程度"><a href="#3、自旋达到一定次数和程度" class="headerlink" title="3、自旋达到一定次数和程度"></a>3、自旋达到一定次数和程度</h5><p>java6之前</p><p>默认启用，默认情况下自旋的次数是 10 次  -XX:PreBlockSpin&#x3D;10来修改，或者自旋线程数超过cpu核数一半</p><p>Java6之后</p><p>自适应，自适应意味着自旋的次数不是固定不变的</p><p>而是根据：同一个锁上一次自旋的时间，拥有锁线程的状态来决定。</p><h5 id="4、轻量锁与偏向锁的区别和不同"><a href="#4、轻量锁与偏向锁的区别和不同" class="headerlink" title="4、轻量锁与偏向锁的区别和不同"></a>4、轻量锁与偏向锁的区别和不同</h5><p>争夺轻量级锁失败时，自旋尝试抢占锁</p><p>轻量级锁每次退出同步块都需要释放锁，而偏向锁是在竞争发生时才释放锁</p><h4 id="6、重锁"><a href="#6、重锁" class="headerlink" title="6、重锁"></a>6、重锁</h4><p>有大量的线程参与锁的竞争，冲突性很高</p><p><img src="/images/1.JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20210929213558173.png" alt="image-20210929213558173"></p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210929213604489.png" alt="image-20210929213604489"></p><h4 id="7、各种锁优缺点、synchronized锁升级和实现原理"><a href="#7、各种锁优缺点、synchronized锁升级和实现原理" class="headerlink" title="7、各种锁优缺点、synchronized锁升级和实现原理"></a>7、各种锁优缺点、synchronized锁升级和实现原理</h4><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210929213623068.png" alt="image-20210929213623068"></p><p>synchronized锁升级过程总结：一句话，就是先自旋，不行再阻塞。<br>实际上是把之前的悲观锁(重量级锁)变成在一定条件下使用偏向锁以及使用轻量级(自旋锁CAS)的形式</p><p>​synchronized在修饰方法和代码块在字节码上实现方式有很大差异，但是内部实现还是基于对象头的MarkWord来实现的。<br>JDK1.6之前synchronized使用的是重量级锁，JDK1.6之后进行了优化，拥有了无锁-&gt;偏向锁-&gt;轻量级锁-&gt;重量级锁的升级过程，而不是无论什么情况都使用重量级锁。</p><p>​偏向锁:适用于单线程适用的情况，在不存在锁竞争的时候进入同步方法&#x2F;代码块则使用偏向锁。<br>轻量级锁：适用于竞争较不激烈的情况(这和乐观锁的使用范围类似)， 存在竞争时升级为轻量级锁，轻量级锁采用的是自旋锁，如果同步方法&#x2F;代码块执行时间很短的话，采用轻量级锁虽然会占用cpu资源但是相对比使用重量级锁还是更高效。<br>​重量级锁：适用于竞争激烈的情况，如果同步方法&#x2F;代码块执行时间很长，那么使用轻量级锁自旋带来的性能消耗就比使用重量级锁更严重，这时候就需要升级为重量级锁。</p><h3 id="4、JIT编译器对锁的优化"><a href="#4、JIT编译器对锁的优化" class="headerlink" title="4、JIT编译器对锁的优化"></a>4、JIT编译器对锁的优化</h3><p>Just In Time Compiler，一般翻译为即时编译器</p><h4 id="1、锁消除"><a href="#1、锁消除" class="headerlink" title="1、锁消除"></a>1、锁消除</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 锁消除</span></span><br><span class="line"><span class="comment"> * 从JIT角度看相当于无视它，synchronized (o)不存在了,这个锁对象并没有被共用扩散到其它线程使用，</span></span><br><span class="line"><span class="comment"> * 极端的说就是根本没有加这个锁对象的底层机器码，消除了锁的使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockClearUPDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">objectLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();<span class="comment">//正常的</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//锁消除,JIT会无视它，synchronized(对象锁)不存在了。不正常的</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (o)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;-----hello LockClearUPDemo&quot;</span>+<span class="string">&quot;\t&quot;</span>+o.hashCode()+<span class="string">&quot;\t&quot;</span>+objectLock.hashCode());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">LockClearUPDemo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LockClearUPDemo</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                demo.m1();</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、锁粗化"><a href="#2、锁粗化" class="headerlink" title="2、锁粗化"></a>2、锁粗化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 锁粗化</span></span><br><span class="line"><span class="comment"> * 假如方法中首尾相接，前后相邻的都是同一个锁对象，那JIT编译器就会把这几个synchronized块合并成一个大块，</span></span><br><span class="line"><span class="comment"> * 加粗加大范围，一次申请锁使用即可，避免次次的申请和释放锁，提升了性能</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockBigDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">objectLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (objectLock) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;11111&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (objectLock) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;22222&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (objectLock) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;33333&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;a&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (objectLock) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;44444&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (objectLock) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;55555&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (objectLock) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;66666&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;b&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="十六、AbstractQueuedSynchronizer之AQS"><a href="#十六、AbstractQueuedSynchronizer之AQS" class="headerlink" title="十六、AbstractQueuedSynchronizer之AQS"></a>十六、AbstractQueuedSynchronizer之AQS</h2><h3 id="1、AQS是什么"><a href="#1、AQS是什么" class="headerlink" title="1、AQS是什么"></a>1、AQS是什么</h3><p>字面意思:抽象的队列同步器</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210929214004518.png" alt="image-20210929214004518"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AbstractOwnableSynchronizer</span><br><span class="line">AbstractQueuedLongSynchronizer</span><br><span class="line">AbstractQueuedSynchronizer                  </span><br><span class="line">通常地：AbstractQueuedSynchronizer简称为AQS</span><br></pre></td></tr></table></figure><p><strong>技术解释</strong></p><p>​是用来构建锁或者其它同步器组件的重量级基础框架及整个JUC体系的基石，通过内置的FIFO队列来完成资源获取线程的排队工作，并通过一个int类变量表示持有锁的状态</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210929214041662.png" alt="image-20210929214041662"></p><p>CLH：Craig、Landin and Hagersten 队列，是一个单向链表，AQS中的队列是CLH变体的虚拟双向队列FIFO</p><h3 id="2、AQS为什么是JUC内容中最重要的基石"><a href="#2、AQS为什么是JUC内容中最重要的基石" class="headerlink" title="2、AQS为什么是JUC内容中最重要的基石"></a>2、AQS为什么是JUC内容中最重要的基石</h3><h4 id="1、和AQS有关的"><a href="#1、和AQS有关的" class="headerlink" title="1、和AQS有关的"></a>1、和AQS有关的</h4><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210929214144170.png" alt="image-20210929214144170"></p><h4 id="2、ReentrantLock"><a href="#2、ReentrantLock" class="headerlink" title="2、ReentrantLock"></a>2、ReentrantLock</h4><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210929214213703.png" alt="image-20210929214213703"></p><h4 id="3、CountDownLatch"><a href="#3、CountDownLatch" class="headerlink" title="3、CountDownLatch"></a>3、CountDownLatch</h4><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210929214224423.png" alt="image-20210929214224423"></p><h4 id="4、ReentrantReadWriteLock"><a href="#4、ReentrantReadWriteLock" class="headerlink" title="4、ReentrantReadWriteLock"></a>4、ReentrantReadWriteLock</h4><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210929214237561.png" alt="image-20210929214237561"></p><h4 id="5、Semaphore"><a href="#5、Semaphore" class="headerlink" title="5、Semaphore"></a>5、Semaphore</h4><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210929214249848.png" alt="image-20210929214249848"></p><h4 id="6、进一步理解锁和同步器的关系"><a href="#6、进一步理解锁和同步器的关系" class="headerlink" title="6、进一步理解锁和同步器的关系"></a>6、进一步理解锁和同步器的关系</h4><p>锁，面向锁的使用者 </p><p>定义了程序员和锁交互的使用层API，隐藏了实现细节，你调用即可。</p><p>同步器，面向锁的实现者</p><p>比如Java并发大神DougLee，提出统一规范并简化了锁的实现，屏蔽了同步状态管理、阻塞线程排队和通知、唤醒机制等。</p><h3 id="3、AQS能干嘛"><a href="#3、AQS能干嘛" class="headerlink" title="3、AQS能干嘛"></a>3、AQS能干嘛</h3><p>加锁会导致阻塞，有阻塞就需要排队，实现排队必然需要队列</p><p>​抢到资源的线程直接使用处理业务，抢不到资源的必然涉及一种排队等候机制。抢占资源失败的线程继续去等待(类似银行业务办理窗口都满了，暂时没有受理窗口的顾客只能去候客区排队等候)，但等候线程仍然保留获取锁的可能且获取锁流程仍在继续(候客区的顾客也在等着叫号，轮到了再去受理窗口办理业务)。</p><p>既然说到了排队等候机制，那么就一定会有某种队列形成，这样的队列是什么数据结构呢？</p><p>​如果共享资源被占用，就需要一定的阻塞等待唤醒机制来保证锁分配。这个机制主要用的是CLH队列的变体实现的，将暂时获取不到锁的线程加入到队列中，这个队列就是AQS的抽象表现。它将请求共享资源的线程封装成队列的结点（Node），通过CAS、自旋以及LockSupport.park()的方式，维护state变量的状态，使并发达到同步的效果。</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210929214426330.png" alt="image-20210929214426330"></p><h3 id="4、AQS初步"><a href="#4、AQS初步" class="headerlink" title="4、AQS初步"></a>4、AQS初步</h3><h4 id="1、官网解释"><a href="#1、官网解释" class="headerlink" title="1、官网解释"></a>1、官网解释</h4><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210929214506123.png" alt="image-20210929214506123"></p><p>有阻塞就需要排队，实现排队必然需要队列</p><p>​AQS使用一个volatile的int类型的成员变量来表示同步状态，通过内置的FIFO队列来完成资源获取的排队工作将每条要去抢占资源的线程封装成一个Node节点来实现锁的分配，通过CAS完成对State值的修改。</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210929214546424.png" alt="image-20210929214546424"></p><h4 id="2、AQS内部体系架构"><a href="#2、AQS内部体系架构" class="headerlink" title="2、AQS内部体系架构"></a>2、AQS内部体系架构</h4><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210929214605895.png" alt="image-20210929214605895"></p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210929214622747.png" alt="image-20210929214622747"></p><h5 id="1、AQS自身"><a href="#1、AQS自身" class="headerlink" title="1、AQS自身"></a>1、AQS自身</h5><ol><li>AQS的int变量</li></ol><p>AQS的同步状态State成员变量</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210929214734697.png" alt="image-20210929214734697"></p><p>银行办理业务的受理窗口状态</p><p>零就是没人，自由状态可以办理</p><p>大于等于1，有人占用窗口，等着去</p><ol start="2"><li>AQS的CLH队列</li></ol><p>CLH队列(三个大牛的名字组成)，为一个双向队列</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210929214808112.png" alt="image-20210929214808112"></p><p><strong>小总结</strong></p><p>有阻塞就需要排队，实现排队必然需要队列</p><p>state变量+CLH双端队列</p><h5 id="2、内部类Node-Node类在AQS类内部"><a href="#2、内部类Node-Node类在AQS类内部" class="headerlink" title="2、内部类Node(Node类在AQS类内部)"></a>2、内部类Node(Node类在AQS类内部)</h5><ol><li>Node的int变量</li></ol><p>Node的等待状态waitState成员变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> waitStatus</span><br></pre></td></tr></table></figure><p>等候区其它顾客(其它线程)的等待状态</p><p>队列中每个排队的个体就是一个 Node</p><ol start="2"><li>Node此类的讲解</li></ol><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210929214940522.png" alt="image-20210929214940522"></p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210929214949657.png" alt="image-20210929214949657"></p><h5 id="3、AQS同步队列的基本结构"><a href="#3、AQS同步队列的基本结构" class="headerlink" title="3、AQS同步队列的基本结构"></a>3、AQS同步队列的基本结构</h5><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210929215024937.png" alt="image-20210929215024937"></p><p>CLH：Craig、Landin and Hagersten 队列，是个单向链表，AQS中的队列是CLH变体的虚拟双向队列（FIFO）</p><h3 id="5、从ReentrantLock开始解读AQS"><a href="#5、从ReentrantLock开始解读AQS" class="headerlink" title="5、从ReentrantLock开始解读AQS"></a>5、从ReentrantLock开始解读AQS</h3><p>Lock接口的实现类，基本都是通过【聚合】了一个【队列同步器】的子类完成线程访问控制的</p><h4 id="1、ReentrantLock的原理"><a href="#1、ReentrantLock的原理" class="headerlink" title="1、ReentrantLock的原理"></a>1、ReentrantLock的原理</h4><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210929215121096.png" alt="image-20210929215121096"></p><h4 id="2、从最简单的lock方法开始看看公平和非公平"><a href="#2、从最简单的lock方法开始看看公平和非公平" class="headerlink" title="2、从最简单的lock方法开始看看公平和非公平"></a>2、从最简单的lock方法开始看看公平和非公平</h4><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210929215157532.png" alt="image-20210929215157532"></p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210929215208921.png" alt="image-20210929215208921"></p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210929215217723.png" alt="image-20210929215217723"></p><blockquote><p>可以明显看出公平锁与非公平锁的lock()方法唯一的区别就在于公平锁在获取同步状态时多了一个限制条件：<br>hasQueuedPredecessors()<br>hasQueuedPredecessors是公平锁加锁时判断等待队列中是否存在有效节点的方法</p></blockquote><h4 id="3、非公平锁-方法lock"><a href="#3、非公平锁-方法lock" class="headerlink" title="3、非公平锁 方法lock()"></a>3、非公平锁 方法lock()</h4><p>对比公平锁和非公平锁的 tryAcquire()方法的实现代码，其实差别就在于非公平锁获取锁时比公平锁中少了一个判断 !hasQueuedPredecessors()</p><p>hasQueuedPredecessors() 中判断了是否需要排队，导致公平锁和非公平锁的差异如下：</p><p>公平锁：公平锁讲究先来先到，线程在获取锁时，如果这个锁的等待队列中已经有线程在等待，那么当前线程就会进入等待队列中；</p><p>非公平锁：不管是否有等待队列，如果可以获取锁，则立刻占有锁对象。也就是说队列的第一个排队线程在unpark()，之后还是需要竞争锁（存在线程竞争的情况下）</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210929215348250.png" alt="image-20210929215348250"></p><h4 id="4、源码解读"><a href="#4、源码解读" class="headerlink" title="4、源码解读"></a>4、源码解读</h4><h5 id="1、lock"><a href="#1、lock" class="headerlink" title="1、lock()"></a>1、lock()</h5><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210929215500057.png" alt="image-20210929215500057"></p><h5 id="2、acquire"><a href="#2、acquire" class="headerlink" title="2、acquire()"></a>2、acquire()</h5><p><img src="/images/1.JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20210929215527782.png" alt="image-20210929215527782"></p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210929215532317.png" alt="image-20210929215532317"></p><h5 id="3、tryAcquire-arg"><a href="#3、tryAcquire-arg" class="headerlink" title="3、tryAcquire(arg)"></a>3、tryAcquire(arg)</h5><p>非公平锁</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210929215617239.png" alt="image-20210929215617239"></p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210929215622470.png" alt="image-20210929215622470"></p><p>nonfairTryAcquire(acquires)</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210929215636783.png" alt="image-20210929215636783"></p><p>return false; 继续推进条件，走下一个方法</p><p>return true; 结束</p><h5 id="4、addWaiter-Node-EXCLUSIVE"><a href="#4、addWaiter-Node-EXCLUSIVE" class="headerlink" title="4、addWaiter(Node.EXCLUSIVE)"></a>4、addWaiter(Node.EXCLUSIVE)</h5><p>addWaiter(Node mode)</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210929215721311.png" alt="image-20210929215721311"></p><p>enq(node);</p><p><img src="/images/1.JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20210929215749207.png" alt="image-20210929215749207"></p><p>双向链表中，第一个节点为虚节点(也叫哨兵节点)，其实并不存储任何信息，只是占位。<br>真正的第一个有数据的节点，是从第二个节点开始的。</p><p>假如3号ThreadC线程进来</p><p>prev - compareAndSetTail - next</p><h5 id="5、acquireQueued-addWaiter-Node-EXCLUSIVE-arg"><a href="#5、acquireQueued-addWaiter-Node-EXCLUSIVE-arg" class="headerlink" title="5、acquireQueued(addWaiter(Node.EXCLUSIVE), arg)"></a>5、acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</h5><p>acquireQueued</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210929215842781.png" alt="image-20210929215842781"></p><p>假如再抢抢失败就会进入</p><p>shouldParkAfterFailedAcquire 和 parkAndCheckInterrupt 方法中</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210929215859160.png" alt="image-20210929215859160"></p><p>shouldParkAfterFailedAcquire </p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210929215907481.png" alt="image-20210929215907481"></p><p>​如果前驱节点的 waitStatus 是 SIGNAL状态，即 shouldParkAfterFailedAcquire 方法会返回 true 程序会继续向下执行 parkAndCheckInterrupt 方法，用于将当前线程挂起</p><p>parkAndCheckInterrupt </p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210929215923254.png" alt="image-20210929215923254"></p><h4 id="5、unlock"><a href="#5、unlock" class="headerlink" title="5、unlock"></a>5、unlock</h4><p>sync.release(1); </p><p>tryRelease(arg)</p><p>unparkSuccessor</p><h2 id="十七、ReentrantLock、ReentrantReadWriteLock、StampedLock"><a href="#十七、ReentrantLock、ReentrantReadWriteLock、StampedLock" class="headerlink" title="十七、ReentrantLock、ReentrantReadWriteLock、StampedLock"></a>十七、ReentrantLock、ReentrantReadWriteLock、StampedLock</h2><h3 id="1、ReentrantReadWriteLock"><a href="#1、ReentrantReadWriteLock" class="headerlink" title="1、ReentrantReadWriteLock"></a>1、ReentrantReadWriteLock</h3><p>读写锁定义为：一个资源能够被多个读线程访问，或者被一个写线程访问，但是不能同时存在读写线程。</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210929220234946.png" alt="image-20210929220234946"></p><h4 id="1、读写锁意义和特点"><a href="#1、读写锁意义和特点" class="headerlink" title="1、读写锁意义和特点"></a>1、读写锁意义和特点</h4><p>​读写锁ReentrantReadWriteLock并不是真正意义上的读写分离，它只允许读读共存，而读写和写写依然是互斥的，<br>大多实际场景是“读&#x2F;读”线程间并不存在互斥关系，只有”读&#x2F;写”线程或”写&#x2F;写”线程间的操作需要互斥的。因此引入ReentrantReadWriteLock。</p><p>​一个ReentrantReadWriteLock同时只能存在一个写锁但是可以存在多个读锁，但不能同时存在写锁和读锁(切菜还是拍蒜选一个)。也即一个资源可以被多个读操作访问或一个写操作访问，但两者不能同时进行。</p><p>只有在读多写少情境之下，读写锁才具有较高的性能体现。</p><h4 id="2、特点"><a href="#2、特点" class="headerlink" title="2、特点"></a>2、特点</h4><ul><li>可重入</li><li>读写分离</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantReadWriteLockDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">MyResource</span> <span class="variable">myResource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyResource</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">finalI</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                myResource.write(finalI +<span class="string">&quot;&quot;</span>, finalI +<span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">finalI</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                myResource.read(finalI +<span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//暂停几秒钟线程</span></span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">1</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读全部over才可以继续写</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">finalI</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                myResource.write(finalI +<span class="string">&quot;&quot;</span>, finalI +<span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;,<span class="string">&quot;newWriteThread===&quot;</span>+String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、从写锁→读锁，ReentrantReadWriteLock可以降级"><a href="#3、从写锁→读锁，ReentrantReadWriteLock可以降级" class="headerlink" title="3、从写锁→读锁，ReentrantReadWriteLock可以降级"></a>3、从写锁→读锁，ReentrantReadWriteLock可以降级</h4><p>《Java 并发编程的艺术》中关于锁降级的说明：</p><p>锁的严苛程度变强叫做升级，反之叫做降级</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210929220521703.png" alt="image-20210929220521703"></p><p>锁降级：将写入锁降级为读锁(类似Linux文件读写权限理解，就像写权限要高于读权限一样)</p><h5 id="1、读写锁降级演示"><a href="#1、读写锁降级演示" class="headerlink" title="1、读写锁降级演示"></a>1、读写锁降级演示</h5><p>可以降级</p><p>锁降级：遵循获取写锁→再获取读锁→再释放写锁的次序，写锁能够降级成为读锁。<br>如果一个线程占有了写锁，在不释放写锁的情况下，它还能占有读锁，即写锁降级为读锁。</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210929220618332.png" alt="image-20210929220618332"></p><p>Java8 官网说明</p><p><img src="/images/1.JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20210929220638216.png" alt="image-20210929220638216"></p><p>重入还允许通过获取写入锁定，然后读取锁然后释放写锁从写锁到读取锁, 但是，从读锁定升级到写锁是不可能的。</p><p><strong>锁降级是为了让当前线程感知到数据的变化，目的是保证数据可见性</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 锁降级：遵循获取写锁→再获取读锁→再释放写锁的次序，写锁能够降级成为读锁。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果一个线程占有了写锁，在不释放写锁的情况下，它还能占有读锁，即写锁降级为读锁。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockDownGradingDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">ReentrantReadWriteLock</span> <span class="variable">readWriteLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line"></span><br><span class="line">        ReentrantReadWriteLock.<span class="type">ReadLock</span> <span class="variable">readLock</span> <span class="operator">=</span> readWriteLock.readLock();</span><br><span class="line">        ReentrantReadWriteLock.<span class="type">WriteLock</span> <span class="variable">writeLock</span> <span class="operator">=</span> readWriteLock.writeLock();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        writeLock.lock();</span><br><span class="line">        System.out.println(<span class="string">&quot;-------正在写入&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        readLock.lock();</span><br><span class="line">        System.out.println(<span class="string">&quot;-------正在读取&quot;</span>);</span><br><span class="line"></span><br><span class="line">        writeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如果有线程在读，那么写线程是无法获取写锁的，是悲观锁的策略</strong></p><p>不可锁升级</p><p>线程获取读锁是不能直接升级为写入锁的。</p><p><img src="/images/1.JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20210929220808008.png" alt="image-20210929220808008"></p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210929220811350.png" alt="image-20210929220811350"></p><p>在ReentrantReadWriteLock中，当读锁被使用时，如果有线程尝试获取写锁，该写线程会被阻塞。所以，需要释放所有读锁，才可获取写锁，</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210929220821174.png" alt="image-20210929220821174"></p><h5 id="2、写锁和读锁是互斥的"><a href="#2、写锁和读锁是互斥的" class="headerlink" title="2、写锁和读锁是互斥的"></a>2、写锁和读锁是互斥的</h5><p>​写锁和读锁是互斥的（这里的互斥是指线程间的互斥，当前线程可以获取到写锁又获取到读锁，但是获取到了读锁不能继续获取写锁），这是因为读写锁要保持写操作的可见性。因为，如果允许读锁在被获取的情况下对写锁的获取，那么正在运行的其他读线程无法感知到当前写线程的操作</p><p>​因此，分析读写锁ReentrantReadWriteLock，会发现它有个潜在的问题：读锁全完，写锁有望；写锁独占，读写全堵；如果有线程正在读，写线程需要等待读线程释放锁后才能获取写锁，见前面Case《code演示LockDownGradingDemo》即ReadWriteLock读的过程中不允许写，只有等待线程都释放了读锁，当前线程才能获取写锁，也就是写入必须等待，这是一种悲观的读锁，o(╥﹏╥)o，人家还在读着那，你先别去写，省的数据乱。</p><p>​分析StampedLock(后面详细讲解)，会发现它改进之处在于：读的过程中也允许获取写锁介入(相当牛B，读和写两个操作也让你“共享”(注意引号))，这样会导致我们读的数据就可能不一致！所以，需要额外的方法来判断读的过程中是否有写入，这是一种乐观的读锁，O(∩_∩)O哈哈~。 显然乐观锁的并发效率更高，但一旦有小概率的写入导致读取的数据不一致，需要能检测出来，再读一遍就行。</p><h4 id="4、读写锁之读写规矩，再说降级"><a href="#4、读写锁之读写规矩，再说降级" class="headerlink" title="4、读写锁之读写规矩，再说降级"></a>4、读写锁之读写规矩，再说降级</h4><p>锁降级  下面的示例代码摘自ReentrantWriteReadLock源码中：<br>ReentrantWriteReadLock支持锁降级，遵循按照获取写锁，获取读锁再释放写锁的次序，写锁能够降级成为读锁，不支持锁升级。<br>解读在最下面:</p><p><img src="https://cdn.jsdelivr.net/gh/zhonghanlu/PicGo/img/image-20210929221016416.png" alt="image-20210929221016416"></p><ol><li><p>代码中声明了一个volatile类型的cacheValid变量，保证其可见性。</p></li><li><p>首先获取读锁，如果cache不可用，则释放读锁，获取写锁，在更改数据之前，再检查一次cacheValid的值，然后修改数据，将cacheValid置为true，然后在释放写锁前获取读锁；此时，cache中数据可用，处理cache中数据，最后释放读锁。这个过程就是一个完整的锁降级的过程，目的是保证数据可见性。</p></li></ol><ul><li><p>如果违背锁降级的步骤 </p><ul><li>如果当前的线程C在修改完cache中的数据后，没有获取读锁而是直接释放了写锁，那么假设此时另一个线程D获取了写锁并修改了数据，那么C线程无法感知到数据已被修改，则数据出现错误。</li></ul></li><li><p>如果遵循锁降级的步骤 </p><ul><li>线程C在释放写锁之前获取读锁，那么线程D在获取写锁时将被阻塞，直到线程C完成数据处理过程，释放读锁。这样可以保证返回的数据是这次更新的数据，该机制是专门为了缓存设计的。</li></ul></li></ul><h3 id="2、邮戳锁StampedLock"><a href="#2、邮戳锁StampedLock" class="headerlink" title="2、邮戳锁StampedLock"></a>2、邮戳锁StampedLock</h3><p>无锁→独占锁→读写锁→邮戳锁</p><h4 id="1、StampedLock是什么"><a href="#1、StampedLock是什么" class="headerlink" title="1、StampedLock是什么"></a>1、StampedLock是什么</h4><p>StampedLock是JDK1.8中新增的一个读写锁，也是对JDK1.5中的读写锁ReentrantReadWriteLock的优化。</p><p>邮戳锁 - 也叫票据锁</p><blockquote><p> stamp（戳记，long类型）</p><p>代表了锁的状态。当stamp返回零时，表示线程获取锁失败。并且，当释放锁或者转换锁的时候，都要传入最初获取的stamp值。</p></blockquote><h4 id="2、它是由锁饥饿问题引出"><a href="#2、它是由锁饥饿问题引出" class="headerlink" title="2、它是由锁饥饿问题引出"></a>2、它是由锁饥饿问题引出</h4><p>​ReentrantReadWriteLock实现了读写分离，但是一旦读操作比较多的时候，想要获取写锁就变得比较困难了，假如当前1000个线程，999个读，1个写，有可能999个读取线程长时间抢到了锁，那1个写线程就悲剧了 因为当前有可能会一直存在读锁，而无法获得写锁，根本没机会写，</p><h5 id="1、如何缓解锁饥饿问题？"><a href="#1、如何缓解锁饥饿问题？" class="headerlink" title="1、如何缓解锁饥饿问题？"></a>1、如何缓解锁饥饿问题？</h5><p>使用“公平”策略可以一定程度上缓解这个问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>但是“公平”策略是以牺牲系统吞吐量为代价的</p><p><strong>StampedLock类的乐观读锁闪亮登场</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ReentrantReadWriteLock</span><br><span class="line">允许多个线程同时读，但是只允许一个线程写，在线程获取到写锁的时候，其他写操作和读操作都会处于阻塞状态，</span><br><span class="line">读锁和写锁也是互斥的，所以在读的时候是不允许写的，读写锁比传统的synchronized速度要快很多，</span><br><span class="line">原因就是在于ReentrantReadWriteLock支持读并发</span><br><span class="line"></span><br><span class="line">StampedLock横空出世</span><br><span class="line">ReentrantReadWriteLock的读锁被占用的时候，其他线程尝试获取写锁的时候会被阻塞。</span><br><span class="line">但是，StampedLock采取乐观获取锁后，其他线程尝试获取写锁时不会被阻塞，这其实是对读锁的优化，</span><br><span class="line">所以，在获取乐观读锁后，还需要对结果进行校验。</span><br></pre></td></tr></table></figure><h4 id="3、StampedLock的特点"><a href="#3、StampedLock的特点" class="headerlink" title="3、StampedLock的特点"></a>3、StampedLock的特点</h4><ul><li>所有获取锁的方法，都返回一个邮戳（Stamp），Stamp为零表示获取失败，其余都表示成功；</li><li>所有释放锁的方法，都需要一个邮戳（Stamp），这个Stamp必须是和成功获取锁时得到的Stamp一致；</li><li>StampedLock是不可重入的，危险(如果一个线程已经持有了写锁，再去获取写锁的话就会造成死锁)</li></ul><h5 id="1、StampedLock有三种访问模式"><a href="#1、StampedLock有三种访问模式" class="headerlink" title="1、StampedLock有三种访问模式"></a>1、StampedLock有三种访问模式</h5><ol><li><p>Reading（读模式）：功能和ReentrantReadWriteLock的读锁类似</p></li><li><p>Writing（写模式）：功能和ReentrantReadWriteLock的写锁类似</p></li><li><p>Optimistic reading（乐观读模式）：无锁机制，类似于数据库中的乐观锁，支持读写并发，很乐观认为读取时没人修改，假如被修改再实现升级为悲观读模式</p></li></ol><h5 id="2、乐观读模式code演示"><a href="#2、乐观读模式code演示" class="headerlink" title="2、乐观读模式code演示"></a>2、乐观读模式code演示</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StampedLockDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">37</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">StampedLock</span> <span class="variable">stampedLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StampedLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> stampedLock.writeLock();</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;=====写线程准备修改&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            number = number + <span class="number">13</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            stampedLock.unlockWrite(stamp);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;=====写线程结束修改&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//悲观读</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> stampedLock.readLock();</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t come in readlock block,4 seconds continue...&quot;</span>);</span><br><span class="line">        <span class="comment">//暂停几秒钟线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;<span class="number">4</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">1</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t 正在读取中......&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> number;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot; 获得成员变量值result：&quot;</span> + result);</span><br><span class="line">            System.out.println(<span class="string">&quot;写线程没有修改值，因为 stampedLock.readLock()读的时候，不可以写，读写互斥&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            stampedLock.unlockRead(stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//乐观读</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tryOptimisticRead</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> stampedLock.tryOptimisticRead();</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> number;</span><br><span class="line">        <span class="comment">//间隔4秒钟，我们很乐观的认为没有其他线程修改过number值，实际靠判断。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;4秒前stampedLock.validate值(true无修改，false有修改)&quot;</span>+<span class="string">&quot;\t&quot;</span>+stampedLock.validate(stamp));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">4</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">1</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t 正在读取中......&quot;</span>+i+</span><br><span class="line">                    <span class="string">&quot;秒后stampedLock.validate值(true无修改，false有修改)&quot;</span>+<span class="string">&quot;\t&quot;</span></span><br><span class="line">                    +stampedLock.validate(stamp));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!stampedLock.validate(stamp)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;有人动过--------存在写操作！&quot;</span>);</span><br><span class="line">            stamp = stampedLock.readLock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;从乐观读 升级为 悲观读&quot;</span>);</span><br><span class="line">                result = number;</span><br><span class="line">                System.out.println(<span class="string">&quot;重新悲观读锁通过获取到的成员变量值result：&quot;</span> + result);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                stampedLock.unlockRead(stamp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t finally value: &quot;</span>+result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">StampedLockDemo</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StampedLockDemo</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            resource.read();</span><br><span class="line">            <span class="comment">//resource.tryOptimisticRead();</span></span><br><span class="line">        &#125;,<span class="string">&quot;readThread&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2秒钟时乐观读失败，6秒钟乐观读取成功resource.tryOptimisticRead();，修改切换演示</span></span><br><span class="line">        <span class="comment">//try &#123; TimeUnit.SECONDS.sleep(6); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            resource.write();</span><br><span class="line">        &#125;,<span class="string">&quot;writeThread&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>读的过程中也允许获取写锁介入</strong></p><h4 id="4、StampedLock的缺点"><a href="#4、StampedLock的缺点" class="headerlink" title="4、StampedLock的缺点"></a>4、StampedLock的缺点</h4><ul><li>StampedLock 不支持重入，没有Re开头</li><li>StampedLock 的悲观读锁和写锁都不支持条件变量（Condition），这个也需要注意。</li><li>使用 StampedLock一定不要调用中断操作，即不要调用interrupt() 方法<ul><li>如果需要支持中断功能，一定使用可中断的悲观读锁 readLockInterruptibly()和写锁writeLockInterruptibly()</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArchLinux install</title>
      <link href="/archives/27ab9b42.html"/>
      <url>/archives/27ab9b42.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="切换之前"><a href="#切换之前" class="headerlink" title="切换之前"></a>切换之前</h3><p>​为啥需要换做ArchLinux系统呢，作为一个开发就应该用属于开发的系统，好不好！！！ 其实也是因为自己买不起MAC。在众多的Linux系统中最终我选择了Arch。Ubuntu我装了一次很方便，从制镜像到安装完成，共花费一小时。但是这个Ubuntu一直出毛病，要不然是显卡不能用了，要不然是连不上网了，网卡都给我干丢了，反正就是一直出问题，然后就想着换一个系统。选了大蜥蜴和Arch，网上评论众多，想了想像我这种爱折腾的Java小开发，那不得整个Arch。果不其然整了一天，终于整出来了，下面细细听我道来   （部分转载别人安装教程）</p><h3 id="制作镜像"><a href="#制作镜像" class="headerlink" title="制作镜像"></a>制作镜像</h3><p>​制作镜像我选择的是U盘制作，U盘格式成FAT32形式的，如果U盘是FATex的也不是不可以。用这个玩意就可以轻松制作启动盘了</p><p><img src="https://cdn.zenless.top/gh/zhonghanlu/PicGo/img/image-20220919165841611.png" alt="image-20220919165841611"></p><p>镜像下载直接搜ArchLinux官网即可</p><p>选择中国的镜像源 下载iso文件即可</p><p>会清空磁盘的嗷谨慎操作嗷，盘符里的小电影注意点嗷</p><h3 id="U盘启动基础安装"><a href="#U盘启动基础安装" class="headerlink" title="U盘启动基础安装"></a>U盘启动基础安装</h3><p>​插上U盘进行重启，狂按12进行启动选择 ，我的拯救者狂按F12即可，选择U盘启动，U盘启动失败的就重新制启动盘，这个没办法。</p><p>​进行U盘启动，启动完成选择第一个UEFI形式安装  （可以提前看下自己的BIOS是什么模式，记住将安全启动关闭，进入BIOS将Ser那个玩意关闭再次进行U盘启动）</p><p><img src="https://cdn.zenless.top/gh/zhonghanlu/PicGo/img/image-20220919170331056.png" alt="image-20220919170331056"></p><p>等待黑屏刷日志</p><p>刷完即可进入安装程序</p><p>首先更新时间（*这一步也是检查你网络是否通常，记住WIFI如果连不上就别连了，我整了整整四五个小时WIFI没成功，最后找到我们运维大哥给我插根网线，唉。放心刷完系统之后进去是可以使用WIFI的）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timedatectl set-ntp true</span><br></pre></td></tr></table></figure><p>列出磁盘：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk -l</span><br></pre></td></tr></table></figure><p>&#x2F;dev&#x2F;sda1 : EFI 系统分区，大小为 1024 MB，FAT32 格式。这为存储引导加载程序和引导所需的其他文件提供了空间。</p><p>&#x2F;dev&#x2F;sda2 ： 交换分区，4GB 大小。交换空间用于将虚拟内存扩展到已安装的物理内存 (RAM) 之外，或用于挂起磁盘支持。</p><p>&#x2F;dev&#x2F;sda3 ： Linux分区，剩余可用磁盘空间大小，EXT4格式。这是存储我们的 Arch Linux 操作系统、文件和其他信息的根 ( &#x2F; ) 分区。</p><p>创建 EFI 系统分区</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cfdisk /dev/sda </span><br></pre></td></tr></table></figure><p>选择 GPT 标签类型并点击 Enter 。</p><p>然后 从底部菜单中选择 Free Space 并点击 New 。您可以使用 Tab 或 箭头键浏览菜单选项。</p><p>(如果你不想要之前的数据，直接delete完，硬干)</p><p>以 MB ( 1024M ) 为单位键入分区大小，然后按 Enter 键。</p><p>在 &#x2F;dev&#x2F;sda1 分区仍然被选中的情况下，从底部菜单中选择 Type 并选择 EFI System 分区类型。 </p><p>现在，您已完成 EFI 系统分区的配置。</p><p>创建交换分区</p><p>现在让我们使用相同的过程创建 Swap 分区。再次选择剩余的 Free space 和 并点击 New 。</p><p>以 GB ( 4G ) 为单位键入分区大小，然后按 Enter 键。</p><p>在 &#x2F;dev&#x2F;sda2 分区仍然被选中的情况下，从底部菜单中选择 Type 并选择 Linux swap 分区类型。</p><p>现在，您已经完成了 Swap 分区的配置。</p><p>创建根分区</p><p>最后，您需要创建根 ( &#x2F; ) 分区。再次选择剩余的 Free space 并点击 New 。</p><p>对于 ( &#x2F; ) 大小，保留默认大小值。这意味着，所有剩余的可用空间。按 Enter 键。</p><p>在 &#x2F;dev&#x2F;sda3 分区仍然被选中的情况下，从底部菜单中选择 Type 并选择 Linux filesystem 分区类型。</p><p>现在，您已经完成了根分区的配置。</p><p>将更改写入磁盘</p><p>接下来，您需要保存所做的更改。选择 Write 从底部菜单和命中 Enter 。</p><p>键入 yes 并按下 Enter 键。</p><p>我们到此结束。选择 Quit 并按下 Enter 即可。</p><p> 创建文件系统</p><p>现在您已准备好磁盘分区，是时候在其上创建文件系统了。但是让我们首先通过运行来查看分区表摘要：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk -l</span><br></pre></td></tr></table></figure><p>该 &#x2F;dev&#x2F;sda 磁盘应该有三个分区（ &#x2F;dev&#x2F;sda1 ， dev&#x2F;sda2 ，和 &#x2F;dev&#x2F;sda3 ）</p><p><strong>EFI分区格式化</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkfs.fat -F32 /dev/sda1</span><br><span class="line">mkfs.ext4 /dev/sda3</span><br></pre></td></tr></table></figure><p><strong>创建swap分区</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkswap /dev/sda2</span><br><span class="line">swapon /dev/sda2</span><br></pre></td></tr></table></figure><p><strong>挂载分区：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mount /dev/sda3 /mnt</span><br><span class="line">mkdir -p /mnt/boot/efi</span><br><span class="line">mount /dev/sda1 /mnt/boot/efi</span><br></pre></td></tr></table></figure><p><strong>查看磁盘分区情况</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsblk -f</span><br></pre></td></tr></table></figure><p><strong>更新为国内镜像源</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reflector --country China --age 72 --sort rate --protocol https --save /etc/pacman.d/mirrorlist</span><br></pre></td></tr></table></figure><p>将最新的镜像源更新为国内的，保存在&#x2F;etc&#x2F;pacman.d&#x2F;mirrorlist目录下</p><p>也可以手动替换到“&#x2F;etc&#x2F;pacman.d&#x2F;mirrorlistg”中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Server = https://mirrors.bfsu.edu.cn/archlinux/$repo/os/$arch</span><br><span class="line">Server = https://mirrors.cqu.edu.cn/archlinux/$repo/os/$arch</span><br><span class="line">Server = https://mirrors.dgut.edu.cn/archlinux/$repo/os/$arch</span><br><span class="line">Server = https://mirrors.neusoft.edu.cn/archlinux/$repo/os/$arch</span><br><span class="line">Server = https://mirrors.nju.edu.cn/archlinux/$repo/os/$arch</span><br><span class="line">Server = https://mirror.redrock.team/archlinux/$repo/os/$arch</span><br><span class="line">Server = https://mirrors.sjtug.sjtu.edu.cn/archlinux/$repo/os/$arch</span><br><span class="line">Server = https://mirrors.tuna.tsinghua.edu.cn/archlinux/$repo/os/$arch</span><br><span class="line">Server = https://mirrors.ustc.edu.cn/archlinux/$repo/os/$arch</span><br><span class="line">Server = https://mirrors.xjtu.edu.cn/archlinux/$repo/os/$arch</span><br></pre></td></tr></table></figure><p>如果到这一步 大哥畅通无阻  那只能说牛批  ， 开始安装ARCH</p><h3 id="ArchLinux-安装"><a href="#ArchLinux-安装" class="headerlink" title="ArchLinux 安装"></a>ArchLinux 安装</h3><p>安装基本系统（包括linux内核以及基础软件包），这里相比参考文章多给了几个软件包，因为这些对用户来说还是比较重要的 ，有几种内核可以安装：</p><p>普通内核(linux linux-headers)<br>lts稳定版内核(linux-lts linux-lts-headers)<br>zen内核(linux-zen,linux-zen-headers)<br>按自己的需求安装就可以</p><p>这里需要提前说一下，linux-zen 内核不支持 nvidia 显卡，有这个需求的就别装了，如果是原版 linux 内核的话，就要做好随时滚挂的准备，最近的 5.18 内核更新就会导致 nvidia-5.15 版本驱动失效无法开机，如果你希望稳定使用，就选择 linux-lts 内核和linux-lts-headers，并安装相应的 nvidia-lts 驱动（后面会有详细说明），不过不用太担心，即便是系统安装完成，你也可以随时切换自己想要的内核版本。</p><p>建议安装LTS内核</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pacstrap /mnt base linux-lts linux-lts-headers linux-firmware base-devel （LTS内核）</span><br><span class="line">或者</span><br><span class="line">pacstrap /mnt base linux linux-headers linux-firmware base-devel （普通内核）</span><br></pre></td></tr></table></figure><p>如安装报错 ERROR: Failed to install packages to new root </p><p>尝试以下命令再继续安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -Sy archlinux-keyring</span><br></pre></td></tr></table></figure><p>写入分区表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">genfstab -U /mnt &gt;&gt; /mnt/etc/fstab</span><br></pre></td></tr></table></figure><p> 使用如下命令进入新系统，进入后会显示[root@archiso &#x2F;]#</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arch-chroot /mnt</span><br></pre></td></tr></table></figure><p>配置系统<br>我解释一下这都是干嘛的。</p><p>vim：文本编辑器，可替代有neovim，nano,其中nano对新手比较友好，推荐经验较少或者刚入坑的同志使用。<br>iwd,networkmanager：用iwd作为nm的backend进行使用。（但是我这样使用在i3下会出现不少问题，比如网络经常自动断，且短时间无法重连等(KDE也会出现，但感觉没有i3频繁，我觉得可能是命令行的原因，安装完成之后卸载掉networkmanager问题解决。另外，如果需要使用网线和usb网络共享，networkmanager必须安装，最好加装一个dhcpcd）<br>ttf-dejavu：开源字体<br>sudo：用于非root用户暂时获取root权限<br>bluez：蓝牙模块<br>usbmuxd：参考文章没给这个。现在系统中使用的网络来自于live系统，不装这个的话，重启是无法通过usb连接手机共享网络的，根据个人情况选择，建议安装。<br>wqy-zenhei：中文字体，避免进入系统后无法显示中<br>dhcpcd：连网线用<br>pacman -S neovim iwd ttf-dejavu sudo bluez usbmuxd networkmanager dhcpcd wqy-zenhei<br>neovim和vim的启动命令是不一样的，neovim为“nvim”，vim是“vim”我一般会通过软链接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ln -s /bin/nvim /bin/vim</span><br><span class="line">ln -s /bin/nvim /bin/vi</span><br></pre></td></tr></table></figure><p> 将他们链接起来看，这样的话，通过“vim”“vi”命令也可以启动neovim了。</p><p>设置时区和时间</p><p>依次输入下面的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br><span class="line"></span><br><span class="line">hwclock --systohc</span><br></pre></td></tr></table></figure><p> 设置语言</p><p>输入“vim &#x2F;etc&#x2F;locale.gen”，删除前面的“#”，保存。</p><p><img src="https://cdn.zenless.top/gh/zhonghanlu/PicGo/img/image-20220919171722856.png" alt="image-20220919171722856"></p><p>输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">locale-gen</span><br><span class="line"></span><br><span class="line">echo LANG=zh_CN.UTF-8 &gt;&gt; /etc/locale.conf</span><br></pre></td></tr></table></figure><p>设置root用户的密码</p><p>输入“passwd”，再输入密码，密码不会显示。</p><p>设置主机名</p><p>主机名的开头和结尾字符不允许是连字符。 主机名强烈建议不要用数字开头,尽管这一条不是强制的。 用小写字母而不用大写字母。</p><p>echo 主机名 &gt;&gt; &#x2F;etc&#x2F;hostname<br>设置网络</p><p>编辑 “vim &#x2F;etc&#x2F;hosts”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1 localhost</span><br><span class="line">::1 localhost</span><br><span class="line">127.0.1.1 主机名.localdomain 主机名</span><br></pre></td></tr></table></figure><p>安装引导并重启系统<br>pacman -S grub efibootmgr   (安装grub)<br>grub-install &#x2F;dev&#x2F;sda    (注意：选择的是整个硬盘)<br>创建grub配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grub-mkconfig -o /boot/grub/grub.cfg</span><br></pre></td></tr></table></figure><p> 重启系统</p><p>exit    (退出新系统，回到live系统)<br>umount -R &#x2F;mnt    (递归卸载 &#x2F;mnt 中的磁盘)<br>reboot    (重启)<br>重启后登录root，密码是刚才设置的</p><p>打开联网服务和蓝牙</p><ol><li>首先激活服务</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">systemctl start iwd.service</span><br><span class="line">systemctl enable iwd.service</span><br><span class="line">systemctl start systemd-resolved.service</span><br><span class="line">systemctl enable systemd-resolved.service</span><br><span class="line">systemctl enable bluetooth.service</span><br><span class="line">systemctl enable NetworkManager</span><br><span class="line">systemctl enable dhcpcd</span><br></pre></td></tr></table></figure><ol start="2"><li>配置网络连接和DNS</li></ol><p>输入“vim &#x2F;etc&#x2F;iwd&#x2F;main.conf”，把下面的文字打进去，保存。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[General]</span><br><span class="line">EnableNetworkConfiguration=true</span><br><span class="line">NameResolvingService=systemd</span><br></pre></td></tr></table></figure><ol start="3"><li>安装了netwokmanager的配置</li></ol><p>如果安装了networkmanager，则需要将backend服务修改为iwd，总体上iwd比wpa好用很多。</p><p>输入“vim &#x2F;etc&#x2F;NetworkManager&#x2F;NetworkManager.conf”，把下面的文字打进去，保存。（vim的光标移动、删除和保存退出等命令请另行百度。）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[device]</span><br><span class="line">wifi.backend=iwd</span><br></pre></td></tr></table></figure><p>如果只安装networkmanager而不安装iwd的话，是不需要这一步的，nm会使用默认的wpa。（猜测）</p><p>安装一些硬件设备<br>    1.CPU编码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pacman -S intel-ucode    (intel的cpu装这个)</span><br><span class="line">pacman -S amd-ucode    (amd的cpu装这个)</span><br></pre></td></tr></table></figure><p>注意是 CPU 编码，不是显卡</p><ol start="2"><li>显卡驱动</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pacman -S xf86-video-intel（Intel核心显卡驱动，用Intel核显就装，否则不用装）</span><br><span class="line">pacman -S mesa nvidia(-lts) nvidia-settings nvidia-dkms nvidia-utils nvidia-prime（nvidia显卡驱动，用nvidia显卡就装，否则不用装）</span><br><span class="line">pacman -S xf86-video-amdgpu (AMD显卡驱动，用amd显卡的就装)</span><br><span class="line">这里举两个例子，我的笔记本，i7-11代，搭配intel核显以及3050显卡，所以安装前两个。我的台式机，e3-1230垃圾CPU，搭配HD6950显卡，所以装第三个。nvidia-dkms 与 nvidia-lts 不兼容，如果装lts驱动的话无需安装dkms 。</span><br><span class="line"></span><br><span class="line">注意：nvidia驱动的安装与前面选择的内核有关，如果你安装的是linux-lts内核，那么需要将nvidia更换为nvidia-lts，linux-zen不支持nvidia显卡（务必对号入座）</span><br></pre></td></tr></table></figure><p>新建一个用户</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd -m -G wheel -s /bin/bash 用户名    (添加进入wheel用户组，并将bash作为启动命令)</span><br></pre></td></tr></table></figure><p>passwd 用户名<br>然后输入</p><p>visudo<br>如果报错的话(应该不会)，就改为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/sudoers</span><br></pre></td></tr></table></figure><p> 找到如下内容，取消掉“# %wheel ALL&#x3D;(ALL:ALL) ALL”前面的“# ”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">## User privilege specification</span><br><span class="line">##</span><br><span class="line">root ALL=(ALL:ALL) ALL</span><br><span class="line"> </span><br><span class="line">## Uncomment to allow members of group wheel to execute any command</span><br><span class="line"># %wheel ALL=(ALL:ALL) ALL</span><br><span class="line"> </span><br><span class="line">## Same thing without a password</span><br><span class="line"># %wheel ALL=(ALL:ALL) NOPASSWD: ALL</span><br></pre></td></tr></table></figure><p>这里说一下，取消“# %wheel ALL&#x3D;(ALL:ALL) NOPASSWD: ALL”前的“# ”也是可以的，区别就在于，取消这一行后，wheel组的用户使用 sudo 就不用输密码了，如果你是新手，不建议这么做，如果你是老鸟，可以考虑取消NOPASSWD 所在的这一行。（我取消的是NOPASWD这行，图方便）</p><p>重启系统</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure><p>此时的系统已经基本可以使用了，但是还没有配置图形界面，如果你不需要图形界面，就只需登陆用户名就可以使用了。</p><h3 id="ArchLiux-桌面安装"><a href="#ArchLiux-桌面安装" class="headerlink" title="ArchLiux 桌面安装"></a>ArchLiux 桌面安装</h3><p>！！！注意：从这里开始，如果登陆的是普通用户，则所有的pacman和systemctl都需要 sudo ， 如果嫌麻烦，可以先在 ~&#x2F;.bashrc 中添加 “alias pacman&#x3D;’sudo pacman’和alias systemctl&#x3D;’sudo systemctl’”，我这里就不多写sudo了。如果提示需要权限，同样加sudo即可。所以这部分安装建议登陆root用户。</p><p>首先需要选择X11或者是Wayland，现在来看Wayland是比较先进的，但为了方便和兼容性还是用X11吧。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S xorg</span><br></pre></td></tr></table></figure><p>这个是必须安装的，后面的DE和WM都是基于x服务。</p><p><strong>安装KDE桌面</strong></p><p>特点：美观，比较稳定，自定义功能强大，配置方便（最推荐）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S plasma sddm konsole dolphin kate ark okular spectacle yay</span><br></pre></td></tr></table></figure><p>重启</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable sddm</span><br></pre></td></tr></table></figure><p><strong>安装Gnome桌面</strong></p><p>特点：自定义功能丰富（但是被阻隔了），</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pacman -S gnome</span><br><span class="line">systemctl <span class="built_in">enable</span> gdm</span><br></pre></td></tr></table></figure><p>我安装的是Gnome桌面，不要问我为什么不装第一个，第一个装不上去，焯！！！！</p><p><strong>中文输入法</strong></p><p>推荐使用 fcitx5</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S fcitx5 fcitx5-chinese-addons fcitx5-gtk fcitx5-qt fcitx5-configtool</span><br></pre></td></tr></table></figure><p>然后添加环境变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/environment</span><br><span class="line"></span><br><span class="line">GTK_IM_MODULE=fcitx</span><br><span class="line">QT_IM_MODULE=fcitx</span><br><span class="line">XMODIFIERS=@im=fcitx</span><br><span class="line">INPUT_METHOD=fcitx</span><br><span class="line">SDL_IM_MODULE=fcitx</span><br><span class="line">GLFW_IM_MODULE=ibus</span><br></pre></td></tr></table></figure><p>‘然后设置开机启动即可（桌面环境不同，方法也不同），这里提供一个简单的思路。</p><p>tty 下面是不需要中文输入法的（也用不了），所以修改 ~&#x2F;.xinitrc ，添加代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fcitx5 -d &amp;    (后台运行fcitx5，且开机自启)</span><br></pre></td></tr></table></figure><p>wiki描述</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">注意：</span><br><span class="line">如果您使用的桌面环境是兼容 XDG 的（例如 KDE、GNOME、Xfce、LXDE等），则 无需 此步骤（添加自启）。</span><br><span class="line">如果使用i3、awesome等窗口管理器，需要在其脚本中添加 Fcitx5 以实现自启动。例如，如果您使用 i3 或 sway ,可以在配置文件中添加exec --no-startup-id fcitx5 -d</span><br><span class="line">如果使用dwm，则需要添加 autostart 补丁。在 ~/.dwm/autostart.sh 中添加fcitx5 -d</span><br></pre></td></tr></table></figure><h3 id="系统切换完成"><a href="#系统切换完成" class="headerlink" title="系统切换完成"></a>系统切换完成</h3><p>开始安装环境吧</p><p><img src="https://cdn.zenless.top/gh/zhonghanlu/PicGo/img/image-20220919172627761.png" alt="image-20220919172627761"></p><p>写在最后：</p><p>​组成了众多文章：</p><ol><li>CSDN</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://blog.csdn.net/love906897406/article/details/126109464?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166357655316800180660005%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=166357655316800180660005&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-126109464-null-null.142^v47^body_digest,201^v3^control&amp;utm_term=archlinux%E5%AE%89%E8%A3%85&amp;spm=1018.2226.3001.4187</span><br></pre></td></tr></table></figure><p>2.知乎</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://zhuanlan.zhihu.com/p/433920079</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ArchLinux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ArchLinux </tag>
            
            <tag> System </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin Base</title>
      <link href="/archives/38da91cc.html"/>
      <url>/archives/38da91cc.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> hello                      <span class="comment">//  可选的包头</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;    <span class="comment">// 包级可见的函数，接受一个字符串数组作为参数</span></span><br><span class="line">   println(<span class="string">&quot;Hello World!&quot;</span>)         <span class="comment">// 分号可以省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Greeter</span>(<span class="keyword">val</span> name: String) &#123;</span><br><span class="line">   <span class="function"><span class="keyword">fun</span> <span class="title">greet</span><span class="params">()</span></span> &#123; </span><br><span class="line">      println(<span class="string">&quot;Hello, <span class="variable">$name</span>&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">   Greeter(<span class="string">&quot;World!&quot;</span>).greet()          <span class="comment">// 创建一个对象不用 new 关键字</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="为什么选择-Kotlin？"><a href="#为什么选择-Kotlin？" class="headerlink" title="为什么选择 Kotlin？"></a>为什么选择 Kotlin？</h3><p>简洁: 大大减少样板代码的数量。<br>安全: 避免空指针异常等整个类的错误。<br>互操作性: 充分利用 JVM、Android 和浏览器的现有库。<br>工具友好: 可用任何 Java IDE 或者使用命令行构建。</p><h3 id="Kotlin-使用命令行编译"><a href="#Kotlin-使用命令行编译" class="headerlink" title="Kotlin 使用命令行编译"></a>Kotlin 使用命令行编译</h3><p>Kotlin 命令行编译工具下载地址：<a href="https://github.com/JetBrains/kotlin/releases/tag/v1.1.2-2%EF%BC%8C%E7%9B%AE%E5%89%8D%E6%9C%80%E6%96%B0%E4%B8%BA">https://github.com/JetBrains/kotlin/releases/tag/v1.1.2-2，目前最新为</a> 1.1.2-2。</p><p>你可以选择一个最新的稳定版下载。</p><p>下载完成后，解压到指定目录，然后将 bin 目录添加到系统环境变量。bin 目录包含编译和运行 Kotlin 所需的脚本。</p><h3 id="SDKMAN"><a href="#SDKMAN" class="headerlink" title="SDKMAN!"></a>SDKMAN!</h3><p>在 OS X、Linux、Cygwin、FreeBSD 和 Solaris 系统上也可以使用更简单的安装方法，命令如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl -s https:<span class="comment">//get.sdkman.io | bash</span></span><br><span class="line">$ sdk install kotlin</span><br></pre></td></tr></table></figure><h3 id="Homebrew"><a href="#Homebrew" class="headerlink" title="Homebrew"></a>Homebrew</h3><p>在 OS X 下，你可以使用 Homebrew 安装：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ brew update</span><br><span class="line">$ brew install kotlin</span><br></pre></td></tr></table></figure><h3 id="MacPorts"><a href="#MacPorts" class="headerlink" title="MacPorts"></a>MacPorts</h3><p>如果你是 MacPorts 用户，可以使用以下命令安装：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo port install kotlin</span><br></pre></td></tr></table></figure><h2 id="创建和运行第一个程序"><a href="#创建和运行第一个程序" class="headerlink" title="创建和运行第一个程序"></a>创建和运行第一个程序</h2><p>创建一个名为 hello.kt 文件，代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hello.kt</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;Hello, World!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 Kotlin 编译器编译应用:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kotlinc hello.kt -include-runtime -d hello.jar</span><br></pre></td></tr></table></figure><p>-d: 用来设置编译输出的名称，可以是 class 或 .jar 文件，也可以是目录。<br>-include-runtime : 让 .jar 文件包含 Kotlin 运行库，从而可以直接运行。<br>如果你想看所有的可用选项，运行:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kotlinc -help</span><br></pre></td></tr></table></figure><p>运行应用</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ java -jar hello.jar</span><br><span class="line">Hello, World!</span><br></pre></td></tr></table></figure><h3 id="编译成库"><a href="#编译成库" class="headerlink" title="编译成库"></a>编译成库</h3><p>若需要将生成的 jar 包供其他 Kotlin 程序使用，可无需包含 Kotlin 的运行库：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kotlinc hello.kt -d hello.jar</span><br></pre></td></tr></table></figure><p>由于这样生成的 .jar 文件不包含 Kotlin 运行库，所以你应该确保当它被使用时，运行时在你的 classpath 上。</p><p>你也可以使用 kotlin 命令来运行 Kotlin 编译器生成的 .jar 文件</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kotlin -classpath hello.jar HelloKt</span><br></pre></td></tr></table></figure><p>HelloKt 为编译器为 hello.kt 文件生成的默认类名。</p><p>运行 REPL（交互式解释器）<br>我们可以运行如下命令得到一个可交互的 shell，然后输入任何有效的 Kotlin 代码，并立即看到结果</p><p><img src="https://cdn.zenless.top/gh/zhonghanlu/PicGo/img/image-20220825114103310.png" alt="image-20220825114103310"></p><p>使用命令行执行脚本<br>Kotlin 也可以作为一个脚本语言使用，文件后缀名为 .kts 。</p><p>例如我们创建一个名为 list_folders.kts，代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File</span><br><span class="line"><span class="keyword">val</span> folders = File(args[<span class="number">0</span>]).listFiles &#123; file -&gt; file.isDirectory() &#125;</span><br><span class="line">folders?.forEach &#123; folder -&gt; println(folder) &#125;</span><br></pre></td></tr></table></figure><p>执行时通过 -script 选项设置相应的脚本文件。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kotlinc -script list_folders.kts &lt;path_to_folder&gt;$ kotlinc -script list_folders.kts</span><br></pre></td></tr></table></figure><h2 id="Kotlin-Android-环境搭建"><a href="#Kotlin-Android-环境搭建" class="headerlink" title="Kotlin Android 环境搭建"></a>Kotlin Android 环境搭建</h2><h3 id="安装-Kotlin-插件"><a href="#安装-Kotlin-插件" class="headerlink" title="安装 Kotlin 插件"></a>安装 Kotlin 插件</h3><p>Android Studio 从 3.0（preview）版本开始将内置安装 Kotlin 插件。</p><p>打开 Settings ( Mac 为 Preferences) 面板，在右侧找到 Plugins 选项 (快捷键 Ctrl+, Mac 下为 command+)，搜索框输入 “Kotlin” 查找，点击 Search in repositories(仓库中搜索)，然后安装即可，安装完成之后需要重启 Android Studio。</p><p><img src="https://cdn.zenless.top/gh/zhonghanlu/PicGo/img/image-20220825114206140.png" alt="image-20220825114206140"></p><p><img src="https://cdn.zenless.top/gh/zhonghanlu/PicGo/img/image-20220825114218887.png" alt="image-20220825114218887"></p><h3 id="创建新工程"><a href="#创建新工程" class="headerlink" title="创建新工程"></a>创建新工程</h3><p>选择 Start a new Android Studio project 或者 File | New project，大多数选项均有默认值 ，只需要按几次”回车”键即可。</p><p><img src="https://www.runoob.com/wp-content/uploads/2017/05/1495853720-4994-0-create-new-project.png" alt="img"></p><p>Android Studio 3.0 在当前对话框中提供启用 Kotlin 支持的选项，勾选后可以跳过 “配置 Kotlin 工程（Configuring Kotlin in the project）”的步骤。</p><p>选择 Android 版本:</p><p><img src="https://cdn.zenless.top/gh/zhonghanlu/PicGo/img/image-20220825114303851.png" alt="image-20220825114303851"></p><p>选择需要创建的 Activity 样式:</p><p><img src="https://www.runoob.com/wp-content/uploads/2017/05/1495853838-1520-0-create-new-project.png" alt="img"></p><p>命名该 Activity:</p><p><img src="https://www.runoob.com/wp-content/uploads/2017/05/1495853838-8955-1-create-new-project.png" alt="img"></p><p>在 Android Studio 3.0 中，可以选择使用 Kotlin 创建 activity，因此也不需要”将Java 代码转换为 Kotlin（Converting Java code to Kotlin）”这一步骤。</p><p>早期版本中则会先使用 Java 创建 activity，然后再使用自动转换工具 进行转换。</p><h3 id="将-Java-代码转换为-Kotlin"><a href="#将-Java-代码转换为-Kotlin" class="headerlink" title="将 Java 代码转换为 Kotlin"></a>将 Java 代码转换为 Kotlin</h3><p>重新打开Android Studio，新建一个Android项目吧，添加一个默认的MainActivity</p><p>打开 MainActivity.java 文件，通过菜单栏依次调出 Code | Convert Java File to Kotlin File：</p><p><img src="https://www.runoob.com/wp-content/uploads/2017/05/1495854751-7389-convert-java-to-kotlin.png" alt="img"></p><p>转换完成后即可看到使用 Kotlin 编写的 activity。</p><p><img src="https://www.runoob.com/wp-content/uploads/2017/05/1495854753-3864-converted-code.png" alt="img"></p><h3 id="工程中配置-Kotlin"><a href="#工程中配置-Kotlin" class="headerlink" title="工程中配置 Kotlin"></a>工程中配置 Kotlin</h3><p>在开始编辑此文件时，Android Studio 会提示当前工程还未配置 Kotlin，根据提示完成操作即可，或者可以在菜单栏中选择 Tools</p><p><img src="https://www.runoob.com/wp-content/uploads/2017/05/1495854757-6620-kotlin-not-configured.png" alt="img"></p><p>选择配置时有如下对话框，选择已安装的最新版本即可。</p><p><img src="https://www.runoob.com/wp-content/uploads/2017/05/1495854752-7001-re-kotlin-in-project-details.png" alt="img"></p><p>Kotlin 配置完成后，应用程序的 build.gradle 文件会更新。 你能看到新增了 apply plugin: ‘kotlin-android’ 及其依赖。</p><p><img src="https://www.runoob.com/wp-content/uploads/2017/05/1495854750-1825-sync-project-with-gradle.png" alt="img"></p><p>同步工程，在提示框中点击”立即同步（Sync Now）”或者使用 Sync Project with Gradle Files命令。</p><p><img src="https://www.runoob.com/wp-content/uploads/2017/05/1495854764-6190-sync-project-with-gradle-2.png" alt="img"></p><h2 id="Kotlin-基础语法"><a href="#Kotlin-基础语法" class="headerlink" title="Kotlin 基础语法"></a>Kotlin 基础语法</h2><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>暂且结束   转载菜鸟教程+自我理解</p>]]></content>
      
      
      <categories>
          
          <category> Kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java开发手册</title>
      <link href="/archives/bc91248c.html"/>
      <url>/archives/bc91248c.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://cdn.zenless.top/gh/zhonghanlu/PicGo/img/image-20220822180939274.png" alt="image-20220822180939274"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>《Java开发手册》是阿里巴巴集团技术团队的集体智慧结晶和经验总结，经历了多次大规模一</p><p>线实战的检验及不断完善，公开到业界后，众多社区开发者踊跃参与，共同打磨完善，系统化地整理</p><p>成册，当前的版本是泰山版。现代软件行业的高速发展对开发者的综合素质要求越来越高，因为不仅</p><p>是编程知识点，其它维度的知识点也会影响到软件的最终交付质量。比如：数据库的表结构和索引设</p><p>计缺陷可能带来软件上的架构缺陷或性能风险；工程结构混乱导致后续维护艰难；没有鉴权的漏洞代</p><p>码易被黑客攻击等等。所以本手册以Java开发者为中心视角，划分为 <strong>编程规约、异常日志、单元测</strong></p><p><strong>试、安全规约、MySQL数据库、工程结构、设计规约</strong> 七个维度，再根据内容特征，细分成若干二级</p><p>子目录。另外，依据约束力强弱及故障敏感性，规约依次分为强制、推荐、参考三大类。在延伸信息</p><p>中，“说明”对规约做了适当扩展和解释；“正例”提倡什么样的编码和实现方式；“反例”说明需</p><p>要提防的雷区，以及真实的错误案例。</p><p>手册的愿景是 <strong>码出高效，码出质量</strong> 。现代软件架构的复杂性需要协同开发完成，如何高效地协</p><p>同呢？无规矩不成方圆，无规范难以协同，比如，制订交通法规表面上是要限制行车权，实际上是保</p><p>障公众的人身安全，试想如果没有限速，没有红绿灯，谁还敢上路行驶？对软件来说，适当的规范和</p><p>标准绝不是消灭代码内容的创造性、优雅性，而是限制过度个性化，以一种普遍认可的统一方式一起</p><p>做事，提升协作效率，降低沟通成本。代码的字里行间流淌的是软件系统的血液，质量的提升是尽可</p><p>能少踩坑，杜绝踩重复的坑，切实提升系统稳定性，码出质量。</p><p>我们已经在 2017 杭州云栖大会上发布了配套的Java开发规约IDE插件，下载量达到 152 万人</p><p>次，阿里云效也集成了代码规约扫描引擎。次年，发布 36 万字的配套详解图书《码出高效》，本书</p><p>秉持“图胜于表，表胜于言”的理念，深入浅出地将计算机基础、面向对象思想、JVM探源、数据</p><p>结构与集合、并发与多线程、单元测试等知识客观、立体地呈现出来。紧扣学以致用、学以精进的目</p><p>标，结合阿里巴巴实践经验和故障案例，与底层源码解析融会贯通，娓娓道来。《码出高效》和《Java</p><p>开发手册》书籍版所得收入均捐赠公益事情，希望用技术情怀帮助更多的人。</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li>一、编程规约 前 言<ul><li>(一) 命名风格</li><li>(二) 常量定义</li><li>(三) 代码格式</li><li>(四) OOP规约</li><li>(五) 日期时间</li><li>(六) 集合处理</li><li>(七) 并发处理</li><li>(八) 控制语句</li><li>(九) 注释规约</li><li>(十) 其它</li></ul></li><li>二、异常日志<ul><li>(一) 错误码</li><li>(二) 异常处理</li><li>(三) 日志规约</li></ul></li><li>三、单元测试</li><li>四、安全规约</li><li>五、MySQL数据库<ul><li>(一) 建表规约</li><li>(二) 索引规约</li><li>(三) SQL语句</li><li>(四) ORM映射</li></ul></li><li>六、工程结构<ul><li>(一) 应用分层</li><li>(二) 二方库依赖</li><li>(三) 服务器</li></ul></li><li>七、设计规约</li><li>附 1 ：版本历史</li><li>附 2 ：专有名词解释</li><li>附 3 ：错误码列表</li></ul><h2 id="一、-编程规约"><a href="#一、-编程规约" class="headerlink" title="一、 编程规约"></a>一、 编程规约</h2><h3 id="一-命名风格"><a href="#一-命名风格" class="headerlink" title="(一) 命名风格"></a>(一) 命名风格</h3><ol><li>【强制】代码中的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束。<br> 反例：<em>name &#x2F; <em><em>name &#x2F; $name &#x2F; name</em> &#x2F; name$ &#x2F; name</em></em></li><li>【强制】所有编程相关的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。<br>说明：正确的英文拼写和语法可以让阅读者易于理解，避免歧义。注意，纯拼音命名方式更要避免采用。<br>正例：ali &#x2F; alibaba &#x2F; taobao &#x2F; cainiao&#x2F; aliyun&#x2F; youku &#x2F; hangzhou 等国际通用的名称，可视同英文。<br>反例：DaZhePromotion [打折] &#x2F; getPingfenByName() [评分] &#x2F; int 某变量 &#x3D; 3</li><li>【强制】类名使用UpperCamelCase风格，但以下情形例外：DO &#x2F; BO &#x2F; DTO &#x2F; VO &#x2F; AO &#x2F;<br> PO &#x2F; UID等。<br> 正例：ForceCode &#x2F; UserDO &#x2F; HtmlDTO &#x2F; XmlService &#x2F; TcpUdpDeal &#x2F; TaPromotion<br> 反例：forcecode &#x2F; UserDo &#x2F; HTMLDto &#x2F; XMLService &#x2F; TCPUDPDeal &#x2F; TAPromotion</li><li>【强制】方法名、参数名、成员变量、局部变量都统一使用lowerCamelCase风格。<br> 正例： localValue &#x2F; getHttpMessage() &#x2F; inputUserId</li><li>【强制】常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。<br> 正例：MAX_STOCK_COUNT &#x2F; CACHE_EXPIRED_TIME<br> 反例：MAX_COUNT &#x2F; EXPIRED_TIME</li><li>【强制】抽象类命名使用Abstract或Base开头；异常类命名使用Exception结尾；测试类<br> 命名以它要测试的类的名称开始，以Test结尾。</li><li>【强制】类型与中括号紧挨相连来表示数组。<br> 正例：定义整形数组int[] arrayDemo;<br> 反例：在main参数中，使用String args[]来定义。</li><li>【强制】POJO类中的任何布尔类型的变量，都不要加is前缀，否则部分框架解析会引起序列<br> 化错误。<br> 说明：在本文MySQL规约中的建表约定第一条，表达是与否的值采用is_xxx的命名方式，所以，需要在<br> <resultMap>设置从is_xxx到xxx的映射关系。</li></ol><h4 id="版本号-制定团队-更新日期-备注"><a href="#版本号-制定团队-更新日期-备注" class="headerlink" title="版本号 制定团队 更新日期 备注"></a>版本号 制定团队 更新日期 备注</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 .6.0 阿里巴巴与Java社区开发者 2020. 04. 22 泰山版，首次发布错误码统一方案</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">反例：定义为基本数据类型Boolean isDeleted的属性，它的方法也是isDeleted()，框架在反向解析的时</span><br><span class="line">候，“误以为”对应的属性名称是deleted，导致属性获取不到，进而抛出异常。</span><br></pre></td></tr></table></figure><ol start="9"><li><p>【强制】包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用<br> 单数形式，但是类名如果有复数含义，类名可以使用复数形式。<br> 正例：应用工具类包名为com.alibaba.ei.kunlun.aap.util、类名为MessageUtils（此规则参考spring的<br> 框架结构）</p></li><li><p>【强制】避免在子父类的成员变量之间、或者不同代码块的局部变量之间采用完全相同的命名，<br>使可读性降低。<br>说明：子类、父类成员变量名相同，即使是public类型的变量也是能够通过编译，而局部变量在同一方法<br>内的不同代码块中同名也是合法的，但是要避免使用。对于非setter&#x2F;getter的参数名称也要避免与成员变<br>量名称相同。<br>反例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfusingName</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> stock;</span><br><span class="line"><span class="comment">// 非setter/getter的参数名称，不允许与本类成员变量同名</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">get</span><span class="params">(String alibaba)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">money</span> <span class="operator">=</span> <span class="number">666</span> ;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++) &#123;</span><br><span class="line"><span class="comment">// 在同一方法体中，不允许与其它代码块中的money命名相同</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">money</span> <span class="operator">=</span> <span class="number">15978</span> ;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">ConfusingName</span> &#123;</span><br><span class="line"><span class="comment">// 不允许与父类的成员变量名称相同</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> stock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>【强制】杜绝完全不规范的缩写，避免望文不知义。<br>反例：AbstractClass“缩写”命名成AbsClass；condition“缩写”命名成 condi，此类随意缩写严重降<br>低了代码的可阅读性。</p></li><li><p>【推荐】为了达到代码自解释的目标，任何自定义编程元素在命名时，使用尽量完整的单词组<br>合来表达。<br>正例：在JDK中，对某个对象引用的volatile字段进行原子更新的类名为：AtomicReferenceFieldUpdater。<br>反例：常见的方法内变量为int a;的定义方式。</p></li><li><p>【推荐】在常量与变量的命名时，表示类型的名词放在词尾，以提升辨识度。<br>正例：startTime &#x2F; workQueue &#x2F; nameList &#x2F; TERMINATED_THREAD_COUNT<br>反例：startedAt &#x2F; QueueOfWork &#x2F; listName &#x2F; COUNT_TERMINATED_THREAD</p></li><li><p>【推荐】如果模块、接口、类、方法使用了设计模式，在命名时需体现出具体模式。<br>说明：将设计模式体现在名字中，有利于阅读者快速理解架构设计理念。<br>正例： public class OrderFactory;<br>public class LoginProxy;<br>public class ResourceObserver;</p></li><li><p>【推荐】接口类中的方法和属性不要加任何修饰符号（public 也不要加），保持代码的简洁<br>性，并加上有效的Javadoc注释。尽量不要在接口里定义变量，如果一定要定义变量，确定<br>与接口方法相关，并且是整个应用的基础常量。<br>正例：接口方法签名 void commit();<br>接口基础常量 String COMPANY &#x3D; “alibaba”;<br>反例：接口方法定义 public abstract void f();<br>说明：JDK8中接口允许有默认实现，那么这个default方法，是对所有实现类都有价值的默认实现。</p></li><li><p>接口和实现类的命名有两套规则：<br>1 ）【强制】对于Service和DAO类，基于SOA的理念，暴露出来的服务一定是接口，内部的实现类用<br>Impl的后缀与接口区别。<br>正例：CacheServiceImpl实现CacheService接口。<br>2 ）【推荐】如果是形容能力的接口名称，取对应的形容词为接口名（通常是–able的形容词）。<br>正例：AbstractTranslator实现 Translatable接口。</p></li><li><p>【参考】枚举类名带上Enum后缀，枚举成员名称需要全大写，单词间用下划线隔开。<br>说明：枚举其实就是特殊的常量类，且构造方法被默认强制是私有。<br>正例：枚举名字为ProcessStatusEnum的成员名称：SUCCESS &#x2F; UNKNOWN_REASON。</p></li><li><p>【参考】各层命名规约：<br>A) Service&#x2F;DAO层方法命名规约<br>1 ） 获取单个对象的方法用get做前缀。<br>2 ） 获取多个对象的方法用list做前缀，复数结尾，如：listObjects。<br>3 ） 获取统计值的方法用count做前缀。<br>4 ） 插入的方法用save&#x2F;insert做前缀。<br>5 ） 删除的方法用remove&#x2F;delete做前缀。<br>6 ） 修改的方法用update做前缀。<br>B) 领域模型命名规约<br>1 ） 数据对象：xxxDO，xxx即为数据表名。<br>2 ） 数据传输对象：xxxDTO，xxx为业务领域相关的名称。</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3 ） 展示对象：xxxVO，xxx一般为网页名称。</span><br><span class="line">4 ） POJO是DO/DTO/BO/VO的统称，禁止命名成xxxPOJO。</span><br></pre></td></tr></table></figure><h3 id="二-常量定义"><a href="#二-常量定义" class="headerlink" title="(二) 常量定义"></a>(二) 常量定义</h3><ol><li>【强制】不允许任何魔法值（即未经预先定义的常量）直接出现在代码中。<br> 反例：<br>&#x2F;&#x2F;本例中同学A定义了缓存的key，然后缓存提取的同学B使用了Id#taobao来提取，少了下划线，导致故障。<br>String key &#x3D; “Id#taobao_” + tradeId;<br>cache.put(key, value);</li><li>【强制】在long或者Long赋值时，数值后使用大写的L，不能是小写的l，小写容易跟数字<br>混淆，造成误解。<br>说明：Long a &#x3D; 2l; 写的是数字的 21 ，还是Long型的 2 。</li><li>【推荐】不要使用一个常量类维护所有常量，要按常量功能进行归类，分开维护。<br> 说明：大而全的常量类，杂乱无章，使用查找功能才能定位到修改的常量，不利于理解，也不利于维护。<br>正例：缓存相关常量放在类CacheConsts下；系统配置相关常量放在类ConfigConsts下。</li><li>【推荐】常量的复用层次有五层：跨应用共享常量、应用内共享常量、子工程内共享常量、包<br> 内共享常量、类内共享常量。<br> 1 ） 跨应用共享常量：放置在二方库中，通常是client.jar中的constant目录下。<br> 2 ） 应用内共享常量：放置在一方库中，通常是子模块中的constant目录下。<br> 反例：易懂变量也要统一定义成应用内共享常量，两位工程师在两个类中分别定义了“YES”的变量：<br> 类A中：public static final String YES &#x3D; “yes”;<br> 类B中：public static final String YES &#x3D; “y”;<br> A.YES.equals(B.YES)，预期是true，但实际返回为false，导致线上问题。<br>3 ） 子工程内部共享常量：即在当前子工程的constant目录下。<br>4 ） 包内共享常量：即在当前包下单独的constant目录下。<br>5 ） 类内共享常量：直接在类内部private static final定义。</li><li>【推荐】如果变量值仅在一个固定范围内变化用enum类型来定义。<br> 说明：如果存在名称之外的延伸属性应使用enum类型，下面正例中的数字就是延伸信息，表示一年中的<br> 第几个季节。<br> 正例：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> public enum SeasonEnum &#123;</span><br><span class="line">   SPRING( 1 ), SUMMER( 2 ), AUTUMN( 3 ), WINTER( 4 );</span><br><span class="line">   private int seq;</span><br><span class="line">   SeasonEnum(int seq) &#123;</span><br><span class="line">   this.seq = seq;</span><br><span class="line">   &#125;</span><br><span class="line">   public int getSeq() &#123;</span><br><span class="line">return seq;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三-代码格式"><a href="#三-代码格式" class="headerlink" title="(三) 代码格式"></a>(三) 代码格式</h3><ol><li>【强制】如果是大括号内为空，则简洁地写成{}即可，大括号中间无需换行和空格；如果是非<br> 空代码块则：<br> 1 ） 左大括号前不换行。<br> 2 ） 左大括号后换行。<br> 3 ） 右大括号前换行。<br> 4 ） 右大括号后还有else等代码则不换行；表示终止的右大括号后必须换行。</li><li>【强制】左小括号和右边相邻字符之间不出现空格；右小括号和左边相邻字符之间也不出现空<br>格；而左大括号前需要加空格。详见第 5 条下方正例提示。<br>反例：if (空格a &#x3D;&#x3D; b空格)</li><li>【强制】if&#x2F;for&#x2F;while&#x2F;switch&#x2F;do等保留字与括号之间都必须加空格。</li><li>【强制】任何二目、三目运算符的左右两边都需要加一个空格。<br> 说明：包括赋值运算符&#x3D;、逻辑运算符&amp;&amp;、加减乘除符号等。</li><li>【强制】采用 4 个空格缩进，禁止使用tab字符。<br>  说明：如果使用tab缩进，必须设置 1 个tab为 4 个空格。IDEA设置tab为 4 个空格时，请勿勾选Use tab<br>  character；而在eclipse中，必须勾选insert spaces for tabs。<br>  正例： （涉及 1 - 5 点）</li></ol>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">// 缩进 4 个空格</span></span><br><span class="line"><span class="type">String</span> <span class="variable">say</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="comment">// 运算符的左右必须有一个空格</span></span><br><span class="line"><span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="number">0</span> ;</span><br><span class="line"><span class="comment">// 关键词if与括号之间必须有一个空格，括号内的f与左括号， 0 与右括号不需要空格</span></span><br><span class="line"><span class="keyword">if</span> (flag == <span class="number">0</span> ) &#123;</span><br><span class="line">System.out.println(say);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 左大括号前加空格且不换行；左大括号后换行</span></span><br><span class="line"><span class="keyword">if</span> (flag == <span class="number">1</span> ) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;world&quot;</span>);</span><br><span class="line"><span class="comment">// 右大括号前换行，右大括号后有else，不用换行</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line"><span class="comment">// 在右大括号后直接结束，则必须换行</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li><p>【强制】注释的双斜线与注释内容之间有且仅有一个空格。<br> 正例：<br>&#x2F;&#x2F; 这是示例注释，请注意在双斜线之后有一个空格<br>String commentString &#x3D; new String();</p></li><li><p>【强制】在进行类型强制转换时，右括号与强制转换值之间不需要任何空格隔开。<br> 正例：<br>long first &#x3D; 1000000000000L;<br>int second &#x3D; (int)first + 2 ;</p></li><li><p>【强制】单行字符数限制不超过 120 个，超出需要换行，换行时遵循如下原则：<br> 1 ）第二行相对第一行缩进 4 个空格，从第三行开始，不再继续缩进，参考示例。<br> 2 ）运算符与下文一起换行。<br> 3 ）方法调用的点符号与下文一起换行。<br> 4 ）方法调用中的多个参数需要换行时，在逗号后进行。<br> 5 ）在括号前不要换行，见反例。<br> 正例：</p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">  <span class="comment">// 超过 120 个字符的情况下，换行缩进 4 个空格，并且方法前的点号一起换行</span></span><br><span class="line">  sb.append(<span class="string">&quot;zi&quot;</span>).append(<span class="string">&quot;xin&quot;</span>)...</span><br><span class="line">  .append(<span class="string">&quot;huang&quot;</span>)...</span><br><span class="line">  .append(<span class="string">&quot;huang&quot;</span>)...</span><br><span class="line">  .append(<span class="string">&quot;huang&quot;</span>);</span><br></pre></td></tr></table></figure><p> 反例：</p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">  <span class="comment">// 超过 120 个字符的情况下，不要在括号前换行</span></span><br><span class="line">  sb.append(<span class="string">&quot;you&quot;</span>).append(<span class="string">&quot;are&quot;</span>)...append</span><br><span class="line">  (<span class="string">&quot;lucky&quot;</span>);</span><br><span class="line">  <span class="comment">// 参数很多的方法调用可能超过 120 个字符，逗号后才是换行处</span></span><br><span class="line">  method(args1, args2, args3, ...</span><br><span class="line">  , argsX);</span><br></pre></td></tr></table></figure></li><li><p>【强制】方法参数在定义和传入时，多个参数逗号后边必须加空格。<br> 正例：下例中实参的args1，后边必须要有一个空格。<br>method(args1, args2, args3);</p></li><li><p>【强制】IDE的text file encoding设置为UTF-8; IDE中文件的换行符使用Unix格式，不要<br>使用Windows格式。</p></li><li><p>【推荐】单个方法的总行数不超过 80 行。<br>说明：除注释之外的方法签名、左右大括号、方法内代码、空行、回车及任何不可见字符的总行数不超过<br>80 行。<br>正例：代码逻辑分清红花和绿叶，个性和共性，绿叶逻辑单独出来成为额外方法，使主干代码更加清晰；共<br>性逻辑抽取成为共性方法，便于复用和维护。</p></li><li><p>【推荐】没有必要增加若干空格来使变量的赋值等号与上一行对应位置的等号对齐。<br>正例：<br>   int one &#x3D; 1 ;<br>   long two &#x3D; 2 L;<br>   float three &#x3D; 3F;<br>   StringBuilder sb &#x3D; new StringBuilder();<br>说明：增加sb这个变量，如果需要对齐，则给one、two、three都要增加几个空格，在变量比较多的情<br>况下，是非常累赘的事情。</p></li><li><p>【推荐】不同逻辑、不同语义、不同业务的代码之间插入一个空行分隔开来以提升可读性。<br>说明：任何情形，没有必要插入多个空行进行隔开。</p></li></ol><h3 id="四-OOP规约"><a href="#四-OOP规约" class="headerlink" title="(四) OOP规约"></a>(四) OOP规约</h3><ol><li><p>【强制】避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成<br> 本，直接用类名来访问即可。</p></li><li><p>【强制】所有的覆写方法，必须加@Override注解。<br> 说明：getObject()与get0bject()的问题。一个是字母的O，一个是数字的 0 ，加@Override可以准确判<br> 断是否覆盖成功。另外，如果在抽象类中对方法签名进行修改，其实现类会马上编译报错。</p></li><li><p>【强制】相同参数类型，相同业务含义，才可以使用Java的可变参数，避免使用Object。<br>说明：可变参数必须放置在参数列表的最后。（提倡同学们尽量不用可变参数编程）<br>正例：public List<User> listUsers(String type, Long… ids) {…}</p></li><li><p>【强制】外部正在调用或者二方库依赖的接口，不允许修改方法签名，避免对接口调用方产生<br> 影响。接口过时必须加@Deprecated注解，并清晰地说明采用的新接口或者新服务是什么。</p></li><li><p>【强制】不能使用过时的类或方法。<br> 说明：java.net.URLDecoder 中的方法decode(String encodeStr) 这个方法已经过时，应该使用双参数<br> decode(String source, String encode)。接口提供方既然明确是过时接口，那么有义务同时提供新的接口；<br> 作为调用方来说，有义务去考证过时方法的新实现是什么。</p></li><li><p>【强制】Object的equals方法容易抛空指针异常，应使用常量或确定有值的对象来调用equals。<br> 正例：”test”.equals(object);<br> 反例：object.equals(“test”);<br> 说明：推荐使用java.util.Objects#equals（JDK7引入的工具类）。</p></li><li><p>【强制】所有整型包装类对象之间值的比较，全部使用equals方法比较。<br> 说明：对于Integer var &#x3D;? 在- 128 至 127 之间的赋值，Integer对象是在 IntegerCache.cache产生，<br> 会复用已有对象，这个区间内的Integer值可以直接使用&#x3D;&#x3D;进行判断，但是这个区间之外的所有数据，都<br> 会在堆上产生，并不会复用已有对象，这是一个大坑，推荐使用equals方法进行判断。</p></li><li><p>【强制】任何货币金额，均以最小货币单位且整型类型来进行存储。</p></li><li><p>【强制】浮点数之间的等值判断，基本数据类型不能用&#x3D;&#x3D;来比较，包装数据类型不能用equals<br>  来判断。<br>  说明：浮点数采用“尾数+阶码”的编码方式，类似于科学计数法的“有效数字+指数”的表示方式。二进<br>  制无法精确表示大部分的十进制小数，具体原理参考《码出高效》。<br>  反例：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1.0f</span> - <span class="number">0.9f</span>;</span><br><span class="line"><span class="type">float</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0.9f</span> - <span class="number">0.8f</span>;</span><br><span class="line"><span class="keyword">if</span> (a == b) &#123;</span><br><span class="line"><span class="comment">// 预期进入此代码快，执行其它业务逻辑</span></span><br><span class="line"><span class="comment">// 但事实上a==b的结果为false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Float</span> <span class="variable">x</span> <span class="operator">=</span> Float.valueOf(a);</span><br><span class="line"><span class="type">Float</span> <span class="variable">y</span> <span class="operator">=</span> Float.valueOf(b);</span><br><span class="line"><span class="keyword">if</span> (x.equals(y)) &#123;</span><br><span class="line"><span class="comment">// 预期进入此代码快，执行其它业务逻辑</span></span><br><span class="line"><span class="comment">// 但事实上equals的结果为false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>  正例：<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>) 指定一个误差范围，两个浮点数的差值在此范围之内，则认为是相等的。</span><br><span class="line"><span class="type">float</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1.0f</span> - <span class="number">0.9f</span>;</span><br><span class="line"><span class="type">float</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0.9f</span> - <span class="number">0.8f</span>;</span><br><span class="line"><span class="type">float</span> <span class="variable">diff</span> <span class="operator">=</span> <span class="number">1e-6f</span>;</span><br><span class="line"><span class="keyword">if</span> (Math.abs(a - b) &lt; diff) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;true&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">(<span class="number">2</span>) 使用BigDecimal来定义值，再进行浮点数的运算操作。</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.0&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.9&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.8&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">x</span> <span class="operator">=</span> a.subtract(b);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">y</span> <span class="operator">=</span> b.subtract(c);</span><br><span class="line"><span class="keyword">if</span> (x.equals(y)) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;true&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="10"><li>【强制】定义数据对象DO类时，属性类型要与数据库字段类型相匹配。<br>正例：数据库字段的bigint必须与类属性的Long类型相对应。<br>反例：某个案例的数据库表id字段定义类型bigint unsigned，实际类对象属性为Integer，随着id越来<br>越大，超过Integer的表示范围而溢出成为负数。</li><li>【强制】禁止使用构造方法BigDecimal(double)的方式把double值转化为BigDecimal对象。<br>说明：BigDecimal(double)存在精度损失风险，在精确计算或值比较的场景中可能会导致业务逻辑异常。</li></ol><p>如：BigDecimal g &#x3D; new BigDecimal(0.1f); 实际的存储值为：0.<br>正例：优先推荐入参为String的构造方法，或使用BigDecimal的valueOf方法，此方法内部其实执行了<br>Double的toString，而Double的toString按double的实际能表达的精度对尾数进行了截断。<br>BigDecimal recommend1 &#x3D; new BigDecimal(“0.1”);<br>BigDecimal recommend2 &#x3D; BigDecimal.valueOf(0.1);</p><ol start="12"><li><p>关于基本数据类型与包装数据类型的使用标准如下：<br>1 ） 【强制】所有的POJO类属性必须使用包装数据类型。<br>2 ） 【强制】RPC方法的返回值和参数必须使用包装数据类型。<br>3 ） 【推荐】所有的局部变量使用基本数据类型。<br>说明：POJO类属性没有初值是提醒使用者在需要使用时，必须自己显式地进行赋值，任何NPE问题，或<br>者入库检查，都由使用者来保证。<br>正例：数据库的查询结果可能是null，因为自动拆箱，用基本数据类型接收有NPE风险。<br>反例：某业务的交易报表上显示成交总额涨跌情况，即正负x%，x为基本数据类型，调用的RPC服务，调<br>用不成功时，返回的是默认值，页面显示为0%，这是不合理的，应该显示成中划线-。所以包装数据类型<br>的null值，能够表示额外的信息，如：远程调用失败，异常退出。</p></li><li><p>【强制】定义DO&#x2F;DTO&#x2F;VO等POJO类时，不要设定任何属性默认值。<br>反例：POJO类的createTime默认值为new Date()，但是这个属性在数据提取时并没有置入具体值，在<br>更新其它字段时又附带更新了此字段，导致创建时间被修改成当前时间。</p></li><li><p>【强制】序列化类新增属性时，请不要修改serialVersionUID字段，避免反序列失败；如果<br>完全不兼容升级，避免反序列化混乱，那么请修改serialVersionUID值。<br>说明：注意serialVersionUID不一致会抛出序列化运行时异常。</p></li><li><p>【强制】构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在init方法中。</p></li><li><p>【强制】POJO类必须写toString方法。使用IDE中的工具：source&gt; generate toString<br>时，如果继承了另一个POJO类，注意在前面加一下super.toString。<br>说明：在方法执行抛出异常时，可以直接调用POJO的toString()方法打印其属性值，便于排查问题。</p></li><li><p>【强制】禁止在POJO类中，同时存在对应属性xxx的isXxx()和getXxx()方法。<br>说明：框架在调用属性xxx的提取方法时，并不能确定哪个方法一定是被优先调用到，神坑之一。</p></li><li><p>【推荐】使用索引访问用String的split方法得到的数组时，需做最后一个分隔符后有无内容<br>的检查，否则会有抛IndexOutOfBoundsException的风险。<br>说明：<br>String str &#x3D; “a,b,c,,”;<br>String[] ary &#x3D; str.split(“,”);<br>&#x2F;&#x2F; 预期大于 3 ，结果是 3<br>System.out.println(ary.length);</p></li><li><p>【推荐】当一个类有多个构造方法，或者多个同名方法，这些方法应该按顺序放置在一起，便<br>于阅读，此条规则优先于下一条。</p></li><li><p>【推荐】 类内方法定义的顺序依次是：公有方法或保护方法 &gt; 私有方法 &gt; getter &#x2F; setter<br>方法。<br>说明：公有方法是类的调用者和维护者最关心的方法，首屏展示最好；保护方法虽然只是子类关心，也可<br>能是“模板设计模式”下的核心方法；而私有方法外部一般不需要特别关心，是一个黑盒实现；因为承载<br>的信息价值较低，所有Service和DAO的getter&#x2F;setter方法放在类体最后。</p></li><li><p>【推荐】setter方法中，参数名称与类成员变量名称一致，this.成员名 &#x3D; 参数名。在<br>getter&#x2F;setter方法中，不要增加业务逻辑，增加排查问题的难度。<br>反例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Integer <span class="title function_">getData</span> <span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.data + <span class="number">100</span> ;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.data - <span class="number">100</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>【推荐】循环体内，字符串的连接方式，使用StringBuilder的append方法进行扩展。<br>说明：下例中，反编译出的字节码文件显示每次循环都会new出一个StringBuilder对象，然后进行append<br>操作，最后通过toString方法返回String对象，造成内存资源浪费。<br>反例：<br>String str &#x3D; “start”;<br>for (int i &#x3D; 0 ; i &lt; 100 ; i++) {<br>str &#x3D; str + “hello”;<br>}</p></li><li><p>【推荐】final可以声明类、成员变量、方法、以及本地变量，下列情况使用final关键字：<br>1 ） 不允许被继承的类，如：String类。<br>2 ） 不允许修改引用的域对象，如：POJO类的域变量。<br>3 ） 不允许被覆写的方法，如：POJO类的setter方法。<br>4 ） 不允许运行过程中重新赋值的局部变量。<br>5 ） 避免上下文重复使用一个变量，使用final可以强制重新定义一个变量，方便更好地进行重构。</p></li><li><p>【推荐】慎用Object的clone方法来拷贝对象。<br>说明：对象clone方法默认是浅拷贝，若想实现深拷贝需覆写clone方法实现域对象的深度遍历式拷贝。</p></li><li><p>【推荐】类成员与方法访问控制从严：<br>1 ） 如果不允许外部直接通过new来创建对象，那么构造方法必须是private。<br>2 ） 工具类不允许有public或default构造方法。<br>3 ） 类非static成员变量并且与子类共享，必须是protected。<br>4 ） 类非static成员变量并且仅在本类使用，必须是private。<br>5 ） 类static成员变量如果仅在本类使用，必须是private。<br>6 ） 若是static成员变量，考虑是否为final。</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">7 ） 类成员方法只供类内部调用，必须是private。</span><br><span class="line">8 ） 类成员方法只对继承类公开，那么限制为protected。</span><br><span class="line">说明：任何类、方法、参数、变量，严控访问范围。过于宽泛的访问范围，不利于模块解耦。思考：如果</span><br><span class="line">是一个private的方法，想删除就删除，可是一个public的service成员方法或成员变量，删除一下，不</span><br><span class="line">得手心冒点汗吗？变量像自己的小孩，尽量在自己的视线内，变量作用域太大，无限制的到处跑，那么你</span><br><span class="line">会担心的。</span><br></pre></td></tr></table></figure><h3 id="五-日期时间"><a href="#五-日期时间" class="headerlink" title="(五) 日期时间"></a>(五) 日期时间</h3><ol><li>【强制】日期格式化时，传入pattern中表示年份统一使用小写的y。<br> 说明：日期格式化时，yyyy表示当天所在的年，而大写的YYYY代表是week in which year（JDK7之后<br> 引入的概念），意思是当天所在的周属于的年份，一周从周日开始，周六结束，只要本周跨年，返回的YYYY<br> 就是下一年。<br> 正例：表示日期和时间的格式如下所示：<br> new SimpleDateFormat(“yyyy-MM-dd HH:mm:ss”)</li><li>【强制】在日期格式中分清楚大写的M和小写的m，大写的H和小写的h分别指代的意义。<br>说明：日期格式中的这两对字母表意如下：<br>1 ） 表示月份是大写的M；<br>2 ） 表示分钟则是小写的m；<br>3 ） 24 小时制的是大写的H；<br>4 ） 12 小时制的则是小写的h。</li><li>【强制】获取当前毫秒数：System.currentTimeMillis(); 而不是new Date().getTime()。<br> 说明：如果想获取更加精确的纳秒级时间值，使用System.nanoTime的方式。在JDK8中，针对统计时间<br> 等场景，推荐使用Instant类。</li><li>【强制】不允许在程序任何地方中使用： 1 ）java.sql.Date 2）java.sql.Time 3）<br>java.sql.Timestamp。<br>说明：第 1 个不记录时间，getHours()抛出异常；第 2 个不记录日期，getYear()抛出异常；第 3 个在构造<br>方法super((time&#x2F;1000)*1000)，fastTime和nanos分开存储秒和纳秒信息。<br>反例： java.util.Date.after(Date)进行时间比较时，当入参是java.sql.Timestamp时，会触发JDK<br>BUG(JDK9已修复)，可能导致比较时的意外结果。</li><li>【强制】不要在程序中写死一年为 365 天，避免在公历闰年时出现日期转换错误或程序逻辑<br>错误。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">正例：</span><br><span class="line">// 获取今年的天数</span><br><span class="line">int daysOfThisYear = LocalDate.now().lengthOfYear();</span><br><span class="line">// 获取指定某年的天数</span><br><span class="line">LocalDate.of( 2011 , 1 , 1 ).lengthOfYear();</span><br><span class="line">反例：</span><br><span class="line">// 第一种情况：在闰年 366 天时，出现数组越界异常</span><br><span class="line">int[] dayArray = new int[ 365 ];</span><br><span class="line">// 第二种情况：一年有效期的会员制，今年 1 月 26 日注册，硬编码 365 返回的却是 1 月 25 日</span><br><span class="line">Calendar calendar = Calendar.getInstance();</span><br><span class="line">calendar.set( 2020 , 1 , 26 );</span><br><span class="line">calendar.add(Calendar.DATE, 365 );</span><br></pre></td></tr></table></figure><ol start="6"><li>【推荐】避免公历闰年 2 月问题。闰年的 2 月份有 29 天，一年后的那一天不可能是 2 月 29<br> 日。</li><li>【推荐】使用枚举值来指代月份。如果使用数字，注意Date，Calendar等日期相关类的月份<br> month取值在 0 - 11 之间。<br> 说明：参考JDK原生注释，Month value is 0-based. e.g., 0 for January.<br> 正例： Calendar.JANUARY，Calendar.FEBRUARY，Calendar.MARCH等来指代相应月份来进行传参或<br> 比较。</li></ol><h3 id="六-集合处理"><a href="#六-集合处理" class="headerlink" title="(六) 集合处理"></a>(六) 集合处理</h3><ol><li><p>【强制】关于hashCode和equals的处理，遵循如下规则：<br> 1 ） 只要重写equals，就必须重写hashCode。<br> 2 ） 因为Set存储的是不重复的对象，依据hashCode和equals进行判断，所以Set存储的对象必须重写<br> 这两个方法。<br> 3 ） 如果自定义对象作为Map的键，那么必须覆写hashCode和equals。<br> 说明：String因为重写了hashCode和equals方法，所以我们可以愉快地使用String对象作为key来使<br> 用。</p></li><li><p>【强制】判断所有集合内部的元素是否为空，使用isEmpty()方法，而不是size()&#x3D;&#x3D;0的方式。<br> 说明：前者的时间复杂度为O(1)，而且可读性更好。<br> 正例：<br>Map&lt;String, Object&gt; map &#x3D; new HashMap&lt;&gt;();<br>if(map.isEmpty()) {<br>System.out.println(“no element in this map.”);<br>}</p></li><li><p>【强制】在使用java.util.stream.Collectors类的toMap()方法转为Map集合时，一定要使<br> 用含有参数类型为BinaryOperator，参数名为mergeFunction的方法，否则当出现相同key<br> 值时会抛出IllegalStateException异常。<br> 说明：参数mergeFunction的作用是当出现key重复时，自定义对value的处理策略。<br> 正例：<br>List&lt;Pair&lt;String, Double&gt;&gt; pairArrayList &#x3D; new ArrayList&lt;&gt;( 3 );<br>pairArrayList.add(new Pair&lt;&gt;(“version”, 6.19));<br>pairArrayList.add(new Pair&lt;&gt;(“version”, 10.24));<br>pairArrayList.add(new Pair&lt;&gt;(“version”, 13.14));<br>Map&lt;String, Double&gt; map &#x3D; pairArrayList.stream().collect(<br>&#x2F;&#x2F; 生成的map集合中只有一个键值对：{version&#x3D;13.14}<br>Collectors.toMap(Pair::getKey, Pair::getValue, (v1, v2) - &gt; v2));<br> 反例：<br>String[] departments &#x3D; new String[] {“iERP”, “iERP”, “EIBU”};<br>&#x2F;&#x2F; 抛出IllegalStateException异常<br>Map&lt;Integer, String&gt; map &#x3D; Arrays.stream(departments)<br>.collect(Collectors.toMap(String::hashCode, str -&gt; str));</p></li><li><p>【强制】在使用java.util.stream.Collectors类的toMap()方法转为Map集合时，一定要注<br> 意当value为null时会抛NPE异常。<br> 说明：在java.util.HashMap的merge方法里会进行如下的判断：<br>if (value &#x3D;&#x3D; null || remappingFunction &#x3D;&#x3D; null)<br>   throw new NullPointerException();<br> 反例：<br>List&lt;Pair&lt;String, Double&gt;&gt; pairArrayList &#x3D; new ArrayList&lt;&gt;( 2 );<br>pairArrayList.add(new Pair&lt;&gt;(“version1”, 4.22));<br>pairArrayList.add(new Pair&lt;&gt;(“version2”, null));<br>Map&lt;String, Double&gt; map &#x3D; pairArrayList.stream().collect(<br>&#x2F;&#x2F; 抛出NullPointerException异常<br>Collectors.toMap(Pair::getKey, Pair::getValue, (v1, v2) - &gt; v2));</p></li><li><p>【强制】ArrayList的subList结果不可强转成ArrayList，否则会抛出 ClassCastException异<br> 常：java.util.RandomAccessSubList cannot be cast to java.util.ArrayList。<br> 说明：subList 返回的是ArrayList的内部类SubList，并不是 ArrayList而是ArrayList 的一个视图，对<br> 于SubList子列表的所有操作最终会反映到原列表上。</p></li><li><p>【强制】使用Map的方法keySet()&#x2F;values()&#x2F;entrySet()返回集合对象时，不可以对其进行添<br> 加元素操作，否则会抛出UnsupportedOperationException异常。</p></li><li><p>【强制】Collections类返回的对象，如：emptyList()&#x2F;singletonList()等都是immutable list，<br>不可对其进行添加或者删除元素的操作。<br>反例：如果查询无结果，返回Collections.emptyList()空集合对象，调用方一旦进行了添加元素的操作，就<br>会触发UnsupportedOperationException异常。</p></li><li><p>【强制】在subList场景中，高度注意对父集合元素的增加或删除，均会导致子列表的遍历、<br> 增加、删除产生ConcurrentModificationException 异常。</p></li><li><p>【强制】使用集合转数组的方法，必须使用集合的toArray(T[] array)，传入的是类型完全一<br>致、长度为 0 的空数组。<br>反例：直接使用toArray无参方法存在问题，此方法返回值只能是Object[]类，若强转其它类型数组将出现<br>ClassCastException错误。<br>正例：<br>List<String> list &#x3D; new ArrayList&lt;&gt;( 2 );<br>list.add(“guan”);<br>list.add(“bao”);<br>String[] array &#x3D; list.toArray(new String[ 0 ]);</p></li></ol><p>说明：使用toArray带参方法，数组空间大小的length，<br>1 ） 等于 0 ，动态创建与size相同的数组，性能最好。<br>2 ） 大于 0 但小于size，重新创建大小等于size的数组，增加GC负担。<br>3 ） 等于size，在高并发情况下，数组创建完成之后，size正在变大的情况下，负面影响与 2 相同。<br>4 ） 大于size，空间浪费，且在size处插入null值，存在NPE隐患。</p><ol start="10"><li>【强制】在使用Collection接口任何实现类的addAll()方法时，都要对输入的集合参数进行<br>NPE判断。<br>说明：在ArrayList#addAll方法的第一行代码即Object[] a &#x3D; c.toArray(); 其中c为输入集合参数，如果<br>为null，则直接抛出异常。</li><li>【强制】使用工具类Arrays.asList()把数组转换成集合时，不能使用其修改集合相关的方法，<br>它的add&#x2F;remove&#x2F;clear方法会抛出UnsupportedOperationException异常。<br>说明：asList的返回对象是一个Arrays内部类，并没有实现集合的修改方法。Arrays.asList体现的是适配<br>器模式，只是转换接口，后台的数据仍是数组。<br>String[] str &#x3D; new String[] { “yang”, “hao” };<br>List list &#x3D; Arrays.asList(str);<br>第一种情况：list.add(“yangguanbao”); 运行时异常。<br>第二种情况：str[0] &#x3D; “changed”; 也会随之修改，反之亦然。</li><li>【强制】泛型通配符&lt;? extends T&gt;来接收返回的数据，此写法的泛型集合不能使用add方法，<br>而&lt;? super T&gt;不能使用get方法，两者在接口调用赋值的场景中容易出错。<br>说明：扩展说一下PECS(Producer Extends Consumer Super)原则：第一、频繁往外读取内容的，适合用<? extends T>。第二、经常往里插入的，适合用<? super T></li><li>【强制】在无泛型限制定义的集合赋值给泛型限制的集合时，在使用集合元素时，需要进行<br>instanceof判断，避免抛出ClassCastException异常。<br>说明：毕竟泛型是在JDK5后才出现，考虑到向前兼容，编译器是允许非泛型集合与泛型集合互相赋值。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">反例：</span><br><span class="line">List&lt;String&gt; generics = null;</span><br><span class="line">List notGenerics = new ArrayList( 10 );</span><br><span class="line">notGenerics.add(new Object());</span><br><span class="line">notGenerics.add(new Integer( 1 ));</span><br><span class="line">generics = notGenerics;</span><br><span class="line">// 此处抛出ClassCastException异常</span><br><span class="line">String string = generics.get( 0 );</span><br></pre></td></tr></table></figure><ol start="14"><li>【强制】不要在foreach循环里进行元素的remove&#x2F;add操作。remove元素请使用Iterator<br>方式，如果并发操作，需要对Iterator对象加锁。<br>   正例：<br>  List<String> list &#x3D; new ArrayList&lt;&gt;();<br>  list.add(“1”);<br>  list.add(“2”);<br>  Iterator<String> iterator &#x3D; list.iterator();<br>  while (iterator.hasNext()) {<br>  String item &#x3D; iterator.next();<br>  if (删除元素的条件) {<br>  iterator.remove();<br>  }<br>  }<br>   反例：<br>  for (String item : list) {<br>  if (“1”.equals(item)) {<br>  list.remove(item);<br>  }<br>  }<br>   说明：以上代码的执行结果肯定会出乎大家的意料，那么试一下把“1”换成“2”，会是同样的结果吗？</li><li>【强制】在JDK 7 版本及以上，Comparator实现类要满足如下三个条件，不然Arrays.sort，<br>Collections.sort会抛IllegalArgumentException异常。<br>说明：三个条件如下<br>1 ） x，y的比较结果和y，x的比较结果相反。<br>2 ） x&gt;y，y&gt;z，则x&gt;z。<br>3 ） x&#x3D;y，则x，z比较结果和y，z比较结果相同。<br>反例：下例中没有处理相等的情况，交换两个对象判断结果并不互反，不符合第一个条件，在实际使用中<br>可能会出现异常。<br>   new Comparator<Student>() {<br>   @Override<br>   public int compare(Student o1, Student o2) {<br>   return o1.getId() &gt; o2.getId()? 1 : - 1 ;<br>   }<br>   };</li><li>【推荐】集合泛型定义时，在JDK7及以上，使用diamond语法或全省略。<br>说明：菱形泛型，即diamond，直接使用&lt;&gt;来指代前边已经指定的类型。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">正例：</span><br><span class="line">// diamond方式，即&lt;&gt;</span><br><span class="line">HashMap&lt;String, String&gt; userCache = new HashMap&lt;&gt;( 16 );</span><br><span class="line">// 全省略方式</span><br><span class="line">ArrayList&lt;User&gt; users = new ArrayList( 10 );</span><br></pre></td></tr></table></figure><ol start="17"><li>【推荐】集合初始化时，指定集合初始值大小。<br>说明：HashMap使用HashMap(int initialCapacity) 初始化，如果暂时无法确定集合大小，那么指定默<br>认值（ 16 ）即可。<br>正例：initialCapacity &#x3D; (需要存储的元素个数 &#x2F; 负载因子) + 1。注意负载因子（即loader factor）默认<br>为0.75，如果暂时无法确定初始值大小，请设置为 16 （即默认值）。<br>   反例：HashMap需要放置 1024 个元素，由于没有设置容量初始大小，随着元素不断增加，容量 7 次被迫<br>   扩大，resize需要重建hash表。当放置的集合元素个数达千万级别时，不断扩容会严重影响性能。</li><li>【推荐】使用entrySet遍历Map类集合KV，而不是keySet方式进行遍历。<br>说明：keySet其实是遍历了 2 次，一次是转为Iterator对象，另一次是从hashMap中取出key所对应的<br>value。而entrySet只是遍历了一次就把key和value都放到了entry中，效率更高。如果是JDK8，使用<br>Map.forEach方法。<br>正例：values()返回的是V值集合，是一个list集合对象；keySet()返回的是K值集合，是一个Set集合对<br>象；entrySet()返回的是K-V值组合集合。</li><li>【推荐】高度注意Map类集合K&#x2F;V能不能存储null值的情况，如下表格：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">集合类 Key Value Super 说明</span><br><span class="line">Hashtable 不允许为null 不允许为null Dictionary 线程安全</span><br><span class="line">ConcurrentHashMap 不允许为null 不允许为null AbstractMap 锁分段技术（JDK8:CAS）</span><br><span class="line">TreeMap 不允许为null 允许为null AbstractMap 线程不安全</span><br><span class="line">HashMap 允许为null 允许为null AbstractMap 线程不安全</span><br><span class="line">反例：由于HashMap的干扰，很多人认为ConcurrentHashMap是可以置入null值，而事实上，存储</span><br><span class="line">null值时会抛出NPE异常。</span><br></pre></td></tr></table></figure><ol start="20"><li>【参考】合理利用好集合的有序性(sort)和稳定性(order)，避免集合的无序性(unsort)和不稳<br>定性(unorder)带来的负面影响。<br>说明：有序性是指遍历的结果是按某种比较规则依次排列的。稳定性指集合每次遍历的元素次序是一定的。<br>如：ArrayList是order&#x2F;unsort；HashMap是unorder&#x2F;unsort；TreeSet是order&#x2F;sort。</li><li>【参考】利用Set元素唯一的特性，可以快速对一个集合进行去重操作，避免使用List的<br>contains()进行遍历去重或者判断包含操作。</li></ol><h3 id="七-并发处理"><a href="#七-并发处理" class="headerlink" title="(七) 并发处理"></a>(七) 并发处理</h3><ol><li>【强制】获取单例对象需要保证线程安全，其中的方法也要保证线程安全。<br> 说明：资源驱动类、工具类、单例工厂类都需要注意。</li><li>【强制】创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。<br>正例：自定义线程工厂，并且根据外部特征进行分组，比如，来自同一机房的调用，把机房编号赋值给<br>whatFeaturOfGroup<br>public class UserThreadFactory implements ThreadFactory {<br>private final String namePrefix;<br>private final AtomicInteger nextId &#x3D; new AtomicInteger( 1 );<br>&#x2F;&#x2F; 定义线程组名称，在jstack问题排查时，非常有帮助<br>UserThreadFactory(String whatFeaturOfGroup) {<br>namePrefix &#x3D; “From UserThreadFactory’s “ + whatFeaturOfGroup + “-Worker-“;<br>}<br>@Override<br>public Thread newThread(Runnable task) {<br>String name &#x3D; namePrefix + nextId.getAndIncrement();<br>Thread thread &#x3D; new Thread(null, task, name, 0 , false);<br>System.out.println(thread.getName());<br>return thread;<br>}<br>}</li><li>【强制】线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。<br>说明：线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源的开销，解决资源不足的问题。<br>如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。</li><li>【强制】线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式，这<br>样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。<br>说明：Executors返回的线程池对象的弊端如下：<br>1 ） FixedThreadPool和SingleThreadPool：<br>允许的请求队列长度为Integer.MAX_VALUE，可能会堆积大量的请求，从而导致OOM。<br>2 ） CachedThreadPool：<br>允许的创建线程数量为Integer.MAX_VALUE，可能会创建大量的线程，从而导致OOM。</li><li>【强制】SimpleDateFormat 是线程不安全的类，一般不要定义为static变量，如果定义为static，<br>必须加锁，或者使用DateUtils工具类。<br>正例：注意线程安全，使用DateUtils。亦推荐如下处理：<br>private static final ThreadLocal<DateFormat> df &#x3D; new ThreadLocal<DateFormat>() {<br>@Override<br>protected DateFormat initialValue() {<br>return new SimpleDateFormat(“yyyy-MM-dd”);<br>}<br>};</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">说明：如果是JDK8的应用，可以使用Instant代替Date，LocalDateTime代替Calendar，</span><br><span class="line">DateTimeFormatter代替SimpleDateFormat，官方给出的解释：simple beautiful strong immutable</span><br><span class="line">thread-safe。</span><br></pre></td></tr></table></figure><ol start="6"><li>【强制】必须回收自定义的ThreadLocal变量，尤其在线程池场景下，线程经常会被复用，<br> 如果不清理自定义的 ThreadLocal变量，可能会影响后续业务逻辑和造成内存泄露等问题。<br> 尽量在代理中使用try-finally块进行回收。<br> 正例：<br>objectThreadLocal.set(userInfo);<br>try {<br>&#x2F;&#x2F; …<br>} finally {<br>objectThreadLocal.remove();<br>}</li><li>【强制】高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁；能<br> 锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁。<br>说明：尽可能使加锁的代码块工作量尽可能的小，避免在锁代码块中调用RPC方法。</li><li>【强制】对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造<br>成死锁。<br>说明：线程一需要对表A、B、C依次全部加锁后才可以进行更新操作，那么线程二的加锁顺序也必须是A、<br>B、C，否则可能出现死锁。</li><li>【强制】在使用阻塞等待获取锁的方式中，必须在try代码块之外，并且在加锁方法与try代<br> 码块之间没有任何可能抛出异常的方法调用，避免加锁成功后，在finally中无法解锁。<br> 说明一：如果在lock方法与try代码块之间的方法调用抛出异常，那么无法解锁，造成其它线程无法成功<br> 获取锁。<br> 说明二：如果lock方法在try代码块之内，可能由于其它方法抛出异常，导致在finally代码块中，unlock<br> 对未加锁的对象解锁，它会调用AQS的tryRelease方法（取决于具体实现类），抛出<br> IllegalMonitorStateException异常。<br> 说明三：在Lock对象的lock方法实现中可能抛出unchecked异常，产生的后果与说明二相同。<br> 正例：<br>Lock lock &#x3D; new XxxLock();<br>&#x2F;&#x2F; …<br>lock.lock();<br>try {<br>doSomething();<br>doOthers();<br>} finally {<br>lock.unlock();<br>}<br> 反例：<br> Lock lock &#x3D; new XxxLock();<br> &#x2F;&#x2F; …</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">// 如果此处抛出异常，则直接执行finally代码块</span><br><span class="line">doSomething();</span><br><span class="line">// 无论加锁是否成功，finally代码块都会执行</span><br><span class="line">lock.lock();</span><br><span class="line">doOthers();</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="10"><li><p>【强制】在使用尝试机制来获取锁的方式中，进入业务代码块之前，必须先判断当前线程是否<br>持有锁。锁的释放规则与锁的阻塞等待方式相同。<br>说明：Lock对象的unlock方法在执行时，它会调用AQS的tryRelease方法（取决于具体实现类），如果<br>当前线程不持有锁，则抛出IllegalMonitorStateException异常。<br>正例：<br>   Lock lock &#x3D; new XxxLock();<br>   &#x2F;&#x2F; …<br>   boolean isLocked &#x3D; lock.tryLock();<br>   if (isLocked) {<br>   try {<br>   doSomething();<br>   doOthers();<br>   } finally {<br>   lock.unlock();<br>   }<br>   }</p></li><li><p>【强制】并发修改同一记录时，避免更新丢失，需要加锁。要么在应用层加锁，要么在缓存加<br>锁，要么在数据库层使用乐观锁，使用version作为更新依据。<br>说明：如果每次访问冲突概率小于20%，推荐使用乐观锁，否则使用悲观锁。乐观锁的重试次数不得小于<br>3 次。</p></li><li><p>【强制】多线程并行处理定时任务时，Timer运行多个TimeTask时，只要其中之一没有捕获抛<br>出的异常，其它任务便会自动终止运行，使用ScheduledExecutorService则没有这个问题。</p></li><li><p>【推荐】资金相关的金融敏感信息，使用悲观锁策略。<br>说明：乐观锁在获得锁的同时已经完成了更新操作，校验逻辑容易出现漏洞，另外，乐观锁对冲突的解决策<br>略有较复杂的要求，处理不当容易造成系统压力或数据异常，所以资金相关的金融敏感信息不建议使用乐观<br>锁更新。<br>   正例：悲观锁遵循一锁二判三更新四释放的原则</p></li><li><p>【推荐】使用CountDownLatch进行异步转同步操作，每个线程退出前必须调用countDown方<br>法，线程执行代码注意catch异常，确保countDown方法被执行到，避免主线程无法执行至<br>await方法，直到超时才返回结果。<br>说明：注意，子线程抛出异常堆栈，不能在主线程try-catch到。</p></li><li><p>【推荐】避免Random实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一seed<br>导致的性能下降。<br>   说明：Random实例包括java.util.Random 的实例或者 Math.random()的方式。<br>   正例：在JDK7之后，可以直接使用API ThreadLocalRandom，而在 JDK7之前，需要编码保证每个线<br>   程持有一个单独的Random实例。</p></li><li><p>【推荐】通过双重检查锁（double-checked locking）（在并发场景下）实现延迟初始化的优化<br>问题隐患(可参考 The “Double-Checked Locking is Broken” Declaration)，推荐解决方案中较为<br>简单一种（适用于JDK 5 及以上版本），将目标属性声明为 volatile型（比如修改helper的属<br>性声明为<code>private volatile Helper helper = null;</code>）。<br>反例：<br>   public class LazyInitDemo {<br>   private Helper helper &#x3D; null;<br>   public Helper getHelper() {<br>   if (helper &#x3D;&#x3D; null) {<br>   synchronized (this) {<br>   if (helper &#x3D;&#x3D; null) { helper &#x3D; new Helper(); }<br>   }<br>   }<br>   return helper;<br>   }<br>   &#x2F;&#x2F; other methods and fields…<br>   }</p></li><li><p>【参考】volatile解决多线程内存不可见问题。对于一写多读，是可以解决变量同步问题，但<br>是如果多写，同样无法解决线程安全问题。<br>   说明：如果是count++操作，使用如下类实现：AtomicInteger count &#x3D; new AtomicInteger();<br>   count.addAndGet(1); 如果是JDK8，推荐使用LongAdder对象，比AtomicLong性能更好（减少乐观<br>   锁的重试次数）。</p></li><li><p>【参考】HashMap在容量不够进行resize时由于高并发可能出现死链，导致CPU飙升，在<br>开发过程中注意规避此风险。</p></li><li><p>【参考】ThreadLocal对象使用static修饰，ThreadLocal无法解决共享对象的更新问题。<br>说明：这个变量是针对一个线程内所有操作共享的，所以设置为静态变量，所有此类实例共享此静态变量，<br>也就是说在类第一次被使用时装载，只分配一块存储空间，所有此类的对象(只要是这个线程内定义的)都可<br>以操控这个变量。</p></li></ol><h3 id="八-控制语句"><a href="#八-控制语句" class="headerlink" title="(八) 控制语句"></a>(八) 控制语句</h3><ol><li>【强制】在一个switch块内，每个case要么通过continue&#x2F;break&#x2F;return等来终止，要么<br> 注释说明程序将继续执行到哪一个case为止；在一个switch块内，都必须包含一个default</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">语句并且放在最后，即使它什么代码也没有。</span><br><span class="line">说明：注意break是退出switch语句块，而return是退出方法体。</span><br></pre></td></tr></table></figure><ol start="2"><li>【强制】当switch括号内的变量类型为String并且此变量为外部参数时，必须先进行null<br> 判断。<br> 反例：如下的代码输出是什么？<br>public class SwitchString {<br>public static void main(String[] args) {<br>method(null);<br>}<br>public static void method(String param) {<br>switch (param) {<br>&#x2F;&#x2F; 肯定不是进入这里<br>case “sth”:<br>System.out.println(“it’s sth”);<br>break;<br>&#x2F;&#x2F; 也不是进入这里<br>case “null”:<br>System.out.println(“it’s null”);<br>break;<br>&#x2F;&#x2F; 也不是进入这里<br>default:<br>System.out.println(“default”);<br>}<br>}<br>}</li><li>【强制】在if&#x2F;else&#x2F;for&#x2F;while&#x2F;do语句中必须使用大括号。<br> 说明：即使只有一行代码，禁止不采用大括号的编码方式：if (condition) statements;</li><li>【强制】三目运算符condition? 表达式1 : 表达式 2 中，高度注意表达式 1 和 2 在类型对齐<br> 时，可能抛出因自动拆箱导致的NPE异常。<br> 说明：以下两种场景会触发类型对齐的拆箱操作：<br> 1 ） 表达式 1 或表达式 2 的值只要有一个是原始类型。<br> 2 ） 表达式 1 或表达式 2 的值的类型不一致，会强制拆箱升级成表示范围更大的那个类型。<br>反例：<br>   Integer a &#x3D; 1 ;<br>   Integer b &#x3D; 2 ;<br>   Integer c &#x3D; null;<br>   Boolean flag &#x3D; false;<br>   &#x2F;&#x2F; a<em>b的结果是int类型，那么c会强制拆箱成int类型，抛出NPE异常<br>   Integer result&#x3D;(flag? a</em>b : c);</li><li>【强制】在高并发场景中，避免使用”等于”判断作为中断或退出的条件。<br>说明：如果并发控制没有处理好，容易产生等值判断被“击穿”的情况，使用大于或小于的区间判断条件<br>来代替。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">反例：判断剩余奖品数量等于 0 时，终止发放奖品，但因为并发处理错误导致奖品数量瞬间变成了负数，</span><br><span class="line">这样的话，活动无法终止。</span><br></pre></td></tr></table></figure><ol start="6"><li><p>【推荐】当某个方法的代码行数超过 10 行时，return &#x2F; throw 等中断逻辑的右大括号后加一<br> 个空行。<br> 说明：这样做逻辑清晰，有利于代码阅读时重点关注。</p></li><li><p>【推荐】表达异常的分支时，少用if-else方式，这种方式可以改写成：<br>if (condition) {<br>…<br>return obj;<br>}<br>&#x2F;&#x2F; 接着写else的业务逻辑代码;<br>说明：如果非使用if()…else if()…else…方式表达逻辑，避免后续代码维护困难，请勿超过 3 层。<br>正例：超过 3 层的 if-else 的逻辑判断代码可以使用卫语句、策略模式、状态模式等来实现，其中卫语句<br>示例如下：<br>public void findBoyfriend (Man man){<br>if (man.isUgly()) {<br>System.out.println(“本姑娘是外貌协会的资深会员”);<br>return;<br>}<br>if (man.isPoor()) {<br>System.out.println(“贫贱夫妻百事哀”);<br>return;<br>}<br>if (man.isBadTemper()) {<br>System.out.println(“银河有多远，你就给我滚多远”);<br>return;<br>}<br>System.out.println(“可以先交往一段时间看看”);<br>}</p></li><li><p>【推荐】除常用方法（如getXxx&#x2F;isXxx）等外，不要在条件判断中执行其它复杂的语句，将复<br> 杂逻辑判断的结果赋值给一个有意义的布尔变量名，以提高可读性。<br> 说明：很多 if 语句内的逻辑表达式相当复杂，与、或、取反混合运算，甚至各种方法纵深调用，理解成本<br> 非常高。如果赋值一个非常好理解的布尔变量名字，则是件令人爽心悦目的事情。<br> 正例：<br>&#x2F;&#x2F; 伪代码如下<br>final boolean existed &#x3D; (file.open(fileName, “w”) !&#x3D; null) &amp;&amp; (…) || (…);<br>if (existed) {<br>…<br>}<br> 反例：<br> public final void acquire ( long arg){<br> if (!tryAcquire(arg) &amp;&amp;<br> acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) {<br> selfInterrupt();<br> }</p></li><li><p>【推荐】不要在其它表达式（尤其是条件表达式）中，插入赋值语句。<br> 说明：赋值点类似于人体的穴位，对于代码的理解至关重要，所以赋值语句需要清晰地单独成为一行。<br> 反例：<br>public Lock getLock(boolean fair) {<br>&#x2F;&#x2F; 算术表达式中出现赋值操作，容易忽略count值已经被改变<br>threshold &#x3D; (count &#x3D; Integer.MAX_VALUE) - 1 ;<br>&#x2F;&#x2F; 条件表达式中出现赋值操作，容易误认为是sync&#x3D;&#x3D;fair<br>return (sync &#x3D; fair)? new FairSync() : new NonfairSync();<br>}</p></li><li><p>【推荐】循环体中的语句要考量性能，以下操作尽量移至循环体外处理，如定义对象、变量、<br>获取数据库连接，进行不必要的try-catch操作（这个try-catch是否可以移至循环体外）。</p></li><li><p>【推荐】避免采用取反逻辑运算符。<br>说明：取反逻辑不利于快速理解，并且取反逻辑写法必然存在对应的正向逻辑写法。<br>正例：使用if (x &lt; 628) 来表达 x 小于 628 。<br>反例：使用if (!(x &gt;&#x3D; 628)) 来表达 x 小于 628 。</p></li><li><p>【推荐】接口入参保护，这种场景常见的是用作批量操作的接口。<br>反例：某业务系统，提供一个用户批量查询的接口，API文档上有说最多查多少个，但接口实现上没做任何<br>保护，导致调用方传了一个 1000 的用户id数组过来后，查询信息后，内存爆了。</p></li><li><p>【参考】下列情形，需要进行参数校验：<br>1 ） 调用频次低的方法。<br>2 ） 执行时间开销很大的方法。此情形中，参数校验时间几乎可以忽略不计，但如果因为参数错误导致<br>中间执行回退，或者错误，那得不偿失。<br>3 ） 需要极高稳定性和可用性的方法。<br>4 ） 对外提供的开放接口，不管是RPC&#x2F;API&#x2F;HTTP接口。<br>   5 ） 敏感权限入口。</p></li><li><p>【参考】下列情形，不需要进行参数校验：<br>1 ） 极有可能被循环调用的方法。但在方法说明里必须注明外部参数检查。<br>2 ） 底层调用频度比较高的方法。毕竟是像纯净水过滤的最后一道，参数错误不太可能到底层才会暴露<br>问题。一般DAO层与Service层都在同一个应用中，部署在同一台服务器中，所以DAO的参数校验，可<br>以省略。<br>3 ） 被声明成private只会被自己代码所调用的方法，如果能够确定调用方法的代码传入参数已经做过检<br>查或者肯定不会有问题，此时可以不校验参数。</p></li></ol><h3 id="九-注释规约"><a href="#九-注释规约" class="headerlink" title="(九) 注释规约"></a>(九) 注释规约</h3><ol><li>【强制】类、类属性、类方法的注释必须使用Javadoc规范，使用&#x2F;*<em>内容</em>&#x2F;格式，不得使用<br> &#x2F;&#x2F; xxx方式。<br> 说明：在IDE编辑窗口中，Javadoc方式会提示相关注释，生成Javadoc可以正确输出相应注释；在IDE<br> 中，工程调用方法时，不进入方法即可悬浮提示方法、参数、返回值的意义，提高阅读效率。</li><li>【强制】所有的抽象方法（包括接口中的方法）必须要用Javadoc注释、除了返回值、参数、<br> 异常说明外，还必须指出该方法做什么事情，实现什么功能。<br> 说明：对子类的实现要求，或者调用注意事项，请一并说明。</li><li>【强制】所有的类都必须添加创建者和创建日期。<br>说明：在设置模板时，注意IDEA的@author为<code>$&#123;USER&#125;</code>，而eclipse的@author为<code>$&#123;user&#125;</code>，大小写有<br>区别，而日期的设置统一为yyyy&#x2F;MM&#x2F;dd的格式。<br>正例：<br>&#x2F;**</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* @author yangguanbao</span><br><span class="line">* @date 2016/10/31</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><ol start="4"><li><p>【强制】方法内部单行注释，在被注释语句上方另起一行，使用&#x2F;&#x2F;注释。方法内部多行注释使<br> 用&#x2F;* *&#x2F;注释，注意与代码对齐。</p></li><li><p>【强制】所有的枚举类型字段必须要有注释，说明每个数据项的用途。</p></li><li><p>【推荐】与其“半吊子”英文来注释，不如用中文注释把问题说清楚。专有名词与关键字保持<br> 英文原文即可。<br> 反例：“TCP连接超时”解释成“传输控制协议连接超时”，理解反而费脑筋。</p></li><li><p>【推荐】代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑<br> 等的修改。<br> 说明：代码与注释更新不同步，就像路网与导航软件更新不同步一样，如果导航软件严重滞后，就失去了<br> 导航的意义。</p></li><li><p>【推荐】在类中删除未使用的任何字段和方法；在方法中删除未使用的任何参数声明与内部变<br> 量。</p></li><li><p>【参考】谨慎注释掉代码。在上方详细说明，而不是简单地注释掉。如果无用，则删除。<br> 说明：代码被注释掉有两种可能性： 1 ）后续会恢复此段代码逻辑。 2 ）永久不用。前者如果没有备注信息，<br> 难以知晓注释动机。后者建议直接删掉即可，假如需要查阅历史代码，登录代码仓库即可。</p></li><li><p>【参考】对于注释的要求：第一、能够准确反映设计思想和代码逻辑；第二、能够描述业务含<br>义，使别的程序员能够迅速了解到代码背后的信息。完全没有注释的大段代码对于阅读者形同<br>天书，注释是给自己看的，即使隔很长时间，也能清晰理解当时的思路；注释也是给继任者看<br>的，使其能够快速接替自己的工作。</p></li><li><p>【参考】好的命名、代码结构是自解释的，注释力求精简准确、表达到位。避免出现注释的一<br>个极端：过多过滥的注释，代码的逻辑一旦修改，修改注释是相当大的负担。<br>反例：<br>&#x2F;&#x2F; put elephant into fridge<br>put(elephant, fridge);<br>方法名put，加上两个有意义的变量名elephant和fridge，已经说明了这是在干什么，语义清晰的代码不<br>需要额外的注释。</p></li><li><p>【参考】特殊注释标记，请注明标记人与标记时间。注意及时处理这些标记，通过标记扫描，<br>经常清理此类标记。线上故障有时候就是来源于这些标记处的代码。<br>1 ） 待办事宜（TODO）:（标记人，标记时间，[预计处理时间]）<br>表示需要实现，但目前还未实现的功能。这实际上是一个Javadoc的标签，目前的Javadoc还没<br>有实现，但已经被广泛使用。只能应用于类，接口和方法（因为它是一个Javadoc标签）。<br>2 ） 错误，不能工作（FIXME）:（标记人，标记时间，[预计处理时间]）<br>在注释中用FIXME标记某代码是错误的，而且不能工作，需要及时纠正的情况。</p></li></ol><h3 id="十-其它"><a href="#十-其它" class="headerlink" title="(十) 其它"></a>(十) 其它</h3><ol><li><p>【强制】在使用正则表达式时，利用好其预编译功能，可以有效加快正则匹配速度。<br> 说明：不要在方法体内定义：Pattern pattern &#x3D; Pattern.compile(“规则”);</p></li><li><p>【强制】避免用Apache Beanutils进行属性的copy。<br> 说明：Apache BeanUtils性能较差，可以使用其他方案比如Spring BeanUtils, Cglib BeanCopier，注意<br> 均是浅拷贝。</p></li><li><p>【强制】velocity调用POJO类的属性时，直接使用属性名取值即可，模板引擎会自动按规范<br> 调用POJO的getXxx()，如果是boolean基本数据类型变量（boolean命名不需要加is前缀），<br> 会自动调用isXxx()方法。<br> 说明：注意如果是Boolean包装类对象，优先调用getXxx()的方法。</p></li><li><p>【强制】后台输送给页面的变量必须加$!{var}——中间的感叹号。<br> 说明：如果var等于null或者不存在，那么${var}会直接显示在页面上。</p></li><li><p>【强制】注意 Math.random() 这个方法返回是double类型，注意取值的范围 0≤x&lt;1（能够<br> 取到零值，注意除零异常），如果想获取整数类型的随机数，不要将x放大 10 的若干倍然后<br> 取整，直接使用Random对象的nextInt或者nextLong方法。</p></li><li><p>【推荐】不要在视图模板中加入任何复杂的逻辑。<br> 说明：根据MVC理论，视图的职责是展示，不要抢模型和控制器的活。</p></li><li><p>【推荐】任何数据结构的构造或初始化，都应指定大小，避免数据结构无限增长吃光内存。</p></li><li><p>【推荐】及时清理不再使用的代码段或配置信息。<br> 说明：对于垃圾代码或过时配置，坚决清理干净，避免程序过度臃肿，代码冗余。<br> 正例：对于暂时被注释掉，后续可能恢复使用的代码片断，在注释代码上方，统一规定使用三个斜杠(&#x2F;&#x2F;&#x2F;)<br> 来说明注释掉代码的理由。如：<br> public static void hello() {<br>&#x2F;&#x2F;&#x2F; 业务方通知活动暂停<br>&#x2F;&#x2F; Business business &#x3D; new Business();<br>&#x2F;&#x2F; business.active();<br>System.out.println(“it’s finished”);<br>}</p></li></ol><h2 id="二、异常日志"><a href="#二、异常日志" class="headerlink" title="二、异常日志"></a>二、异常日志</h2><h3 id="一-错误码"><a href="#一-错误码" class="headerlink" title="(一) 错误码"></a>(一) 错误码</h3><ol><li>【强制】错误码的制定原则：快速溯源、简单易记、沟通标准化。<br> 说明： 错误码想得过于完美和复杂，就像康熙字典中的生僻字一样，用词似乎精准，但是字典不容易随身<br> 携带并且简单易懂。<br> 正例：错误码回答的问题是谁的错？错在哪？ 1 ）错误码必须能够快速知晓错误来源，可快速判断是谁的问<br> 题。 2 ）错误码易于记忆和比对（代码中容易equals）。 3 ）错误码能够脱离文档和系统平台达到线下轻量<br> 化地自由沟通的目的。</li><li>【强制】错误码不体现版本号和错误等级信息。<br> 说明：错误码以不断追加的方式进行兼容。错误等级由日志和错误码本身的释义来决定。</li><li>【强制】全部正常，但不得不填充错误码时返回五个零： 00000 。</li><li>【强制】错误码为字符串类型，共 5 位，分成两个部分：错误产生来源+四位数字编号。<br> 说明：错误产生来源分为A&#x2F;B&#x2F;C，A表示错误来源于用户，比如参数错误，用户安装版本过低，用户支付<br> 超时等问题；B表示错误来源于当前系统，往往是业务逻辑出错，或程序健壮性差等问题；C表示错误来源<br> 于第三方服务，比如CDN服务出错，消息投递超时等问题；四位数字编号从 0001 到 9999 ，大类之间的<br> 步长间距预留 100 ，参考文末 <strong>附表 3</strong> 。</li><li>【强制】编号不与公司业务架构，更不与组织架构挂钩，一切与平台先到先申请的原则进行，<br> 审批生效，编号即被永久固定。</li><li>【强制】错误码使用者避免随意定义新的错误码。<br> 说明：尽可能在原有错误码附表中找到语义相同或者相近的错误码在代码中使用即可。</li><li>【强制】错误码不能直接输出给用户作为提示信息使用。<br> 说明：堆栈（stack_trace）、错误信息(error_message)、错误码（error_code）、提示信息（user_tip）<br> 是一个有效关联并互相转义的和谐整体，但是请勿互相越俎代庖。</li><li>【推荐】错误码之外的业务独特信息由error_message来承载，而不是让错误码本身涵盖过<br> 多具体业务属性。</li><li>【推荐】在获取第三方服务错误码时，向上抛出允许本系统转义，由C转为B，并且在错误信<br> 息上带上原有的第三方错误码。</li><li>【参考】错误码分为一级宏观错误码、二级宏观错误码、三级宏观错误码。<br>说明：在无法更加具体确定的错误场景中，可以直接使用一级宏观错误码，分别是：A0001（用户端错误）、</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">B0001（系统执行出错）、C0001（调用第三方服务出错）。</span><br><span class="line">正例：调用第三方服务出错是一级，中间件错误是二级，消息服务出错是三级。</span><br></pre></td></tr></table></figure><ol start="11"><li>【参考】错误码的后三位编号与HTTP状态码没有任何关系。</li><li>【参考】错误码尽量有利于不同文化背景的开发者进行交流与代码协作。<br>说明：英文单词形式的错误码不利于非英语母语国家（如阿拉伯语、希伯来语、俄罗斯语等）之间的开发<br>者互相协作。</li><li>【参考】错误码即人性，感性认知+口口相传，使用纯数字来进行错误码编排不利于感性记忆<br>和分类。<br>说明：数字是一个整体，每位数字的地位和含义是相同的。<br>反例：一个五位数字 12345 ，第 1 位是错误等级，第 2 位是错误来源， 345 是编号，人的大脑不会主动地<br>分辨每位数字的不同含义。</li></ol><h3 id="二-异常处理"><a href="#二-异常处理" class="headerlink" title="(二) 异常处理"></a>(二) 异常处理</h3><ol><li><p>【强制】Java 类库中定义的可以通过预检查方式规避的RuntimeException异常不应该通过<br> catch 的方式来处理，比如：NullPointerException，IndexOutOfBoundsException等等。<br> 说明：无法通过预检查的异常除外，比如，在解析字符串形式的数字时，可能存在数字格式错误，不得不<br> 通过catch NumberFormatException来实现。<br> 正例：if (obj !&#x3D; null) {…}<br> 反例：try { obj.method(); } catch (NullPointerException e) {…}</p></li><li><p>【强制】异常不要用来做流程控制，条件控制。<br> 说明：异常设计的初衷是解决程序运行中的各种意外情况，且异常的处理效率比条件判断方式要低很多。</p></li><li><p>【强制】catch时请分清稳定代码和非稳定代码，稳定代码指的是无论如何不会出错的代码。<br> 对于非稳定代码的catch尽可能进行区分异常类型，再做对应的异常处理。<br> 说明：对大段代码进行try-catch，使程序无法根据不同的异常做出正确的应激反应，也不利于定位问题，<br> 这是一种不负责任的表现。<br> 正例：用户注册的场景中，如果用户输入非法字符，或用户名称已存在，或用户输入密码过于简单，在程<br> 序上作出分门别类的判断，并提示给用户。</p></li><li><p>【强制】捕获异常是为了处理它，不要捕获了却什么都不处理而抛弃之，如果不想处理它，请<br> 将该异常抛给它的调用者。最外层的业务使用者，必须处理异常，将其转化为用户可以理解的<br> 内容。</p></li><li><p>【强制】事务场景中，抛出异常被catch后，如果需要回滚，一定要注意手动回滚事务。</p></li><li><p>【强制】finally块必须对资源对象、流对象进行关闭，有异常也要做try-catch。<br> 说明：如果JDK7及以上，可以使用try-with-resources方式。</p></li><li><p>【强制】不要在finally块中使用return。<br>说明：try块中的return语句执行成功后，并不马上返回，而是继续执行finally块中的语句，如果此处存<br>在return语句，则在此直接返回，无情丢弃掉try块中的返回点。<br>反例：<br>private int x &#x3D; 0 ;<br>public int checkReturn() {<br>try {<br>&#x2F;&#x2F; x等于 1 ，此处不返回<br>return ++x;<br>} finally {<br>&#x2F;&#x2F; 返回的结果是 2<br>return ++x;<br>}<br>}</p></li><li><p>【强制】捕获异常与抛异常，必须是完全匹配，或者捕获异常是抛异常的父类。<br> 说明：如果预期对方抛的是绣球，实际接到的是铅球，就会产生意外情况。</p></li><li><p>【强制】在调用RPC、二方包、或动态生成类的相关方法时，捕捉异常必须使用Throwable<br> 类来进行拦截。<br> 说明：通过反射机制来调用方法，如果找不到方法，抛出NoSuchMethodException。什么情况会抛出<br> NoSuchMethodError呢？二方包在类冲突时，仲裁机制可能导致引入非预期的版本使类的方法签名不匹配，<br> 或者在字节码修改框架（比如：ASM）动态创建或修改类时，修改了相应的方法签名。这些情况，即使代<br> 码编译期是正确的，但在代码运行期时，会抛出NoSuchMethodError。</p></li><li><p>【推荐】方法的返回值可以为null，不强制返回空集合，或者空对象等，必须添加注释充分说<br>明什么情况下会返回null值。<br>说明：本手册明确防止NPE是调用者的责任。即使被调用方法返回空集合或者空对象，对调用者来说，也<br>并非高枕无忧，必须考虑到远程调用失败、序列化失败、运行时异常等场景返回null的情况。</p></li><li><p>【推荐】防止NPE，是程序员的基本修养，注意NPE产生的场景：<br>1 ） 返回类型为基本数据类型，return包装数据类型的对象时，自动拆箱有可能产生NPE。<br>反例：public int f() { return Integer对象}， 如果为null，自动解箱抛NPE。<br>2 ） 数据库的查询结果可能为null。<br>3 ） 集合里的元素即使isNotEmpty，取出的数据元素也可能为null。<br>4 ） 远程调用返回对象时，一律要求进行空指针判断，防止NPE。<br>5 ） 对于Session中获取的数据，建议进行NPE检查，避免空指针。<br>6 ） 级联调用obj.getA().getB().getC()；一连串调用，易产生NPE。<br>正例：使用JDK8的Optional类来防止NPE问题。</p></li><li><p>【推荐】定义时区分unchecked &#x2F; checked 异常，避免直接抛出new RuntimeException()，<br>更不允许抛出Exception或者Throwable，应使用有业务含义的自定义异常。推荐业界已定<br>义过的自定义异常，如：DAOException &#x2F; ServiceException等。</p></li><li><p>【参考】对于公司外的http&#x2F;api开放接口必须使用“错误码”；而应用内部推荐异常抛出；<br>跨应用间RPC调用优先考虑使用Result方式，封装isSuccess()方法、“错误码”、“错误<br>简短信息”；而应用内部推荐异常抛出。<br>说明：关于RPC方法返回方式使用Result方式的理由：<br>1 ）使用抛异常返回方式，调用方如果没有捕获到就会产生运行时错误。<br>2 ）如果不加栈信息，只是new自定义异常，加入自己的理解的error message，对于调用端解决问题<br>的帮助不会太多。如果加了栈信息，在频繁调用出错的情况下，数据序列化和传输的性能损耗也是问题。</p></li><li><p>【参考】避免出现重复的代码（Don’t Repeat Yourself），即DRY原则。<br>说明：随意复制和粘贴代码，必然会导致代码的重复，在以后需要修改时，需要修改所有的副本，容易遗漏。<br>必要时抽取共性方法，或者抽象公共类，甚至是组件化。<br>正例：一个类中有多个public方法，都需要进行数行相同的参数校验操作，这个时候请抽取：<br>private boolean checkParam(DTO dto) {…}</p></li></ol><h3 id="三-日志规约"><a href="#三-日志规约" class="headerlink" title="(三) 日志规约"></a>(三) 日志规约</h3><ol><li>【强制】应用中不可直接使用日志系统（Log 4 j、Logback）中的API，而应依赖使用日志框架<br> （SLF4J、JCL–Jakarta Commons Logging）中的API，使用门面模式的日志框架，有利于维护和<br> 各个类的日志处理方式统一。<br> 说明：日志框架（SLF4J、JCL–Jakarta Commons Logging）的使用方式（推荐使用SLF4J）<br> 使用SLF4J：<br> import org.slf4j.Logger;<br> import org.slf4j.LoggerFactory;<br> private static final Logger logger &#x3D; LoggerFactory.getLogger(Test.class);<br> 使用JCL：<br> import org.apache.commons.logging.Log;<br> import org.apache.commons.logging.LogFactory;<br> private static final Log log &#x3D; LogFactory.getLog(Test.class);</li><li>【强制】所有日志文件至少保存 15 天，因为有些异常具备以“周”为频次发生的特点。对于<br>当天日志，以“应用名.log”来保存，保存在&#x2F;home&#x2F;admin&#x2F;应用名&#x2F;logs&#x2F;</font>目录下，<br>过往日志格式为: {logname}.log.{保存日期}，日期格式：yyyy-MM-dd<br>说明：以mppserver应用为例，日志保存在&#x2F;home&#x2F;admin&#x2F;mppserver&#x2F;logs&#x2F;mppserver.log，历史日志<br>名称为mppserver.log.2016- 08 - 01</li><li>【强制】应用中的扩展日志（如打点、临时监控、访问日志等）命名方式：<br> appName_logType_logName.log。logType:日志类型，如stats&#x2F;monitor&#x2F;access等；logName:日志描</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">述。这种命名的好处：通过文件名就可知道日志文件属于什么应用，什么类型，什么目的，也有利于归类查</span><br><span class="line">找。</span><br><span class="line">说明：推荐对日志进行分类，如将错误日志和业务日志分开存放，便于开发人员查看，也便于通过日志对系</span><br><span class="line">统进行及时监控。</span><br><span class="line">正例：mppserver应用中单独监控时区转换异常，如：mppserver_monitor_timeZoneConvert.log</span><br></pre></td></tr></table></figure><ol start="4"><li>【强制】在日志输出时，字符串变量之间的拼接使用占位符的方式。<br> 说明：因为String字符串的拼接会使用StringBuilder的append()方式，有一定的性能损耗。使用占位符仅<br> 是替换动作，可以有效提升性能。<br> 正例：logger.debug(“Processing trade with id: {} and symbol: {}”, id, symbol);</li><li>【强制】对于trace&#x2F;debug&#x2F;info级别的日志输出，必须进行日志级别的开关判断。<br> 说明：虽然在debug(参数)的方法体内第一行代码isDisabled(Level.DEBUG_INT)为真时（Slf4j的常见实现<br> Log4j和Logback），就直接return，但是参数可能会进行字符串拼接运算。此外，如果debug(getName())<br> 这种参数内有getName()方法调用，无谓浪费方法调用的开销。<br> 正例：<br>&#x2F;&#x2F; 如果判断为真，那么可以输出trace和debug级别的日志<br>if (logger.isDebugEnabled()) {<br>logger.debug(“Current ID is: {} and name is: {}”, id, getName());<br>}</li><li>【强制】避免重复打印日志，浪费磁盘空间，务必在log 4 j.xml中设置additivity&#x3D;false。<br> 正例：<logger name="com.taobao.dubbo.config" additivity="false"></li><li>【强制】生产环境禁止直接使用System.out 或System.err 输出日志或使用<br> e.printStackTrace()打印异常堆栈。<br> 说明：标准日志输出与标准错误输出文件每次Jboss重启时才滚动，如果大量输出送往这两个文件，容易<br> 造成文件大小超过操作系统大小限制。</li><li>【强制】异常信息应该包括两类信息：案发现场信息和异常堆栈信息。如果不处理，那么通过<br>关键字throws往上抛出。<br>正例：logger.error(各类参数或者对象toString() + “_” + e.getMessage(), e);</li><li>【强制】日志打印时禁止直接用JSON工具将对象转换成String。<br>说明：如果对象里某些get方法被重写，存在抛出异常的情况，则可能会因为打印日志而影响正常业务流<br>程的执行。<br>正例：打印日志时仅打印出业务相关属性值或者调用其对象的toString()方法。</li><li>【推荐】谨慎地记录日志。生产环境禁止输出debug日志；有选择地输出info日志；如果使用<br>warn来记录刚上线时的业务行为信息，一定要注意日志输出量的问题，避免把服务器磁盘撑<br>爆，并记得及时删除这些观察日志。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">说明：大量地输出无效日志，不利于系统性能提升，也不利于快速定位错误点。记录日志时请思考：这些</span><br><span class="line">日志真的有人看吗？看到这条日志你能做什么？能不能给问题排查带来好处？</span><br></pre></td></tr></table></figure><ol start="11"><li>【推荐】可以使用warn日志级别来记录用户输入参数错误的情况，避免用户投诉时，无所适<br>从。如非必要，请不要在此场景打出error级别，避免频繁报警。<br>说明：注意日志输出的级别，error级别只记录系统逻辑出错、异常或者重要的错误信息。</li><li>【推荐】尽量用英文来描述日志错误信息，如果日志中的错误信息用英文描述不清楚的话使用<br>中文描述即可，否则容易产生歧义。<br>说明：国际化团队或海外部署的服务器由于字符集问题，使用全英文来注释和描述日志错误信息。</li></ol><h2 id="三、单元测试"><a href="#三、单元测试" class="headerlink" title="三、单元测试"></a>三、单元测试</h2><ol><li><p>【强制】好的单元测试必须遵守AIR原则。<br> 说明：单元测试在线上运行时，感觉像空气（AIR）一样并不存在，但在测试质量的保障上，却是非常关键<br> 的。好的单元测试宏观上来说，具有自动化、独立性、可重复执行的特点。<br>⚫ A：Automatic（自动化）<br>⚫ I：Independent（独立性）<br> ⚫ R：Repeatable（可重复）</p></li><li><p>【强制】单元测试应该是全自动执行的，并且非交互式的。测试用例通常是被定期执行的，执<br> 行过程必须完全自动化才有意义。输出结果需要人工检查的测试不是一个好的单元测试。单元<br> 测试中不准使用System.out来进行人肉验证，必须使用assert来验证。</p></li><li><p>【强制】保持单元测试的独立性。为了保证单元测试稳定可靠且便于维护，单元测试用例之间<br> 决不能互相调用，也不能依赖执行的先后次序。<br> 反例：method2需要依赖method1的执行，将执行结果作为method2的输入。</p></li><li><p>【强制】单元测试是可以重复执行的，不能受到外界环境的影响。<br> 说明：单元测试通常会被放到持续集成中，每次有代码check in时单元测试都会被执行。如果单测对外部<br> 环境（网络、服务、中间件等）有依赖，容易导致持续集成机制的不可用。<br> 正例：为了不受外界环境影响，要求设计代码时就把SUT的依赖改成注入，在测试时用spring 这样的DI<br> 框架注入一个本地（内存）实现或者Mock实现。</p></li><li><p>【强制】对于单元测试，要保证测试粒度足够小，有助于精确定位问题。单测粒度至多是类级<br> 别，一般是方法级别。<br> 说明：只有测试粒度小才能在出错时尽快定位到出错位置。单测不负责检查跨类或者跨系统的交互逻辑，<br> 那是集成测试的领域。</p></li><li><p>【强制】核心业务、核心应用、核心模块的增量代码确保单元测试通过。<br> 说明：新增代码及时补充单元测试，如果新增代码影响了原有单元测试，请及时修正。</p></li><li><p>【强制】单元测试代码必须写在如下工程目录：src&#x2F;test&#x2F;java，不允许写在业务代码目录下。<br>说明：源码编译时会跳过此目录，而单元测试框架默认是扫描此目录。</p></li><li><p>【推荐】单元测试的基本目标：语句覆盖率达到70%；核心模块的语句覆盖率和分支覆盖率都<br> 要达到100%<br> 说明：在工程规约的应用分层中提到的DAO层，Manager层，可重用度高的Service，都应该进行单元测<br> 试。</p></li><li><p>【推荐】编写单元测试代码遵守BCDE原则，以保证被测试模块的交付质量。<br> ⚫ B：Border，边界值测试，包括循环边界、特殊取值、特殊时间点、数据顺序等。<br> ⚫ C：Correct，正确的输入，并得到预期的结果。<br> ⚫ D：Design，与设计文档相结合，来编写单元测试。<br> ⚫ E：Error，强制错误信息输入（如：非法数据、异常流程、业务允许外等），并得到预期的结果。</p></li><li><p>【推荐】对于数据库相关的查询，更新，删除等操作，不能假设数据库里的数据是存在的，或<br>者直接操作数据库把数据插入进去，请使用程序插入或者导入数据的方式来准备数据。<br>反例：删除某一行数据的单元测试，在数据库中，先直接手动增加一行作为删除目标，但是这一行新增数<br>据并不符合业务插入规则，导致测试结果异常。</p></li><li><p>【推荐】和数据库相关的单元测试，可以设定自动回滚机制，不给数据库造成脏数据。或者对<br>单元测试产生的数据有明确的前后缀标识。<br>正例：在阿里巴巴企业智能事业部的内部单元测试中，使用ENTERPRISE_INTELLIGENCE <em>UNIT_TEST</em><br>的前缀来标识单元测试相关代码。</p></li><li><p>【推荐】对于不可测的代码在适当的时机做必要的重构，使代码变得可测，避免为了达到测试<br>要求而书写不规范测试代码。</p></li><li><p>【推荐】在设计评审阶段，开发人员需要和测试人员一起确定单元测试范围，单元测试最好覆<br>盖所有测试用例（UC）。</p></li><li><p>【推荐】单元测试作为一种质量保障手段，在项目提测前完成单元测试，不建议项目发布后补<br>充单元测试用例。</p></li><li><p>【参考】为了更方便地进行单元测试，业务代码应避免以下情况：</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">⚫ 构造方法中做的事情过多。</span><br><span class="line">⚫ 存在过多的全局变量和静态方法。</span><br><span class="line">⚫ 存在过多的外部依赖。</span><br><span class="line">⚫ 存在过多的条件语句。</span><br></pre></td></tr></table></figure><p>说明：多层条件语句建议使用卫语句、策略模式、状态模式等方式重构。</p><ol start="16"><li>【参考】不要对单元测试存在如下误解：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">⚫ 那是测试同学干的事情。本文是开发手册，凡是本文内容都是与开发同学强相关的。</span><br><span class="line">⚫ 单元测试代码是多余的。系统的整体功能与各单元部件的测试正常与否是强相关的。</span><br><span class="line">⚫ 单元测试代码不需要维护。一年半载后，那么单元测试几乎处于废弃状态。</span><br><span class="line">⚫ 单元测试与线上故障没有辩证关系。好的单元测试能够最大限度地规避线上故障。</span><br></pre></td></tr></table></figure><h2 id="四、安全规约"><a href="#四、安全规约" class="headerlink" title="四、安全规约"></a>四、安全规约</h2><ol><li>【强制】隶属于用户个人的页面或者功能必须进行权限控制校验。<br> 说明：防止没有做水平权限校验就可随意访问、修改、删除别人的数据，比如查看他人的私信内容。</li><li>【强制】用户敏感数据禁止直接展示，必须对展示数据进行脱敏。<br> 说明：中国大陆个人手机号码显示为:1 37 **** 0969 ，隐藏中间 4 位，防止隐私泄露。</li><li>【强制】用户输入的SQL参数严格使用参数绑定或者METADATA字段值限定，防止SQL注入，<br> 禁止字符串拼接SQL访问数据库。<br> 反例：某系统签名大量被恶意修改，即是因为对于危险字符 # –没有进行转义，导致数据库更新时，where<br> 后边的信息被注释掉，对全库进行更新。</li><li>【强制】用户请求传入的任何参数必须做有效性验证。<br>说明：忽略参数校验可能导致：<br>⚫ page size过大导致内存溢出<br>⚫ 恶意order by导致数据库慢查询<br>⚫ 缓存击穿<br>⚫ SSRF<br>⚫ 任意重定向<br>⚫ SQL注入，Shell注入，反序列化注入<br>⚫ 正则输入源串拒绝服务ReDoS<br> Java代码用正则来验证客户端的输入，有些正则写法验证普通用户输入没有问题，但是如果攻击人员使用<br> 的是特殊构造的字符串来验证，有可能导致死循环的结果。</li><li>【强制】禁止向HTML页面输出未经安全过滤或未正确转义的用户数据。</li><li>【强制】表单、AJAX提交必须执行CSRF安全验证。<br> 说明：CSRF(Cross-site request forgery)跨站请求伪造是一类常见编程漏洞。对于存在CSRF漏洞的应用&#x2F;<br> 网站，攻击者可以事先构造好URL，只要受害者用户一访问，后台便在用户不知情的情况下对数据库中用<br> 户参数进行相应修改。</li><li>【强制】URL外部重定向传入的目标地址必须执行白名单过滤。</li><li>【强制】在使用平台资源，譬如短信、邮件、电话、下单、支付，必须实现正确的防重放的机<br> 制，如数量限制、疲劳度控制、验证码校验，避免被滥刷而导致资损。<br> 说明：如注册时发送验证码到手机，如果没有限制次数和频率，那么可以利用此功能骚扰到其它用户，并<br> 造成短信平台资源浪费。</li><li>【推荐】发贴、评论、发送即时消息等用户生成内容的场景必须实现防刷、文本内容违禁词过<br> 滤等风控策略。</li></ol><h2 id="五、MySQL数据库"><a href="#五、MySQL数据库" class="headerlink" title="五、MySQL数据库"></a>五、MySQL数据库</h2><h3 id="一-建表规约"><a href="#一-建表规约" class="headerlink" title="(一) 建表规约"></a>(一) 建表规约</h3><ol><li><p>【强制】表达是与否概念的字段，必须使用is_xxx的方式命名，数据类型是unsigned tinyint<br> （ 1 表示是， 0 表示否）。<br> 说明：任何字段如果为非负数，必须是unsigned。<br> 注意：POJO类中的任何布尔类型的变量，都不要加is前缀，所以，需要在<resultMap>设置从is_xxx到<br> Xxx的映射关系。数据库表示是与否的值，使用tinyint类型，坚持is_xxx的命名方式是为了明确其取值含<br> 义与取值范围。<br> 正例：表达逻辑删除的字段名is_deleted， 1 表示删除， 0 表示未删除。</p></li><li><p>【强制】表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间只<br> 出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。<br>说明：MySQL在Windows下不区分大小写，但在Linux下默认是区分大小写。因此，数据库名、表名、<br>字段名，都不允许出现任何大写字母，避免节外生枝。<br>正例：aliyun_admin，rdc_config，level3_name<br>反例：AliyunAdmin，rdcConfig，level_3_name</p></li><li><p>【强制】表名不使用复数名词。<br>说明：表名应该仅仅表示表里面的实体内容，不应该表示实体数量，对应于DO类名也是单数形式，符合<br>表达习惯。</p></li><li><p>【强制】禁用保留字，如desc、range、match、delayed等，请参考MySQL官方保留字。</p></li><li><p>【强制】主键索引名为pk_字段名；唯一索引名为uk_字段名；普通索引名则为idx_字段名。<br>说明：pk_ 即primary key；uk_ 即 unique key；idx_ 即index的简称。</p></li><li><p>【强制】小数类型为decimal，禁止使用float和double。<br>说明：在存储的时候，float 和 double 都存在精度损失的问题，很可能在比较值的时候，得到不正确的<br>结果。如果存储的数据范围超过 decimal 的范围，建议将数据拆成整数和小数并分开存储。</p></li><li><p>【强制】如果存储的字符串长度几乎相等，使用char定长字符串类型。</p></li><li><p>【强制】varchar是可变长字符串，不预先分配存储空间，长度不要超过 5000 ，如果存储长度<br>大于此值，定义字段类型为text，独立出来一张表，用主键来对应，避免影响其它字段索引效<br>率。</p></li><li><p>【强制】表必备三字段：id, gmt_create, gmt_modified。<br>说明：其中id必为主键，类型为bigint unsigned、单表时自增、步长为 1 。gmt_create, gmt_modified<br>的类型均为datetime类型，前者现在时表示主动式创建，后者过去分词表示被动式更新。</p></li><li><p>【推荐】表的命名最好是遵循“业务名称_表的作用”。<br>正例：alipay_task &#x2F; force_project &#x2F; trade_config</p></li><li><p>【推荐】库名与应用名称尽量一致。</p></li><li><p>【推荐】如果修改字段含义或对字段表示的状态追加时，需要及时更新字段注释。</p></li><li><p>【推荐】字段允许适当冗余，以提高查询性能，但必须考虑数据一致。冗余字段应遵循：<br>1 ） 不是频繁修改的字段。<br>2 ） 不是唯一索引的字段。<br>3 ） 不是varchar超长字段，更不能是text字段。<br>正例：各业务线经常冗余存储商品名称，避免查询时需要调用IC服务获取。</p></li><li><p>【推荐】单表行数超过 500 万行或者单表容量超过 2 GB，才推荐进行分库分表。<br>说明：如果预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表。</p></li><li><p>【参考】合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索<br>速度。<br>正例：无符号值可以避免误存负数，且扩大了表示范围。</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">对象 年龄区间 类型 字节 表示范围</span><br><span class="line">人 150 岁之内 tinyint unsigned 1 无符号值： 0 到 255</span><br><span class="line">龟 数百岁 smallint unsigned 2 无符号值： 0 到 65535</span><br><span class="line">恐龙化石 数千万年 int unsigned 4 无符号值： 0 到约 43 亿</span><br><span class="line">太阳 约 50 亿年 bigint unsigned 8 无符号值： 0 到约 10 的 19 次方</span><br></pre></td></tr></table></figure><h3 id="二-索引规约"><a href="#二-索引规约" class="headerlink" title="(二) 索引规约"></a>(二) 索引规约</h3><ol><li>【强制】业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引。<br> 说明：不要以为唯一索引影响了insert速度，这个速度损耗可以忽略，但提高查找速度是明显的；另外，<br> 即使在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必然有脏数据产生。</li><li>【强制】超过三个表禁止join。需要join的字段，数据类型保持绝对一致；多表关联查询时，<br> 保证被关联的字段需要有索引。<br> 说明：即使双表join也要注意表索引、SQL性能。</li><li>【强制】在varchar字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据<br> 实际文本区分度决定索引长度。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">说明：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会高达90%</span><br><span class="line">以上，可以使用count(distinct left(列名, 索引长度))/count(*)的区分度来确定。</span><br></pre></td></tr></table></figure><ol start="4"><li><p>【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。<br> 说明：索引文件具有B-Tree的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。</p></li><li><p>【推荐】如果有order by的场景，请注意利用索引的有序性。order by 最后的字段是组合索<br> 引的一部分，并且放在索引组合顺序的最后，避免出现file_sort的情况，影响查询性能。<br> 正例：where a&#x3D;? and b&#x3D;? order by c; 索引：a_b_c<br> 反例：索引如果存在范围查询，那么索引有序性无法利用，如：WHERE a&gt;10 ORDER BY b; 索引a_b无<br> 法排序。</p></li><li><p>【推荐】利用覆盖索引来进行查询操作，避免回表。<br> 说明：如果一本书需要知道第 11 章是什么标题，会翻开第 11 章对应的那一页吗？目录浏览一下就好，这<br> 个目录就是起到覆盖索引的作用。<br> 正例：能够建立索引的种类分为主键索引、唯一索引、普通索引三种，而覆盖索引只是一种查询的一种效<br> 果，用explain的结果，extra列会出现：using index。</p></li><li><p>【推荐】利用延迟关联或者子查询优化超多分页场景。<br> 说明：MySQL并不是跳过offset行，而是取offset+N行，然后返回放弃前offset行，返回N行，那当<br> offset特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行SQL<br> 改写。<br> 正例：先快速定位需要获取的id段，然后再关联：<br> SELECT a.* FROM 表1 a, (select id from 表1 where 条件 LIMIT 100000,20 ) b where a.id&#x3D;b.id</p></li><li><p>【推荐】SQL性能优化的目标：至少要达到 range 级别，要求是ref级别，如果可以是consts<br> 最好。<br> 说明：<br> 1 ） consts 单表中最多只有一个匹配行（主键或者唯一索引），在优化阶段即可读取到数据。<br> 2 ） ref 指的是使用普通的索引（normal index）。<br> 3 ） range 对索引进行范围检索。<br> 反例：explain表的结果，type&#x3D;index，索引物理文件全扫描，速度非常慢，这个index级别比较range<br> 还低，与全表扫描是小巫见大巫。</p></li><li><p>【推荐】建组合索引的时候，区分度最高的在最左边。<br> 正例：如果where a&#x3D;? and b&#x3D;?，a列的几乎接近于唯一值，那么只需要单建idx_a索引即可。<br> 说明：存在非等号和等号混合判断条件时，在建索引时，请把等号条件的列前置。如：where c&gt;? and d&#x3D;?<br> 那么即使c的区分度更高，也必须把d放在索引的最前列，即建立组合索引idx_d_c。</p></li><li><p>【推荐】防止因字段类型不同造成的隐式转换，导致索引失效。</p></li><li><p>【参考】创建索引时避免有如下极端误解：<br>1 ） 索引宁滥勿缺。认为一个查询就需要建一个索引。<br>2 ） 吝啬索引的创建。认为索引会消耗空间、严重拖慢记录的更新以及行的新增速度。<br>3 ） 抵制惟一索引。认为惟一索引一律需要在应用层通过“先查后插”方式解决。</p></li></ol><h3 id="三-SQL语句"><a href="#三-SQL语句" class="headerlink" title="(三) SQL语句"></a>(三) SQL语句</h3><ol><li><p>【强制】不要使用count(列名)或count(常量)来替代count(<em>)，count(</em>)是SQL92定义的标<br> 准统计行数的语法，跟数据库无关，跟NULL和非NULL无关。<br> 说明：count(*)会统计值为NULL的行，而count(列名)不会统计此列为NULL值的行。</p></li><li><p>【强制】count(distinct col) 计算该列除NULL之外的不重复行数，注意 count(distinct col1,<br> col2) 如果其中一列全为NULL，那么即使另一列有不同的值，也返回为 0 。</p></li><li><p>【强制】当某一列的值全是NULL时，count(col)的返回结果为 0 ，但sum(col)的返回结果为<br> NULL，因此使用sum()时需注意NPE问题。<br> 正例：可以使用如下方式来避免sum的NPE问题：SELECT IFNULL(SUM(column), 0) FROM table;</p></li><li><p>【强制】使用ISNULL()来判断是否为NULL值。<br> 说明：NULL与任何值的直接比较都为NULL。<br> 1 ） NULL&lt;&gt;NULL的返回结果是NULL，而不是false。<br> 2 ） NULL&#x3D;NULL的返回结果是NULL，而不是true。<br> 3 ） NULL&lt;&gt;1的返回结果是NULL，而不是true。<br> 反例：在SQL语句中，如果在null前换行，影响可读性。select * from table where column1 is null and<br> column3 is not null; 而<code>ISNULL(column)</code>是一个整体，简洁易懂。从性能数据上分析，<code>ISNULL(column)</code><br> 执行效率更快一些。</p></li><li><p>【强制】代码中写分页查询逻辑时，若count为 0 应直接返回，避免执行后面的分页语句。</p></li><li><p>【强制】不得使用外键与级联，一切外键概念必须在应用层解决。<br> 说明：（概念解释）学生表中的student_id是主键，那么成绩表中的student_id则为外键。如果更新学<br> 生表中的student_id，同时触发成绩表中的student_id更新，即为级联更新。外键与级联更新适用于单机<br> 低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库<br> 的插入速度。</p></li><li><p>【强制】禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。</p></li><li><p>【强制】数据订正（特别是删除或修改记录操作）时，要先select，避免出现误删除，确认无<br> 误才能执行更新语句。</p></li><li><p>【强制】对于数据库中表记录的查询和变更，只要涉及多个表，都需要在列名前加表的别名（或<br> 表名）进行限定。<br> 说明：对多表进行查询记录、更新记录、删除记录时，如果对操作列没有限定表的别名（或表名），并且<br> 操作列在多个表中存在时，就会抛异常。<br> 正例：select t1.name from table_first as t1 , table_second as t2 where t1.id&#x3D;t2.id;<br> 反例：在某业务中，由于多表关联查询语句没有加表的别名（或表名）的限制，正常运行两年后，最近在<br> 某个表中增加一个同名字段，在预发布环境做数据库变更后，线上查询语句出现出 1052 异常：Column<br> ‘name’ in field list is ambiguous。</p></li><li><p>【推荐】SQL语句中表的别名前加as，并且以t1、t2、t3、…的顺序依次命名。<br>说明： 1 ）别名可以是表的简称，或者是根据表出现的顺序，以t1、t2、t3的方式命名。 2 ）别名前加as<br>使别名更容易识别。<br>正例：select t1.name from table_first as t1, table_second as t2 where t1.id&#x3D;t2.id;</p></li><li><p>【推荐】in操作能避免则避免，若实在避免不了，需要仔细评估in后边的集合元素数量，控<br>制在 1000 个之内。</p></li><li><p>【参考】因国际化需要，所有的字符存储与表示，均采用utf 8 字符集，那么字符计数方法需<br>要注意。<br>说明：<br>SELECT LENGTH(“轻松工作”)； 返回为 12<br>SELECT CHARACTER_LENGTH(“轻松工作”)； 返回为 4<br>如果需要存储表情，那么选择utf 8 mb4来进行存储，注意它与utf 8 编码的区别。</p></li><li><p>【参考】TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少，但TRUNCATE<br>无事务且不触发trigger，有可能造成事故，故不建议在开发代码中使用此语句。<br>说明：TRUNCATE TABLE 在功能上与不带 WHERE 子句的 DELETE 语句相同。</p></li></ol><h3 id="四-ORM映射"><a href="#四-ORM映射" class="headerlink" title="(四) ORM映射"></a>(四) ORM映射</h3><ol><li><p>【强制】在表查询中，一律不要使用 * 作为查询的字段列表，需要哪些字段必须明确写明。<br> 说明： 1 ）增加查询分析器解析成本。 2 ）增减字段容易与resultMap配置不一致。 3 ）无用字段增加网络<br> 消耗，尤其是text类型的字段。</p></li><li><p>【强制】POJO类的布尔属性不能加is，而数据库字段必须加is_，要求在resultMap中进行<br> 字段与属性之间的映射。<br> 说明：参见定义POJO类以及数据库字段定义规定，在sql.xml增加映射，是必须的。</p></li><li><p>【强制】不要用resultClass当返回参数，即使所有类属性名与数据库字段一一对应，也需要<br> 定义<resultMap>；反过来，每一个表也必然有一个<resultMap>与之对应。<br> 说明：配置映射关系，使字段与DO类解耦，方便维护。</p></li><li><p>【强制】sql.xml配置参数使用：#{}，#param# 不要使用${} 此种方式容易出现SQL注入。</p></li><li><p>【强制】iBATIS自带的queryForList(String statementName,int start,int size)不推荐使用。<br>说明：其实现方式是在数据库取到statementName对应的SQL语句的所有记录，再通过subList取<br>start,size的子集合。<br>正例：<br>Map&lt;String, Object&gt; map &#x3D; new HashMap&lt;&gt;();<br>map.put(“start”, start);<br>map.put(“size”, size);</p></li><li><p>【强制】不允许直接拿HashMap与Hashtable作为查询结果集的输出。<br> 反例：某同学为避免写一个&lt;resultMap&gt;，直接使用HashTable来接收数据库返回结果，结果出现日常<br> 是把bigint转成Long值，而线上由于数据库版本不一样，解析成BigInteger，导致线上问题。</p></li><li><p>【强制】更新数据表记录时，必须同时更新记录对应的gmt_modified字段值为当前时间。</p></li><li><p>【推荐】不要写一个大而全的数据更新接口。传入为POJO类，不管是不是自己的目标更新字<br> 段，都进行update table set c1&#x3D;value1,c2&#x3D;value2,c3&#x3D;value3; 这是不对的。执行SQL时，<br> 不要更新无改动的字段，一是易出错；二是效率低；三是增加binlog存储。</p></li><li><p>【参考】@Transactional事务不要滥用。事务会影响数据库的QPS，另外使用事务的地方需<br> 要考虑各方面的回滚方案，包括缓存回滚、搜索引擎回滚、消息补偿、统计修正等。</p></li><li><p>【参考】<isEqual>中的compareValue是与属性值对比的常量，一般是数字，表示相等时<br>带上此条件；<isNotEmpty>表示不为空且不为null时执行；<isNotNull>表示不为null值<br>时执行。</p></li></ol><h2 id="六、工程结构"><a href="#六、工程结构" class="headerlink" title="六、工程结构"></a>六、工程结构</h2><h3 id="一-应用分层"><a href="#一-应用分层" class="headerlink" title="(一) 应用分层"></a>(一) 应用分层</h3><ol><li><p>【推荐】图中默认上层依赖于下层，箭头关系表示可直接依赖，如：开放接口层可以依赖于<br> Web层，也可以直接依赖于Service层，依此类推：<br>- 开放接口层：可直接封装Service方法暴露成RPC接口；通过Web封装成http接口；网关控制层等。<br>- 终端显示层：各个端的模板渲染并执行显示的层。当前主要是velocity渲染，JS渲染，JSP渲染，移<br>   动端展示等。<br>- Web层：主要是对访问控制进行转发，各类基本参数校验，或者不复用的业务简单处理等。<br>- Service层：相对具体的业务逻辑服务层。<br>- Manager层：通用业务处理层，它有如下特征：<br>   1 ） 对第三方平台封装的层，预处理返回结果及转化异常信息。<br>   2 ） 对Service层通用能力的下沉，如缓存方案、中间件通用处理。<br>   3 ） 与DAO层交互，对多个DAO的组合复用。<br>- DAO层：数据访问层，与底层MySQL、Oracle、Hbase、OB等进行数据交互。<br>- 外部接口或第三方平台：包括其它部门RPC开放接口，基础平台，其它公司的HTTP接口。</p></li><li><p>【参考】（分层异常处理规约）在DAO层，产生的异常类型有很多，无法用细粒度的异常进<br>行catch，使用catch(Exception e)方式，并throw new DAOException(e)，不需要打印日志，因<br>为日志在Manager&#x2F;Service层一定需要捕获并打印到日志文件中去，如果同台服务器再打日志，<br>浪费性能和存储。在Service层出现异常时，必须记录出错日志到磁盘，尽可能带上参数信息，<br>相当于保护案发现场。Manager层与Service同机部署，日志方式与DAO层处理一致，如果是<br>单独部署，则采用与Service一致的处理方式。Web层绝不应该继续往上抛异常，因为已经处<br>于顶层，如果意识到这个异常将导致页面无法正常渲染，那么就应该直接跳转到友好错误页面，<br>尽量加上友好的错误提示信息。开放接口层要将异常处理成错误码和错误信息方式返回。</p></li><li><p>【参考】分层领域模型规约：</p><ul><li>DO（Data Object）：此对象与数据库表结构一一对应，通过DAO层向上传输数据源对象。</li><li>DTO（Data Transfer Object）：数据传输对象，Service或Manager向外传输的对象。</li><li>BO（Business Object）：业务对象，可以由Service层输出的封装业务逻辑的对象。</li><li>Query：数据查询对象，各层接收上层的查询请求。注意超过 2 个参数的查询封装，禁止使用Map类<br> 来传输。</li><li>VO（View Object）：显示层对象，通常是Web向模板渲染引擎层传输的对象。</li></ul></li></ol><h3 id="二-二方库依赖"><a href="#二-二方库依赖" class="headerlink" title="(二) 二方库依赖"></a>(二) 二方库依赖</h3><ol><li><p>【强制】定义GAV遵从以下规则：<br> 1 ） GroupID格式：com.{公司&#x2F;BU }.业务线 [.子业务线]，最多 4 级。<br> 说明：{公司&#x2F;BU} 例如：alibaba&#x2F;taobao&#x2F;tmall&#x2F;aliexpress等BU一级；子业务线可选。<br> 正例：com.taobao.jstorm 或 com.alibaba.dubbo.register<br> 2 ） ArtifactID格式：产品线名-模块名。语义不重复不遗漏，先到中央仓库去查证一下。<br> 正例：dubbo-client &#x2F; fastjson-api &#x2F; jstorm-tool<br> 3 ） Version：详细规定参考下方。</p></li><li><p>【强制】二方库版本号命名方式：主版本号.次版本号.修订号<br>1 ）主版本号：产品方向改变，或者大规模API不兼容，或者架构不兼容升级。<br>2 ） 次版本号：保持相对兼容性，增加主要功能特性，影响范围极小的API不兼容修改。<br>3 ） 修订号：保持完全兼容性，修复BUG、新增次要功能特性等。<br>说明：注意起始版本号必须为：1.0.0，而不是0.0.1。<br>反例：仓库内某二方库版本号从1.0.0.0开始，一直默默“升级”成1.0.0.64，完全失去版本的语义信息。</p></li><li><p>【强制】线上应用不要依赖SNAPSHOT版本（安全包除外）；正式发布的类库必须先去中央仓<br> 库进行查证，使RELEASE版本号有延续性，且版本号不允许覆盖升级。<br> 说明：不依赖SNAPSHOT版本是保证应用发布的幂等性。另外，也可以加快编译时的打包构建。</p></li><li><p>【强制】二方库的新增或升级，保持除功能点之外的其它jar包仲裁结果不变。如果有改变，<br> 必须明确评估和验证。<br> 说明：在升级时，进行dependency:resolve前后信息比对，如果仲裁结果完全不一致，那么通过<br> dependency:tree命令，找出差异点，进行<exclude>排除jar包。</p></li><li><p>【强制】二方库里可以定义枚举类型，参数可以使用枚举类型，但是接口返回值不允许使用枚<br> 举类型或者包含枚举类型的POJO对象。</p></li><li><p>【强制】依赖于一个二方库群时，必须定义一个统一的版本变量，避免版本号不一致。<br> 说明：依赖springframework-core,-context,-beans，它们都是同一个版本，可以定义一个变量来保存版<br> 本：${spring.version}，定义依赖的时候，引用该版本。</p></li><li><p>【强制】禁止在子项目的pom依赖中出现相同的GroupId，相同的ArtifactId，但是不同的<br> Version。<br> 说明：在本地调试时会使用各子项目指定的版本号，但是合并成一个war，只能有一个版本号出现在最后的<br> lib目录中。曾经出现过线下调试是正确的，发布到线上却出故障的先例。</p></li><li><p>【推荐】底层基础技术框架、核心数据管理平台、或近硬件端系统谨慎引入第三方实现。</p></li><li><p>【推荐】所有pom文件中的依赖声明放在<dependencies>语句块中，所有版本仲裁放在<br> <dependencyManagement>语句块中。<br> 说明：<dependencyManagement>里只是声明版本，并不实现引入，因此子项目需要显式的声明依赖，<br> version和scope都读取自父pom。而<dependencies>所有声明在主pom的<dependencies>里的依<br> 赖都会自动引入，并默认被所有的子项目继承。</p></li><li><p>【推荐】二方库不要有配置项，最低限度不要再增加配置项。</p></li><li><p>【推荐】不要使用不稳定的工具包或者Utils类。<br>说明：不稳定指的是提供方无法做到向下兼容，在编译阶段正常，但在运行时产生异常，因此，尽量使用<br>业界稳定的二方工具包。</p></li><li><p>【参考】为避免应用二方库的依赖冲突问题，二方库发布者应当遵循以下原则：<br>1 ） <strong>精简可控原则</strong> 。移除一切不必要的API和依赖，只包含 Service API、必要的领域模型对象、Utils类、<br>常量、枚举等。如果依赖其它二方库，尽量是provided引入，让二方库使用者去依赖具体版本号；无log<br>具体实现，只依赖日志框架。<br>2 ） <strong>稳定可追溯原则</strong> 。每个版本的变化应该被记录，二方库由谁维护，源码在哪里，都需要能方便查到。除<br>非用户主动升级版本，否则公共二方库的行为不应该发生变化。</p></li></ol><h3 id="三-服务器"><a href="#三-服务器" class="headerlink" title="(三) 服务器"></a>(三) 服务器</h3><ol><li>【推荐】高并发服务器建议调小TCP协议的time_wait超时时间。<br> 说明：操作系统默认 240 秒后，才会关闭处于time_wait状态的连接，在高并发访问下，服务器端会因为<br> 处于time_wait的连接数太多，可能无法建立新的连接，所以需要在服务器上调小此等待值。<br> 正例：在linux服务器上请通过变更&#x2F;etc&#x2F;sysctl.conf文件去修改该缺省值（秒）：<br> net.ipv4.tcp_fin_timeout &#x3D; 30</li><li>【推荐】调大服务器所支持的最大文件句柄数（File Descriptor，简写为fd）。<br> 说明：主流操作系统的设计是将TCP&#x2F;UDP连接采用与文件一样的方式去管理，即一个连接对应于一个fd。<br> 主流的linux服务器默认所支持最大fd数量为 1024 ，当并发连接数很大时很容易因为fd不足而出现“open</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">too many files”错误，导致新的连接无法建立。建议将linux服务器所支持的最大句柄数调高数倍（与服</span><br><span class="line">务器的内存数量相关）。</span><br></pre></td></tr></table></figure><ol start="3"><li>【推荐】给JVM环境参数设置-XX:+HeapDumpOnOutOfMemoryError参数，让JVM碰到OOM<br> 场景时输出dump信息。<br> 说明：OOM的发生是有概率的，甚至相隔数月才出现一例，出错时的堆内信息对解决问题非常有帮助。</li><li>【推荐】在线上生产环境，JVM的Xms和Xmx设置一样大小的内存容量，避免在GC 后调整<br> 堆大小带来的压力。</li><li>【参考】服务器内部重定向必须使用forward；外部重定向地址必须使用URL Broker生成，否<br> 则因线上采用HTTPS协议而导致浏览器提示“不安全“。此外，还会带来URL维护不一致的<br> 问题。</li></ol><h2 id="七、设计规约"><a href="#七、设计规约" class="headerlink" title="七、设计规约"></a>七、设计规约</h2><ol><li>【强制】存储方案和底层数据结构的设计获得评审一致通过，并沉淀成为文档。<br> 说明：有缺陷的底层数据结构容易导致系统风险上升，可扩展性下降，重构成本也会因历史数据迁移和系<br> 统平滑过渡而陡然增加，所以，存储方案和数据结构需要认真地进行设计和评审，生产环境提交执行后，<br> 需要进行double check。<br> 正例：评审内容包括存储介质选型、表结构设计能否满足技术方案、存取性能和存储空间能否满足业务发<br> 展、表或字段之间的辩证关系、字段名称、字段类型、索引等；数据结构变更（如在原有表中新增字段）<br> 也需要进行评审通过后上线。</li><li>【强制】在需求分析阶段，如果与系统交互的User超过一类并且相关的User Case超过 5 个，<br> 使用用例图来表达更加清晰的结构化需求。</li><li>【强制】如果某个业务对象的状态超过 3 个，使用状态图来表达并且明确状态变化的各个触发<br> 条件。<br> 说明：状态图的核心是对象状态，首先明确对象有多少种状态，然后明确两两状态之间是否存在直接转换<br> 关系，再明确触发状态转换的条件是什么。<br> 正例：淘宝订单状态有已下单、待付款、已付款、待发货、已发货、已收货等。比如已下单与已收货这两<br> 种状态之间是不可能有直接转换关系的。</li><li>【强制】如果系统中某个功能的调用链路上的涉及对象超过 3 个，使用时序图来表达并且明确<br> 各调用环节的输入与输出。<br> 说明：时序图反映了一系列对象间的交互与协作关系，清晰立体地反映系统的调用纵深链路。</li><li>【强制】如果系统中模型类超过 5 个，并且存在复杂的依赖关系，使用类图来表达并且明确类<br> 之间的关系。<br> 说明：类图像建筑领域的施工图，如果搭平房，可能不需要，但如果建造蚂蚁Z空间大楼，肯定需要详细<br> 的施工图。</li><li>【强制】如果系统中超过 2 个对象之间存在协作关系，并且需要表示复杂的处理流程，使用活<br> 动图来表示。<br> 说明：活动图是流程图的扩展，增加了能够体现协作关系的对象泳道，支持表示并发等。</li><li>【推荐】系统架构设计时明确以下目标：<br>⚫ 确定系统边界。确定系统在技术层面上的做与不做。<br>⚫ 确定系统内模块之间的关系。确定模块之间的依赖关系及模块的宏观输入与输出。<br>⚫ 确定指导后续设计与演化的原则。使后续的子系统或模块设计在一个既定的框架内和技术方向上继<br>续演化。</li></ol><p>⚫ 确定非功能性需求。非功能性需求是指安全性、可用性、可扩展性等。</p><ol start="8"><li>【推荐】需求分析与系统设计在考虑主干功能的同时，需要充分评估异常流程与业务边界。<br> 反例：用户在淘宝付款过程中，银行扣款成功，发送给用户扣款成功短信，但是支付宝入款时由于断网演<br> 练产生异常，淘宝订单页面依然显示未付款，导致用户投诉。</li><li>【推荐】类在设计与实现时要符合单一原则。<br> 说明：单一原则最易理解却是最难实现的一条规则，随着系统演进，很多时候，忘记了类设计的初衷。</li><li>【推荐】谨慎使用继承的方式来进行扩展，优先使用聚合&#x2F;组合的方式来实现。<br>说明：不得已使用继承的话，必须符合里氏代换原则，此原则说父类能够出现的地方子类一定能够出现，<br>比如，“把钱交出来”，钱的子类美元、欧元、人民币等都可以出现。</li><li>【推荐】系统设计阶段，根据依赖倒置原则，尽量依赖抽象类与接口，有利于扩展与维护。<br>说明：低层次模块依赖于高层次模块的抽象，方便系统间的解耦。</li><li>【推荐】系统设计阶段，注意对扩展开放，对修改闭合。<br>说明：极端情况下，交付的代码是不可修改的，同一业务域内的需求变化，通过模块或类的扩展来实现。</li><li>【推荐】系统设计阶段，共性业务或公共行为抽取出来公共模块、公共配置、公共类、公共方<br>法等，在系统中不出现重复代码的情况。<br>说明：随着代码的重复次数不断增加，维护成本指数级上升。</li><li>【推荐】避免如下误解：敏捷开发 &#x3D; 讲故事 + 编码 + 发布。<br>说明：敏捷开发是快速交付迭代可用的系统，省略多余的设计方案，摒弃传统的审批流程，但核心关键点上<br>的必要设计和文档沉淀是需要的。<br>反例：某团队为了业务快速发展，敏捷成了产品经理催进度的借口，系统中均是勉强能运行但像面条一样<br>的代码，可维护性和可扩展性极差，一年之后，不得不进行大规模重构，得不偿失。</li><li>【参考】设计文档的作用是明确需求、理顺逻辑、后期维护，次要目的用于指导编码。<br>说明：避免为了设计而设计，系统设计文档有助于后期的系统维护和重构，所以设计结果需要进行分类归<br>档保存。</li><li>【参考】可扩展性的本质是找到系统的变化点，并隔离变化点。<br>说明：世间众多设计模式其实就是一种设计模式即隔离变化点的模式。<br>正例：极致扩展性的标志，就是需求的新增，不会在原有代码交付物上进行任何形式的修改。</li><li>【参考】设计的本质就是识别和表达系统难点。<br>说明：识别和表达完全是两回事，很多人错误地认为识别到系统难点在哪里，表达只是自然而然的事情，<br>但是大家在设计评审中经常出现语焉不详，甚至是词不达意的情况。准确地表达系统难点需要具备如下能</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">力： 表达规则和表达工具的熟练性。抽象思维和总结能力的局限性。基础知识体系的完备性。深入浅出的</span><br><span class="line">生动表达力。</span><br></pre></td></tr></table></figure><ol start="18"><li>【参考】代码即文档的观点是错误的，清晰的代码只是文档的某个片断，而不是全部。<br>说明：代码的深度调用，模块层面上的依赖关系网，业务场景逻辑，非功能性需求等问题是需要相应的文<br>档来完整地呈现的。</li><li>【参考】在做无障碍产品设计时，需要考虑到：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">⚫ 所有可交互的控件元素必须能被tab键聚焦，并且焦点顺序需符合自然操作逻辑。</span><br><span class="line">⚫ 用于登陆校验和请求拦截的验证码均需提供图形验证以外的其它方式。</span><br><span class="line">⚫ 自定义的控件类型需明确交互方式。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">正例：用户登陆场景中，输入框的按钮都需要考虑tab键聚焦，符合自然逻辑的操作顺序如下，“输入用</span><br><span class="line">户名，输入密码，输入验证码，点击登录”，其中验证码实现语音验证方式。如果有自定义标签实现的控</span><br><span class="line">件设置控件类型可使用role属性。</span><br></pre></td></tr></table></figure><h2 id="附-1-：版本历史"><a href="#附-1-：版本历史" class="headerlink" title="附 1 ：版本历史"></a>附 1 ：版本历史</h2><h4 id="版本号-版本名-发布日期-备注"><a href="#版本号-版本名-发布日期-备注" class="headerlink" title="版本号 版本名 发布日期 备注"></a>版本号 版本名 发布日期 备注</h4><h4 id="–-2-016-12-07-试读版本首次对外发布"><a href="#–-2-016-12-07-试读版本首次对外发布" class="headerlink" title="– - - 2 016.12.07 试读版本首次对外发布"></a>– - - 2 016.12.07 试读版本首次对外发布</h4><h4 id="1-0-0-正式版-2017-0-2-09-阿里巴巴集团正式对外发布"><a href="#1-0-0-正式版-2017-0-2-09-阿里巴巴集团正式对外发布" class="headerlink" title="1.0.0 正式版 2017. 0 2. 09 阿里巴巴集团正式对外发布"></a>1.0.0 正式版 2017. 0 2. 09 阿里巴巴集团正式对外发布</h4><h4 id="1-0-1-2017-0-2-13"><a href="#1-0-1-2017-0-2-13" class="headerlink" title="1.0.1 - - 2017. 0 2. 13"></a>1.0.1 - - 2017. 0 2. 13</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 ）修正String[]的前后矛盾。</span><br><span class="line">2 ）vm修正成velocity。</span><br><span class="line">3 ）修正countdown描述错误。</span><br></pre></td></tr></table></figure><h4 id="1-0-2-2017-0-2-20"><a href="#1-0-2-2017-0-2-20" class="headerlink" title="1.0.2 - - 2017. 0 2.20"></a>1.0.2 - - 2017. 0 2.20</h4><h4 id="1-）去除文底水印。"><a href="#1-）去除文底水印。" class="headerlink" title="1 ）去除文底水印。"></a>1 ）去除文底水印。</h4><h4 id="2-）数据类型中引用太阳系年龄问题。"><a href="#2-）数据类型中引用太阳系年龄问题。" class="headerlink" title="2 ）数据类型中引用太阳系年龄问题。"></a>2 ）数据类型中引用太阳系年龄问题。</h4><h4 id="3-）修正关于异常和方法签名的部分描述。"><a href="#3-）修正关于异常和方法签名的部分描述。" class="headerlink" title="3 ）修正关于异常和方法签名的部分描述。"></a>3 ）修正关于异常和方法签名的部分描述。</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4 ）修正final描述。</span><br><span class="line">5 ）去除Comparator部分描述。</span><br></pre></td></tr></table></figure><h4 id="1-1-0-2017-0-2-27"><a href="#1-1-0-2017-0-2-27" class="headerlink" title="1 .1.0 - - 2017. 0 2.27"></a>1 .1.0 - - 2017. 0 2.27</h4><h4 id="1-）增加前言。"><a href="#1-）增加前言。" class="headerlink" title="1 ）增加前言。"></a>1 ）增加前言。</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2 ）增加&lt;? extends T&gt;描述和说明。</span><br><span class="line">3 ）增加版本历史。</span><br><span class="line">4 ）增加专有名词解释。</span><br></pre></td></tr></table></figure><h4 id="1-1-1-2017-0-3-31-修正页码总数和部分示例。"><a href="#1-1-1-2017-0-3-31-修正页码总数和部分示例。" class="headerlink" title="1.1.1 - - 2017. 0 3.31 修正页码总数和部分示例。"></a>1.1.1 - - 2017. 0 3.31 修正页码总数和部分示例。</h4><h4 id="1-2-0-完美版-2017-0-5-20"><a href="#1-2-0-完美版-2017-0-5-20" class="headerlink" title="1.2.0 完美版 2017. 0 5.20"></a>1.2.0 完美版 2017. 0 5.20</h4><h4 id="1-）根据云栖社区的“聚能聊”活动反馈，对手册的页码、排版、描述进行修正。"><a href="#1-）根据云栖社区的“聚能聊”活动反馈，对手册的页码、排版、描述进行修正。" class="headerlink" title="1 ）根据云栖社区的“聚能聊”活动反馈，对手册的页码、排版、描述进行修正。"></a>1 ）根据云栖社区的“聚能聊”活动反馈，对手册的页码、排版、描述进行修正。</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2 ）增加final的适用场景描述。</span><br><span class="line">3 ）增加关于锁的粒度的说明。</span><br><span class="line">4 ）增加“指定集合大小”的详细说明以及正反例。</span><br><span class="line">5 ）增加卫语句的示例代码。</span><br><span class="line">6 ）明确数据库表示删除概念的字段名为is_deleted</span><br></pre></td></tr></table></figure><h4 id="1-3-0-终极版-2017-0-9-25-增加单元测试规约，阿里开源的IDE代码规约检测插件：点此下载"><a href="#1-3-0-终极版-2017-0-9-25-增加单元测试规约，阿里开源的IDE代码规约检测插件：点此下载" class="headerlink" title="1.3.0 终极版 2017. 0 9.25 增加单元测试规约，阿里开源的IDE代码规约检测插件：点此下载"></a>1.3.0 终极版 2017. 0 9.25 增加单元测试规约，阿里开源的IDE代码规约检测插件：点此下载</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.3.1 纪念版 2017.11.30 修正部分描述；采用和P3C开源IDE检测插件相同的Apache2.0协议。</span><br><span class="line">1.4.0 详尽版 2018. 0 5.20 增加设计规约大类，共 16 条。</span><br></pre></td></tr></table></figure><h4 id="版本号-版本名-发布日期-备注-1"><a href="#版本号-版本名-发布日期-备注-1" class="headerlink" title="版本号 版本名 发布日期 备注"></a>版本号 版本名 发布日期 备注</h4><h4 id="1-5-0-华山版-2-019-0-6-19"><a href="#1-5-0-华山版-2-019-0-6-19" class="headerlink" title="1 .5.0 华山版 2 019.0 6. 19"></a>1 .5.0 华山版 2 019.0 6. 19</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1 ）鉴于本手册是社区开发者集体智慧的结晶，本版本移除阿里巴巴Java开发手册的</span><br><span class="line">限定词“阿里巴巴”。</span><br><span class="line">2 ）新增 21 条新规约。比如，switch的NPE问题、浮点数的比较、无泛型限制、锁的</span><br><span class="line">使用方式、判断表达式、日期格式等。</span><br><span class="line">3 ）修改描述 112 处。比如，IFNULL的判断、集合的toArray、日志处理等。</span><br><span class="line">4 ）完善若干处示例。比如，命名示例、卫语句示例、enum示例、finally的return</span><br><span class="line">示例等。</span><br></pre></td></tr></table></figure><h4 id="1-6-0"><a href="#1-6-0" class="headerlink" title="1.6.0"></a>1.6.0</h4><h4 id="泰山版"><a href="#泰山版" class="headerlink" title="泰山版"></a>泰山版</h4><h4 id="2020-04-22"><a href="#2020-04-22" class="headerlink" title="2020.04.22"></a>2020.04.22</h4><h4 id="1-）发布错误码统一解决方案，详细参考-附表-3-。"><a href="#1-）发布错误码统一解决方案，详细参考-附表-3-。" class="headerlink" title="1 ）发布错误码统一解决方案，详细参考 附表 3 。"></a>1 ）发布错误码统一解决方案，详细参考 附表 3 。</h4><h4 id="2-）新增-34-条-新规约。比如，日期时间的闰年、闰月问题，三目运算的自动拆箱，SQL"><a href="#2-）新增-34-条-新规约。比如，日期时间的闰年、闰月问题，三目运算的自动拆箱，SQL" class="headerlink" title="2 ）新增 34 条 新规约。比如，日期时间的闰年、闰月问题，三目运算的自动拆箱，SQL"></a>2 ）新增 34 条 新规约。比如，日期时间的闰年、闰月问题，三目运算的自动拆箱，SQL</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">查询的表别名限定，Collectors类的toMap()方法使用注意等。</span><br><span class="line">3 ）修改描述 90 处。 比如，阻塞等待锁、建表的小数类型等。</span><br><span class="line">4 ）完善若干处示例。比如，ISNULL的示例等</span><br></pre></td></tr></table></figure><h2 id="附-2-：专有名词解释"><a href="#附-2-：专有名词解释" class="headerlink" title="附 2 ：专有名词解释"></a>附 2 ：专有名词解释</h2><ol><li>CAS（Compare And Swap）: 阿里巴巴专指数据库表一一对应的POJO类。解决多线程并行<br> 情况下使用锁造成性能损耗的一种机制，这是硬件实现的原子操作。CAS操作包含三个操作<br> 数：内存位置、预期原值和新值。如果内存位置的值与预期原值相匹配，那么处理器会自动将<br> 该位置值更新为新值。否则，处理器不做任何操作。</li><li>DO（Data Object）: 阿里巴巴专指数据库表一一对应的POJO类。</li><li>GAV（GroupId、ArtifactId、Version）: Maven坐标，是用来唯一标识jar包。</li><li>OOP（Object Oriented Programming）: 本文泛指类、对象的编程处理方式。</li><li>AQS（AbstractQueuedSynchronizer）: 利用先进先出队列实现的底层同步工具类，它是很多上<br> 层同步实现类的基础，比如：ReentrantLock、CountDownLatch、Semaphore等，它们通<br> 过继承AQS实现其模版方法，然后将AQS子类作为同步组件的内部类，通常命名为Sync。</li><li>ORM（Object Relation Mapping）: 对象关系映射，对象领域模型与底层数据之间的转换，本<br> 文泛指iBATIS, mybatis等框架。</li><li>POJO（Plain Ordinary Java Object）: 在本规约中，POJO专指只有setter&#x2F;getter&#x2F;toString的<br> 简单类，包括DO&#x2F;DTO&#x2F;BO&#x2F;VO等。</li><li>AO（Application Object）: 阿里巴巴专指Application Object，即在Service层上，极为贴近<br> 业务的复用代码。</li><li>NPE（java.lang.NullPointerException）: 空指针异常。</li><li>OOM（Out Of Memory）: 源于 java.lang.OutOfMemoryError，当 JVM 没有足够的内存<br>来为对象分配空间并且垃圾回收器也无法回收空间时，系统出现的严重状况。</li><li>一方库: 本工程内部子项目模块依赖的库（jar 包）。</li><li>二方库: 公司内部发布到中央仓库，可供公司内部其它应用依赖的库（jar 包）。</li><li>三方库: 公司之外的开源库（jar 包）。</li></ol><h2 id="附-3-：错误码列表"><a href="#附-3-：错误码列表" class="headerlink" title="附 3 ：错误码列表"></a>附 3 ：错误码列表</h2><h4 id="错误码-中文描述-说明"><a href="#错误码-中文描述-说明" class="headerlink" title="错误码 中文描述 说明"></a>错误码 中文描述 说明</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">00000 一切ok 正确执行后的返回</span><br><span class="line">A0001 用户端错误 一级宏观错误码</span><br><span class="line">A0100 用户注册错误 二级宏观错误码</span><br><span class="line">A0101 用户未同意隐私协议</span><br><span class="line">A0102 注册国家或地区受限</span><br><span class="line">A0110 用户名校验失败</span><br><span class="line">A0111 用户名已存在</span><br><span class="line">A0112 用户名包含敏感词</span><br><span class="line">A0113 用户名包含特殊字符</span><br><span class="line">A0120 密码校验失败</span><br><span class="line">A0121 密码长度不够</span><br><span class="line">A0122 密码强度不够</span><br><span class="line">A0130 校验码输入错误</span><br><span class="line">A0131 短信校验码输入错误</span><br><span class="line">A0132 邮件校验码输入错误</span><br><span class="line">A0133 语音校验码输入错误</span><br><span class="line">A0140 用户证件异常</span><br><span class="line">A0141 用户证件类型未选择</span><br><span class="line">A0142 大陆身份证编号校验非法</span><br><span class="line">A0143 护照编号校验非法</span><br><span class="line">A0144 军官证编号校验非法</span><br><span class="line">A0150 用户基本信息校验失败</span><br><span class="line">A0151 手机格式校验失败</span><br><span class="line">A0152 地址格式校验失败</span><br><span class="line">A0153 邮箱格式校验失败</span><br><span class="line">A0200 用户登陆异常 二级宏观错误码</span><br><span class="line">A0201 用户账户不存在</span><br></pre></td></tr></table></figure><h4 id="A0202-用户账户被冻结"><a href="#A0202-用户账户被冻结" class="headerlink" title="A0202 用户账户被冻结"></a>A0202 用户账户被冻结</h4><h4 id="A0203-用户账户已作废"><a href="#A0203-用户账户已作废" class="headerlink" title="A0203 用户账户已作废"></a>A0203 用户账户已作废</h4><h4 id="A0210-用户密码错误"><a href="#A0210-用户密码错误" class="headerlink" title="A0210 用户密码错误"></a>A0210 用户密码错误</h4><h4 id="A0211-用户输入密码次数超限"><a href="#A0211-用户输入密码次数超限" class="headerlink" title="A0211 用户输入密码次数超限"></a>A0211 用户输入密码次数超限</h4><h4 id="A0220-用户身份校验失败"><a href="#A0220-用户身份校验失败" class="headerlink" title="A0220 用户身份校验失败"></a>A0220 用户身份校验失败</h4><h4 id="A0221-用户指纹识别失败"><a href="#A0221-用户指纹识别失败" class="headerlink" title="A0221 用户指纹识别失败"></a>A0221 用户指纹识别失败</h4><h4 id="A0222-用户面容识别失败"><a href="#A0222-用户面容识别失败" class="headerlink" title="A0222 用户面容识别失败"></a>A0222 用户面容识别失败</h4><h4 id="A0223-用户未获得第三方登陆授权"><a href="#A0223-用户未获得第三方登陆授权" class="headerlink" title="A0223 用户未获得第三方登陆授权"></a>A0223 用户未获得第三方登陆授权</h4><h4 id="A0230-用户登陆已过期"><a href="#A0230-用户登陆已过期" class="headerlink" title="A0230 用户登陆已过期"></a>A0230 用户登陆已过期</h4><h4 id="A0240-用户验证码错误"><a href="#A0240-用户验证码错误" class="headerlink" title="A0240 用户验证码错误"></a>A0240 用户验证码错误</h4><h4 id="A0241-用户验证码尝试次数超限"><a href="#A0241-用户验证码尝试次数超限" class="headerlink" title="A0241 用户验证码尝试次数超限"></a>A0241 用户验证码尝试次数超限</h4><p>A0300 访问权限异常 二级宏观错误码</p><p>A0301 访问未授权</p><p>A0302 正在授权中</p><p>A0303 用户授权申请被拒绝</p><p>A0310 因访问对象隐私设置被拦截</p><p>A0311 授权已过期</p><p>A0312 无权限使用API</p><p>A0320 用户访问被拦截</p><p>A0321 黑名单用户</p><p>A0322 账号被冻结</p><p>A0323 非法IP地址</p><p>A0324 网关访问受限</p><p>A0325 地域黑名单</p><p>A0330 服务已欠费</p><p>A0340 用户签名异常</p><p>A0341 RSA签名错误</p><p>A0400 用户请求参数错误 二级宏观错误码</p><p>A0401 包含非法恶意跳转链接</p><p>A0402 无效的用户输入</p><h4 id="A0410-请求必填参数为空"><a href="#A0410-请求必填参数为空" class="headerlink" title="A0410 请求必填参数为空"></a>A0410 请求必填参数为空</h4><h4 id="A0411-用户订单号为空"><a href="#A0411-用户订单号为空" class="headerlink" title="A0411 用户订单号为空"></a>A0411 用户订单号为空</h4><h4 id="A0412-订购数量为空"><a href="#A0412-订购数量为空" class="headerlink" title="A0412 订购数量为空"></a>A0412 订购数量为空</h4><h4 id="A0413-缺少时间戳参数"><a href="#A0413-缺少时间戳参数" class="headerlink" title="A0413 缺少时间戳参数"></a>A0413 缺少时间戳参数</h4><h4 id="A0414-非法的时间戳参数"><a href="#A0414-非法的时间戳参数" class="headerlink" title="A0414 非法的时间戳参数"></a>A0414 非法的时间戳参数</h4><h4 id="A0420-请求参数值超出允许的范围"><a href="#A0420-请求参数值超出允许的范围" class="headerlink" title="A0420 请求参数值超出允许的范围"></a>A0420 请求参数值超出允许的范围</h4><h4 id="A0421-参数格式不匹配"><a href="#A0421-参数格式不匹配" class="headerlink" title="A0421 参数格式不匹配"></a>A0421 参数格式不匹配</h4><h4 id="A0422-地址不在服务范围"><a href="#A0422-地址不在服务范围" class="headerlink" title="A0422 地址不在服务范围"></a>A0422 地址不在服务范围</h4><h4 id="A0423-时间不在服务范围"><a href="#A0423-时间不在服务范围" class="headerlink" title="A0423 时间不在服务范围"></a>A0423 时间不在服务范围</h4><h4 id="A0424-金额超出限制"><a href="#A0424-金额超出限制" class="headerlink" title="A0424 金额超出限制"></a>A0424 金额超出限制</h4><h4 id="A0425-数量超出限制"><a href="#A0425-数量超出限制" class="headerlink" title="A0425 数量超出限制"></a>A0425 数量超出限制</h4><h4 id="A0426-请求批量处理总个数超出限制"><a href="#A0426-请求批量处理总个数超出限制" class="headerlink" title="A0426 请求批量处理总个数超出限制"></a>A0426 请求批量处理总个数超出限制</h4><h4 id="A0427-请求JSON解析失败"><a href="#A0427-请求JSON解析失败" class="headerlink" title="A0427 请求JSON解析失败"></a>A0427 请求JSON解析失败</h4><h4 id="A0430-用户输入内容非法"><a href="#A0430-用户输入内容非法" class="headerlink" title="A0430 用户输入内容非法"></a>A0430 用户输入内容非法</h4><h4 id="A0431-包含违禁敏感词"><a href="#A0431-包含违禁敏感词" class="headerlink" title="A0431 包含违禁敏感词"></a>A0431 包含违禁敏感词</h4><h4 id="A0432-图片包含违禁信息"><a href="#A0432-图片包含违禁信息" class="headerlink" title="A0432 图片包含违禁信息"></a>A0432 图片包含违禁信息</h4><h4 id="A0433-文件侵犯版权"><a href="#A0433-文件侵犯版权" class="headerlink" title="A0433 文件侵犯版权"></a>A0433 文件侵犯版权</h4><h4 id="A0440-用户操作异常"><a href="#A0440-用户操作异常" class="headerlink" title="A0440 用户操作异常"></a>A0440 用户操作异常</h4><h4 id="A0441-用户支付超时"><a href="#A0441-用户支付超时" class="headerlink" title="A0441 用户支付超时"></a>A0441 用户支付超时</h4><h4 id="A0442-确认订单超时"><a href="#A0442-确认订单超时" class="headerlink" title="A0442 确认订单超时"></a>A0442 确认订单超时</h4><h4 id="A0443-订单已关闭"><a href="#A0443-订单已关闭" class="headerlink" title="A0443 订单已关闭"></a>A0443 订单已关闭</h4><p>A0500 用户请求服务异常 二级宏观错误码</p><p>A0501 请求次数超出限制</p><p>A0502 请求并发数超出限制</p><p>A0503 用户操作请等待</p><p>A0504 WebSocket连接异常</p><p>A0505 WebSocket连接断开</p><p>A0506 用户重复请求</p><p>A0600 用户资源异常 二级宏观错误码</p><p>A0601 账户余额不足</p><h4 id="A0602-用户磁盘空间不足"><a href="#A0602-用户磁盘空间不足" class="headerlink" title="A0602 用户磁盘空间不足"></a>A0602 用户磁盘空间不足</h4><h4 id="A0603-用户内存空间不足"><a href="#A0603-用户内存空间不足" class="headerlink" title="A0603 用户内存空间不足"></a>A0603 用户内存空间不足</h4><h4 id="A0604-用户OSS容量不足"><a href="#A0604-用户OSS容量不足" class="headerlink" title="A0604 用户OSS容量不足"></a>A0604 用户OSS容量不足</h4><h4 id="A0605-用户配额已用光-蚂蚁森林浇水数或每天抽奖数"><a href="#A0605-用户配额已用光-蚂蚁森林浇水数或每天抽奖数" class="headerlink" title="A0605 用户配额已用光 蚂蚁森林浇水数或每天抽奖数"></a>A0605 用户配额已用光 蚂蚁森林浇水数或每天抽奖数</h4><h4 id="A0700-用户上传文件异常-二级宏观错误码"><a href="#A0700-用户上传文件异常-二级宏观错误码" class="headerlink" title="A0700 用户上传文件异常 二级宏观错误码"></a>A0700 用户上传文件异常 二级宏观错误码</h4><h4 id="A0701-用户上传文件类型不匹配"><a href="#A0701-用户上传文件类型不匹配" class="headerlink" title="A0701 用户上传文件类型不匹配"></a>A0701 用户上传文件类型不匹配</h4><h4 id="A0702-用户上传文件太大"><a href="#A0702-用户上传文件太大" class="headerlink" title="A0702 用户上传文件太大"></a>A0702 用户上传文件太大</h4><h4 id="A0703-用户上传图片太大"><a href="#A0703-用户上传图片太大" class="headerlink" title="A0703 用户上传图片太大"></a>A0703 用户上传图片太大</h4><h4 id="A0704-用户上传视频太大"><a href="#A0704-用户上传视频太大" class="headerlink" title="A0704 用户上传视频太大"></a>A0704 用户上传视频太大</h4><h4 id="A0705-用户上传压缩文件太大"><a href="#A0705-用户上传压缩文件太大" class="headerlink" title="A0705 用户上传压缩文件太大"></a>A0705 用户上传压缩文件太大</h4><h4 id="A0800-用户当前版本异常-二级宏观错误码"><a href="#A0800-用户当前版本异常-二级宏观错误码" class="headerlink" title="A0800 用户当前版本异常 二级宏观错误码"></a>A0800 用户当前版本异常 二级宏观错误码</h4><h4 id="A0801-用户安装版本与系统不匹配"><a href="#A0801-用户安装版本与系统不匹配" class="headerlink" title="A0801 用户安装版本与系统不匹配"></a>A0801 用户安装版本与系统不匹配</h4><h4 id="A0802-用户安装版本过低"><a href="#A0802-用户安装版本过低" class="headerlink" title="A0802 用户安装版本过低"></a>A0802 用户安装版本过低</h4><h4 id="A0803-用户安装版本过高"><a href="#A0803-用户安装版本过高" class="headerlink" title="A0803 用户安装版本过高"></a>A0803 用户安装版本过高</h4><h4 id="A0804-用户安装版本已过期"><a href="#A0804-用户安装版本已过期" class="headerlink" title="A0804 用户安装版本已过期"></a>A0804 用户安装版本已过期</h4><h4 id="A0805-用户API请求版本不匹配"><a href="#A0805-用户API请求版本不匹配" class="headerlink" title="A0805 用户API请求版本不匹配"></a>A0805 用户API请求版本不匹配</h4><h4 id="A0806-用户API请求版本过高"><a href="#A0806-用户API请求版本过高" class="headerlink" title="A0806 用户API请求版本过高"></a>A0806 用户API请求版本过高</h4><h4 id="A0807-用户API请求版本过低"><a href="#A0807-用户API请求版本过低" class="headerlink" title="A0807 用户API请求版本过低"></a>A0807 用户API请求版本过低</h4><h4 id="A0900-用户隐私未授权-二级宏观错误码"><a href="#A0900-用户隐私未授权-二级宏观错误码" class="headerlink" title="A0900 用户隐私未授权 二级宏观错误码"></a>A0900 用户隐私未授权 二级宏观错误码</h4><h4 id="A0901-用户隐私未签署"><a href="#A0901-用户隐私未签署" class="headerlink" title="A0901 用户隐私未签署"></a>A0901 用户隐私未签署</h4><h4 id="A0902-用户摄像头未授权"><a href="#A0902-用户摄像头未授权" class="headerlink" title="A0902 用户摄像头未授权"></a>A0902 用户摄像头未授权</h4><h4 id="A0903-用户相机未授权"><a href="#A0903-用户相机未授权" class="headerlink" title="A0903 用户相机未授权"></a>A0903 用户相机未授权</h4><h4 id="A0904-用户图片库未授权"><a href="#A0904-用户图片库未授权" class="headerlink" title="A0904 用户图片库未授权"></a>A0904 用户图片库未授权</h4><h4 id="A0905-用户文件未授权"><a href="#A0905-用户文件未授权" class="headerlink" title="A0905 用户文件未授权"></a>A0905 用户文件未授权</h4><h4 id="A0906-用户位置信息未授权"><a href="#A0906-用户位置信息未授权" class="headerlink" title="A0906 用户位置信息未授权"></a>A0906 用户位置信息未授权</h4><h4 id="A0907-用户通讯录未授权"><a href="#A0907-用户通讯录未授权" class="headerlink" title="A0907 用户通讯录未授权"></a>A0907 用户通讯录未授权</h4><h4 id="A1000-用户设备异常-二级宏观错误码"><a href="#A1000-用户设备异常-二级宏观错误码" class="headerlink" title="A1000 用户设备异常 二级宏观错误码"></a>A1000 用户设备异常 二级宏观错误码</h4><h4 id="A1001-用户相机异常"><a href="#A1001-用户相机异常" class="headerlink" title="A1001 用户相机异常"></a>A1001 用户相机异常</h4><h4 id="A1002-用户麦克风异常"><a href="#A1002-用户麦克风异常" class="headerlink" title="A1002 用户麦克风异常"></a>A1002 用户麦克风异常</h4><h4 id="A1003-用户听筒异常"><a href="#A1003-用户听筒异常" class="headerlink" title="A1003 用户听筒异常"></a>A1003 用户听筒异常</h4><h4 id="A1004-用户扬声器异常"><a href="#A1004-用户扬声器异常" class="headerlink" title="A1004 用户扬声器异常"></a>A1004 用户扬声器异常</h4><h4 id="A1005-用户GPS定位异常"><a href="#A1005-用户GPS定位异常" class="headerlink" title="A1005 用户GPS定位异常"></a>A1005 用户GPS定位异常</h4><h4 id=""><a href="#" class="headerlink" title="-"></a>-</h4><ul><li></li></ul><h4 id="B0001-系统执行出错-一级宏观错误码"><a href="#B0001-系统执行出错-一级宏观错误码" class="headerlink" title="B0001 系统执行出错 一级宏观错误码"></a>B0001 系统执行出错 一级宏观错误码</h4><h4 id="B0100-系统执行超时-二级宏观错误码"><a href="#B0100-系统执行超时-二级宏观错误码" class="headerlink" title="B0100 系统执行超时 二级宏观错误码"></a>B0100 系统执行超时 二级宏观错误码</h4><h4 id="B0101-系统订单处理超时"><a href="#B0101-系统订单处理超时" class="headerlink" title="B0101 系统订单处理超时"></a>B0101 系统订单处理超时</h4><h4 id="B0200-系统容灾功能被触发-二级宏观错误码"><a href="#B0200-系统容灾功能被触发-二级宏观错误码" class="headerlink" title="B0200 系统容灾功能被触发 二级宏观错误码"></a>B0200 系统容灾功能被触发 二级宏观错误码</h4><h4 id="B0210-系统限流"><a href="#B0210-系统限流" class="headerlink" title="B0210 系统限流"></a>B0210 系统限流</h4><h4 id="B0220-系统功能降级"><a href="#B0220-系统功能降级" class="headerlink" title="B0220 系统功能降级"></a>B0220 系统功能降级</h4><h4 id="B0300-系统资源异常-二级宏观错误码"><a href="#B0300-系统资源异常-二级宏观错误码" class="headerlink" title="B0300 系统资源异常 二级宏观错误码"></a>B0300 系统资源异常 二级宏观错误码</h4><h4 id="B0310-系统资源耗尽"><a href="#B0310-系统资源耗尽" class="headerlink" title="B0310 系统资源耗尽"></a>B0310 系统资源耗尽</h4><h4 id="B0311-系统磁盘空间耗尽"><a href="#B0311-系统磁盘空间耗尽" class="headerlink" title="B0311 系统磁盘空间耗尽"></a>B0311 系统磁盘空间耗尽</h4><h4 id="B0312-系统内存耗尽"><a href="#B0312-系统内存耗尽" class="headerlink" title="B0312 系统内存耗尽"></a>B0312 系统内存耗尽</h4><h4 id="B0313-文件句柄耗尽"><a href="#B0313-文件句柄耗尽" class="headerlink" title="B0313 文件句柄耗尽"></a>B0313 文件句柄耗尽</h4><h4 id="B0314-系统连接池耗尽"><a href="#B0314-系统连接池耗尽" class="headerlink" title="B0314 系统连接池耗尽"></a>B0314 系统连接池耗尽</h4><h4 id="B0315-系统线程池耗尽"><a href="#B0315-系统线程池耗尽" class="headerlink" title="B0315 系统线程池耗尽"></a>B0315 系统线程池耗尽</h4><h4 id="B0320-系统资源访问异常"><a href="#B0320-系统资源访问异常" class="headerlink" title="B0320 系统资源访问异常"></a>B0320 系统资源访问异常</h4><h4 id="B0321-系统读取磁盘文件失败"><a href="#B0321-系统读取磁盘文件失败" class="headerlink" title="B0321 系统读取磁盘文件失败"></a>B0321 系统读取磁盘文件失败</h4><h4 id="-1"><a href="#-1" class="headerlink" title="-"></a>-</h4><h4 id="-2"><a href="#-2" class="headerlink" title="-"></a>-</h4><h4 id="C0001-调用第三方服务出错-一级宏观错误码"><a href="#C0001-调用第三方服务出错-一级宏观错误码" class="headerlink" title="C0001 调用第三方服务出错 一级宏观错误码"></a>C0001 调用第三方服务出错 一级宏观错误码</h4><h4 id="C0100-中间件服务出错-二级宏观错误码"><a href="#C0100-中间件服务出错-二级宏观错误码" class="headerlink" title="C0100 中间件服务出错 二级宏观错误码"></a>C0100 中间件服务出错 二级宏观错误码</h4><h4 id="C0110-RPC服务出错"><a href="#C0110-RPC服务出错" class="headerlink" title="C0110 RPC服务出错"></a>C0110 RPC服务出错</h4><h4 id="C0111-RPC服务未找到"><a href="#C0111-RPC服务未找到" class="headerlink" title="C0111 RPC服务未找到"></a>C0111 RPC服务未找到</h4><h4 id="C0112-RPC服务未注册"><a href="#C0112-RPC服务未注册" class="headerlink" title="C0112 RPC服务未注册"></a>C0112 RPC服务未注册</h4><h4 id="C0113-接口不存在"><a href="#C0113-接口不存在" class="headerlink" title="C0113 接口不存在"></a>C0113 接口不存在</h4><h4 id="C0120-消息服务出错"><a href="#C0120-消息服务出错" class="headerlink" title="C0120 消息服务出错"></a>C0120 消息服务出错</h4><h4 id="C0121-消息投递出错"><a href="#C0121-消息投递出错" class="headerlink" title="C0121 消息投递出错"></a>C0121 消息投递出错</h4><h4 id="C0122-消息消费出错"><a href="#C0122-消息消费出错" class="headerlink" title="C0122 消息消费出错"></a>C0122 消息消费出错</h4><h4 id="C0123-消息订阅出错"><a href="#C0123-消息订阅出错" class="headerlink" title="C0123 消息订阅出错"></a>C0123 消息订阅出错</h4><h4 id="C0124-消息分组未查到"><a href="#C0124-消息分组未查到" class="headerlink" title="C0124 消息分组未查到"></a>C0124 消息分组未查到</h4><h4 id="C0130-缓存服务出错"><a href="#C0130-缓存服务出错" class="headerlink" title="C0130 缓存服务出错"></a>C0130 缓存服务出错</h4><p>C0131 key长度超过限制</p><p>C0132 value长度超过限制</p><p>C0133 存储容量已满</p><p>C0134 不支持的数据格式</p><p>C0140 配置服务出错</p><p>C0150 网络资源服务出错</p><p>C0151 VPN服务出错</p><p>C0152 CDN服务出错</p><p>C0153 域名解析服务出错</p><p>C0154 网关服务出错</p><p>C0200 第三方系统执行超时 二级宏观错误码</p><p>C0210 RPC执行超时</p><p>C0220 消息投递超时</p><p>C0230 缓存服务超时</p><p>C0240 配置服务超时</p><p>C0250 数据库服务超时</p><p>C0300 数据库服务出错 二级宏观错误码</p><p>C0311 表不存在</p><p>C0312 列不存在</p><p>C0321 多表关联中存在多个相同名称的列</p><p>C0331 数据库死锁</p><p>C0341 主键冲突</p><p>C0400 第三方容灾系统被触发 二级宏观错误码</p><p>C0401 第三方系统限流</p><p>C0402 第三方功能降级</p><p>C0500 通知服务出错 二级宏观错误码</p><p>C0501 短信提醒服务失败</p><p>C0502 语音提醒服务失败</p><p>C0503 邮件提醒服务失败</p><p><img src="https://cdn.zenless.top/gh/zhonghanlu/PicGo/img/image-20220822180836905.png" alt="image-20220822180836905"></p>]]></content>
      
      
      <categories>
          
          <category> 编码规范 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VPN</title>
      <link href="/archives/bcafbad3.html"/>
      <url>/archives/bcafbad3.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="VPN"><a href="#VPN" class="headerlink" title="VPN"></a>VPN</h1><h3 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h3><p>​这两天在搞blog的时候，不是基于github托管的进行部署的吗，就会牵扯到很多国外的网站，我就直接掏出我得setvpn免费的。甭提了贼鸡儿卡，于是我就选了选付费的vpn，我一想到我有个朋友那有个Clash，就拉过来用了下，感觉网速挺快的，也不贵，正好推荐给你们用用</p><h3 id="Clash"><a href="#Clash" class="headerlink" title="Clash"></a>Clash</h3><p>​网址直接搜 营养快线.net  这个域名是不是很骚，不要多想哈某些人</p><p><img src="https://cdn.zenless.top/gh/zhonghanlu/PicGo/img/image-20220816144108352.png" alt="image-20220816144108352"></p><p>进入网站进行注册即可，里面有很多种类型可以选择</p><p><img src="https://cdn.zenless.top/gh/zhonghanlu/PicGo/img/image-20220816144208611.png" alt="image-20220816144208611"></p><p>那个一个月13.33的比较划算，我一想我每天除了逛逛P站，github，也就没啥了，一个月用不了太多，也就没选择他了，我选了那个27￥100G无限用的那个差不多够我用几个月了。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>​他那个有个使用文档，可以看看，下载软件时，需要注意的，建议用这个地址 <a href="https://ghproxy.com/%E5%8A%A0%E9%80%9F">https://ghproxy.com/加速</a></p><p><img src="https://cdn.zenless.top/gh/zhonghanlu/PicGo/img/image-20220816144606460.png" alt="image-20220816144606460"></p><p>要不然你会像我一样，一直下载失败</p><p><img src="https://cdn.zenless.top/gh/zhonghanlu/PicGo/img/image-20220816144644433.png" alt="image-20220816144644433"></p><p>我还特意从我朋友那要的安装包整的</p><p>​至此基本上就OK了，下载完成之后直接就可以在软件里配置即可，可以选择地区啥的</p><p>直接上图</p><p><img src="https://cdn.zenless.top/gh/zhonghanlu/PicGo/img/image-20220816144759368.png" alt="image-20220816144759368"></p><p>直接在软件主页就可以开启</p><p><img src="https://cdn.zenless.top/gh/zhonghanlu/PicGo/img/image-20220816144823563.png" alt="image-20220816144823563"></p><p>直接让你的这台电脑全部翻墙，嘎嘎爽</p><p>我直接一脚把setVPN踢飞，垃圾</p><p><img src="https://cdn.zenless.top/gh/zhonghanlu/PicGo/img/image-20220816144902355.png" alt="image-20220816144902355"></p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>这个玩意还支持tg，甚至会给你提供个账号</p><p><img src="https://cdn.zenless.top/gh/zhonghanlu/PicGo/img/image-20220816144958084.png" alt="image-20220816144958084"></p><p>还可以在手机上直连哦</p><p>安卓端直接下载即可，iPhone端的需要小火箭，我也是直接上地址</p><p><a href="https://apps.apple.com/app/id932747118">https://apps.apple.com/app/id932747118</a></p><p>自行摸索吧，很简单的这个玩意。</p><h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><p><a href="https://ikuuu.ltd/user#">https://ikuuu.ltd/user#</a></p><p>这个地址是我朋友的一个vpn，看域名我觉得应该叫做ikunVPN</p><p><img src="https://cdn.zenless.top/gh/zhonghanlu/PicGo/img/image-20220816145333417.png" alt="image-20220816145333417"></p><p>这个比Clash便宜一点，速度还可以，都可以选择。</p><p>都可以选择</p><p>结束。</p>]]></content>
      
      
      <categories>
          
          <category> VPN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VPN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>My hexo was born</title>
      <link href="/archives/d6bc5d23.html"/>
      <url>/archives/d6bc5d23.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="初衷"><a href="#初衷" class="headerlink" title="初衷"></a>初衷</h3><p>​一直想拥有自己一个博客，为了这个博客我甚至还在慕课上特意学了一丢丢前端，只可惜实在学不下去。最终听从公司大哥的意见直接使用模板建站吧，哈哈哈哈，最终还是倒在了懒。这一篇是这个博客的第一篇文章，记录下建站过程</p><h3 id="博客选型"><a href="#博客选型" class="headerlink" title="博客选型"></a>博客选型</h3><p>​刚开始在做博客选型时，就直接想着硬着头皮租个服务器，前后端全部干，一个人完完全全定制出一个专属的博客，但是倒在了懒的上面，我不想动，我又想要，所以你动吧</p><p><img src="https://cdn.zenless.top/gh/zhonghanlu/PicGo/img/image-20220815132409288.png" alt="image-20220815132409288"></p><p>​最终考虑到了模板博客上面，看了眼我们公司大哥的一个博客其实也不错，就更加下定决心考虑模板博客了（我们公司大哥的博客在友链里面）</p><h3 id="实际技术知识"><a href="#实际技术知识" class="headerlink" title="实际技术知识"></a>实际技术知识</h3><p>​到了最关键的地方，看完我这篇博客你能学会什么呢？其实内容还是很多的，我大概列举下了以下几点</p><ul><li><p>Hexo的基础使用</p></li><li><p>GitHub的pages的使用</p></li><li><p>Github中的CI——Actions</p></li><li><p>Github最贴切的CI——Travis CI</p></li><li><p>Github做图床</p></li><li><p>将网站进行百度SEO</p></li><li><p>网站进行双部署，CDN加速</p></li><li><p>themes中butterfly的使用</p></li><li><p>域名的使用等…..</p><p>此处不一一列举了</p></li></ul><h3 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h3><h4 id="第一步安装Hexo"><a href="#第一步安装Hexo" class="headerlink" title="第一步安装Hexo"></a>第一步安装Hexo</h4><p>安装Hexo的前提为已经将Hexo和nodejs安装完成了</p><p>创个myblog进行下载Hexo</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>用<code>hexo -v</code>查看一下版本</p><p>至此就全部安装完了。</p><p>接下来初始化一下hexo</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init myblog</span><br></pre></td></tr></table></figure><p>这个myblog可以自己取什么名字都行，然后</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd myblog <span class="comment">//进入这个myblog文件夹</span></span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>新建完成后，指定文件夹目录下有：</p><ul><li>node_modules: 依赖包</li><li>public：存放生成的页面</li><li>scaffolds：生成文章的一些模板</li><li>source：用来存放你的文章</li><li>themes：主题</li><li>** _config.yml: 博客的配置文件**</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean <span class="comment">//清楚缓存等   有cdn时需要将cdn的缓存清了</span></span><br><span class="line">hexo g  <span class="comment">//会生成js html等</span></span><br><span class="line">hexo server <span class="comment">//启动服务</span></span><br></pre></td></tr></table></figure><p>大概长这样：</p><p><img src="https://cdn.zenless.top/gh/zhonghanlu/PicGo/img/image-20220815134238132.png" alt="image-20220815134238132"></p><p>至此安装完成！！！ <em>★,°</em>:.☆(￣▽￣)&#x2F;$:<em>.°★</em> 。</p><h4 id="配置Github"><a href="#配置Github" class="headerlink" title="配置Github"></a>配置Github</h4><p>登上自己的同性交友网站，进行创建仓库，此处创建仓库时，建议仓库名和github的名字一致，方便后续的gitpages访问（其实这一块，我第一次是一摸一样的整，但是没成功，于是乎我又换种方式整了）</p><p><img src="https://cdn.zenless.top/gh/zhonghanlu/PicGo/img/image-20220815134614152.png" alt="image-20220815134614152"></p><p>创建完仓库github这部分差不多结束了，后面就牵扯到了提交问题</p><p>我这一块的处理是将生成的静态页面放在仓库的gh-pages分支上的，例如</p><p><img src="https://cdn.zenless.top/gh/zhonghanlu/PicGo/img/image-20220815135029638.png" alt="image-20220815135029638"></p><p>源码是放在master上的</p><p><img src="https://cdn.zenless.top/gh/zhonghanlu/PicGo/img/image-20220815135103149.png" alt="image-20220815135103149"></p><p>这是上传成功的一个大致模板样子，还需要再仓库的setting中设置下pages的分支选择</p><p><img src="https://cdn.zenless.top/gh/zhonghanlu/PicGo/img/image-20220815135245042.png" alt="image-20220815135245042"></p><p>设置完此分支基本上就大功告成了。有点需要注意的是，我访问github使用ssh密钥方式访问的，如过使用https访问的话需要进行配置token，这个token也很好找，在头像下面有个setting进入随机会有有个devpl…啥的，进去就能看见token的获取，名字随便填，生成完之后需要将token保存下来，此token只会显示这一次。仓库的秘钥设置下，名字记住便于后面Actions的自动部署。</p><p><img src="https://cdn.zenless.top/gh/zhonghanlu/PicGo/img/image-20220815135602133.png" alt="image-20220815135602133"></p><h4 id="将hexo部署到GitHub"><a href="#将hexo部署到GitHub" class="headerlink" title="将hexo部署到GitHub"></a>将hexo部署到GitHub</h4><p>​准备就绪，就可以将hexo部署到GitHub上了</p><p>我们就可以将hexo和GitHub关联起来，也就是将hexo生成的文章部署到GitHub上，打开站点配置文件 <code>_config.yml</code>，翻到最后，修改为</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy</span>:</span><br><span class="line">  - <span class="attr">type</span>: <span class="string">&#x27;git&#x27;</span></span><br><span class="line">    <span class="attr">repo</span>: git@github.<span class="property">com</span>:zhonghanlu/myblog.<span class="property">git</span></span><br><span class="line">    <span class="attr">branch</span>: gh-pages</span><br><span class="line">  - <span class="attr">type</span>: baidu_url_submitter</span><br></pre></td></tr></table></figure><p>先安装deploy-git ，也就是部署的命令,这样你才能用命令部署到GitHub。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>然后</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure><p>其中 <code>hexo clean</code>清除了你之前生成的东西，也可以不加。<br> <code>hexo generate</code> 顾名思义，生成静态文章，可以用 <code>hexo g</code>缩写<br> <code>hexo deploy</code> 部署文章，可以用<code>hexo d</code>缩写</p><p>成功就像git正常push一样，没报错就ok了，如果报错了基本上就是github的基础提交问题</p><p>过一会儿就可以在<code>http://yourname.github.io</code> 这个网站看到你的博客了！！</p><h4 id="CI"><a href="#CI" class="headerlink" title="CI"></a>CI</h4><p>​将hexo c &amp;&amp; hexo g &amp;&amp; hexo s &amp;&amp; hexo d &amp;&amp; gulp 进行自动化部署</p><p>由于提交一次，推送一次过于麻烦，有自动化的工具为啥不用嘞？</p><p>所以我在这儿选了两种自动化的方式，一种是Travis CI（这个玩意贼鸡儿狗，贼恶心，我哐哐配置好了，各种各样的原因，我都解决了，最后跟我说收费了，就只有1000积分，一次五分，wqnmd），我选择免费因为我是白嫖党</p><p><img src="https://cdn.zenless.top/gh/zhonghanlu/PicGo/img/image-20220815140531257.png" alt="image-20220815140531257"></p><p>第二种方式就是Github Actions  力荐，这个真的贼好用</p><p>就是这个小玩意</p><p><img src="https://cdn.zenless.top/gh/zhonghanlu/PicGo/img/image-20220815140655255.png" alt="image-20220815140655255"></p><p>这个小玩意咋用来？？</p><p>非常简单跟我来</p><p>首先在你文件的 .github文件夹下建一个workflows文件夹，注意一定要正确无误，这个yml的名字就随便取一下吧</p><p><img src="https://cdn.zenless.top/gh/zhonghanlu/PicGo/img/image-20220815140828012.png" alt="image-20220815140828012"></p><p><img src="https://cdn.zenless.top/gh/zhonghanlu/PicGo/img/image-20220815140847924.png" alt="image-20220815140847924"></p><p>文件内容大致如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">HEXO</span> <span class="string">CI</span></span><br><span class="line"> </span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line"> </span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">strategy:</span></span><br><span class="line">      <span class="attr">matrix:</span></span><br><span class="line">        <span class="attr">node-version:</span> [<span class="number">14.</span><span class="string">x</span>]</span><br><span class="line"> </span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v1</span></span><br><span class="line"> </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Use</span> <span class="string">Node.js</span> <span class="string">$&#123;&#123;</span> <span class="string">matrix.node-version</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/setup-node@v1</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">node-version:</span> <span class="string">$&#123;&#123;</span> <span class="string">matrix.node-version</span> <span class="string">&#125;&#125;</span></span><br><span class="line"> </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Configuration</span> <span class="string">environment</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="attr">HEXO_DEPLOY_PRI:</span> <span class="string">$&#123;&#123;secrets.HEXO_DEPLOY_PRI&#125;&#125;</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          mkdir -p ~/.ssh/</span></span><br><span class="line"><span class="string">          echo &quot;$HEXO_DEPLOY_PRI&quot; &gt; ~/.ssh/id_rsa</span></span><br><span class="line"><span class="string">          chmod 600 ~/.ssh/id_rsa</span></span><br><span class="line"><span class="string">          ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts</span></span><br><span class="line"><span class="string">          git config --global user.name &quot;zhonghanlu&quot;</span></span><br><span class="line"><span class="string">          git config --global user.email &quot;1420865757@qq.com&quot;</span></span><br><span class="line"><span class="string"></span>      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">dependencies</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          npm i -g hexo-cli</span></span><br><span class="line"><span class="string">          npm i</span></span><br><span class="line"><span class="string"></span>      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">hexo</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">          <span class="string">hexo</span> <span class="string">clean</span> <span class="string">&amp;&amp;</span> <span class="string">hexo</span> <span class="string">generate</span> <span class="string">&amp;&amp;</span> <span class="string">hexo</span> <span class="string">deploy</span></span><br></pre></td></tr></table></figure><p>至此，GitHub 的Actions就完成了，推送一次看看，在Actions中就可以查看到，fail了会发邮件给你的哦</p><p>成功了：</p><p><img src="https://cdn.zenless.top/gh/zhonghanlu/PicGo/img/image-20220815141131279.png" alt="image-20220815141131279"></p><p>失败了：</p><p><img src="https://cdn.zenless.top/gh/zhonghanlu/PicGo/img/image-20220815141205531.png" alt="image-20220815141205531"></p><p>其实工作原理很简单：就是监听你的提交和你的那个workflows文件中的yml文件进行处理的，我这一块还加入了github的pages一个部署</p><p>Travis CI的原理也是很简单：就多了一部的GitHub的授权问题</p><h4 id="GitHub图床"><a href="#GitHub图床" class="headerlink" title="GitHub图床"></a>GitHub图床</h4><p>​如果网站中的图片全是网络上的资源，网站会很慢很慢，或者是本地资源也会很慢，甚至可能丢失，所以我这一块采用图床处理。网络上的图床有很多</p><p><img src="https://cdn.zenless.top/gh/zhonghanlu/PicGo/img/image-20220815141722922.png" alt="image-20220815141722922"></p><p>我这一块采用同行交友网站，不要问我为什么，因为他免费！！！</p><p>具体操作就是创建一个GitHub创建一个空的仓库</p><p>然后在GitHub上下载那个picgo这个rela..包，进行安装即可，安装完成进行配置下github就可以了比如</p><p>这儿的token就是上面申请的token</p><p><img src="https://cdn.zenless.top/gh/zhonghanlu/PicGo/img/image-20220815141939488.png" alt="image-20220815141939488"></p><p>然后在typora中进行设置图像设置   文件-》偏好设置-》图像</p><p><img src="https://cdn.zenless.top/gh/zhonghanlu/PicGo/img/image-20220815142044290.png" alt="image-20220815142044290"></p><p>然后就可以进行上传测试了，上传成功后，仓库内也会产生一个对应的照片，就相当于一个文件存储功能，但是这个文件大小有上限（能用，就是有点小），像极了你女朋友说你的样子</p><p><img src="https://cdn.zenless.top/gh/zhonghanlu/PicGo/img/image-20220815142238733.png" alt="image-20220815142238733"></p><p>此处的加速使用的是国内某大佬映射过去的地址，之前的地址被DNS玷污了，唉多好的一个被玷污了，真可恶，我没赶上</p><h4 id="网站进行百度SEO"><a href="#网站进行百度SEO" class="headerlink" title="网站进行百度SEO"></a>网站进行百度SEO</h4><p>​百度的seo，说的简单点就是能让百度搜到我们的网站，其实就是让百度收录下我们的网站，非常慢非常慢，有人就喜欢非常慢，我在某种程度上也是很慢</p><p>首先查看网站收录情况 &#96;site:你的网站</p><p>安装 sitemap</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-baidu-sitemap --save</span><br></pre></td></tr></table></figure><p>根目录_config.yaml添加如下的配置（注意每行的空格）生成对应xml文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sitemap</span></span><br><span class="line"><span class="attr">sitemap:</span></span><br><span class="line"> <span class="attr">path:</span> <span class="string">sitemap.xml</span></span><br><span class="line"><span class="attr">baidusitemap:</span></span><br><span class="line"> <span class="attr">path:</span> <span class="string">baidusitemap.xml</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">url:</span> <span class="string">https://zhonghanlu.club/</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">archives/:abbrlink.html</span></span><br><span class="line"><span class="attr">abbrlink:</span></span><br><span class="line"> <span class="attr">alg:</span> <span class="string">crc32</span>  <span class="comment"># 算法：crc16(default) and crc32</span></span><br><span class="line"> <span class="attr">rep:</span> <span class="string">hex</span>   <span class="comment"># 进制：dec(default) and hex</span></span><br></pre></td></tr></table></figure><p>我这一块顺带生成了那个页面持久化，好像需要装插件，但我忘记了；就想好像需要戴套，但我忘记了</p><p>博客根目录中的 source 文件夹下，添加蜘蛛协议 “robots.txt” 的文件，内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">User-agent:</span> <span class="string">*</span></span><br><span class="line"><span class="attr">Allow:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">Allow:</span> <span class="string">/categories/</span></span><br><span class="line"><span class="attr">Allow:</span> <span class="string">/tags/</span></span><br><span class="line"><span class="attr">Allow:</span> <span class="string">/archives/</span></span><br><span class="line"><span class="attr">Allow:</span> <span class="string">/about/</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Disallow:</span> <span class="string">/vendors/</span></span><br><span class="line"><span class="attr">Disallow:</span> <span class="string">/js/</span></span><br><span class="line"><span class="attr">Disallow:</span> <span class="string">/css/</span></span><br><span class="line"><span class="attr">Disallow:</span> <span class="string">/fonts/</span></span><br><span class="line"><span class="attr">Disallow:</span> <span class="string">/vendors/</span></span><br><span class="line"><span class="attr">Disallow:</span> <span class="string">/fancybox/</span></span><br><span class="line"></span><br><span class="line"><span class="string">记得替换成你的域名</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Sitemap:</span> <span class="string">http://域名/sitemap.xml</span></span><br><span class="line"><span class="attr">Sitemap:</span> <span class="string">http://域名/baidusitemap.xml</span></span><br></pre></td></tr></table></figure><p>主动推送</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-baidu-url-submit --save</span><br></pre></td></tr></table></figure><p>_config.yaml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">baidu_url_submit:</span></span><br><span class="line">  <span class="attr">count:</span> <span class="number">100</span> <span class="comment"># 提交最新的一个链接</span></span><br><span class="line">  <span class="attr">host:</span>  <span class="string">&#x27;&#x27;</span> <span class="comment"># 在百度站长平台中注册的域名</span></span><br><span class="line">  <span class="attr">token:</span> <span class="string">&#x27;&#x27;</span> <span class="comment"># 请注意这是您的秘钥</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">baidu_urls.txt</span> <span class="comment"># 文本文档的地址，新链接会保存在此文本文档里</span></span><br></pre></td></tr></table></figure><p>域名和秘钥可以在站长工具平台的连接提交中的接口调用地址中找到，即对应host与token后面的字段。</p><p><img src="https://cdn.zenless.top/gh/zhonghanlu/PicGo/img/image-20220815143553722.png" alt="image-20220815143553722"></p><p>修改deploy</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">&#x27;git&#x27;</span></span><br><span class="line">    <span class="attr">repo:</span> <span class="string">git@github.com:zhonghanlu/myblog.git</span></span><br><span class="line">    <span class="attr">branch:</span> <span class="string">gh-pages</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">baidu_url_submitter</span></span><br></pre></td></tr></table></figure><p>紧接着就是百度官网的添加收录了，此处不过多赘诉</p><h4 id="双部署，CDN加速"><a href="#双部署，CDN加速" class="headerlink" title="双部署，CDN加速"></a>双部署，CDN加速</h4><p>​双部署，为啥需要双部署呢，因为我们整个站是访问github，github这个访问速度有目共睹的啊，贼鸡儿慢</p><p>所以我们需要再次挂载到本国的，coding，再加上好招云进行免费的CDN加速，再加上gulp进行静态页面压缩，你就说这一套下来，我们国人访问的速度快不快就完事了。但是这一部分我没有做全，我此处暂且不做笔记了，大概的思路如此，我这可以提供个gulp的js文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">&#x27;gulp&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> minifycss = <span class="built_in">require</span>(<span class="string">&#x27;gulp-minify-css&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> uglify = <span class="built_in">require</span>(<span class="string">&#x27;gulp-uglify&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> htmlmin = <span class="built_in">require</span>(<span class="string">&#x27;gulp-htmlmin&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> htmlclean = <span class="built_in">require</span>(<span class="string">&#x27;gulp-htmlclean&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> imagemin = <span class="built_in">require</span>(<span class="string">&#x27;gulp-imagemin&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> babel = <span class="built_in">require</span>(<span class="string">&#x27;gulp-babel&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩css文件</span></span><br><span class="line">gulp.<span class="title function_">task</span>(<span class="string">&#x27;minify-css&#x27;</span>, <span class="keyword">function</span> (<span class="params">done</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.<span class="title function_">src</span>(<span class="string">&#x27;./public/**/*.css&#x27;</span>)</span><br><span class="line">        .<span class="title function_">pipe</span>(<span class="title function_">minifycss</span>())</span><br><span class="line">        .<span class="title function_">pipe</span>(gulp.<span class="title function_">dest</span>(<span class="string">&#x27;./public&#x27;</span>));</span><br><span class="line">    <span class="title function_">done</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩html文件</span></span><br><span class="line">gulp.<span class="title function_">task</span>(<span class="string">&#x27;minify-html&#x27;</span>, <span class="keyword">function</span> (<span class="params">done</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.<span class="title function_">src</span>(<span class="string">&#x27;./public/**/*.html&#x27;</span>)</span><br><span class="line">        .<span class="title function_">pipe</span>(<span class="title function_">htmlclean</span>())</span><br><span class="line">        .<span class="title function_">pipe</span>(<span class="title function_">htmlmin</span>(&#123;</span><br><span class="line">            <span class="attr">removeComments</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">minifyJS</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">minifyCSS</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">minifyURLs</span>: <span class="literal">true</span>,</span><br><span class="line">        &#125;))</span><br><span class="line">        .<span class="title function_">pipe</span>(gulp.<span class="title function_">dest</span>(<span class="string">&#x27;./public&#x27;</span>));</span><br><span class="line">    <span class="title function_">done</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩js文件</span></span><br><span class="line">gulp.<span class="title function_">task</span>(<span class="string">&#x27;minify-js&#x27;</span>, <span class="keyword">function</span> (<span class="params">done</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.<span class="title function_">src</span>([<span class="string">&#x27;./public/**/*.js&#x27;</span>, <span class="string">&#x27;!./public/**/*.min.js&#x27;</span>])</span><br><span class="line">        .<span class="title function_">pipe</span>(<span class="title function_">babel</span>(&#123;</span><br><span class="line">            <span class="comment">//将ES6代码转译为可执行的JS代码</span></span><br><span class="line">            <span class="attr">presets</span>: [<span class="string">&#x27;es2015&#x27;</span>] <span class="comment">// es5检查机制</span></span><br><span class="line">        &#125;))</span><br><span class="line">        .<span class="title function_">pipe</span>(<span class="title function_">uglify</span>())</span><br><span class="line">        .<span class="title function_">pipe</span>(gulp.<span class="title function_">dest</span>(<span class="string">&#x27;./public&#x27;</span>));</span><br><span class="line">    <span class="title function_">done</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩 public/images 目录内图片(Version&gt;3)</span></span><br><span class="line">gulp.<span class="title function_">task</span>(<span class="string">&#x27;minify-images&#x27;</span>, <span class="keyword">function</span> (<span class="params">done</span>) &#123;</span><br><span class="line">    gulp.<span class="title function_">src</span>(<span class="string">&#x27;./public/images/**/*.*&#x27;</span>)</span><br><span class="line">        .<span class="title function_">pipe</span>(<span class="title function_">imagemin</span>([</span><br><span class="line">            imagemin.<span class="title function_">gifsicle</span>(&#123;<span class="attr">interlaced</span>: <span class="literal">true</span>&#125;),</span><br><span class="line">            imagemin.<span class="title function_">jpegtran</span>(&#123;<span class="attr">progressive</span>: <span class="literal">true</span>&#125;),</span><br><span class="line">            imagemin.<span class="title function_">optipng</span>(&#123;<span class="attr">optimizationLevel</span>: <span class="number">5</span>&#125;),</span><br><span class="line">            imagemin.<span class="title function_">svgo</span>(&#123;</span><br><span class="line">                <span class="attr">plugins</span>: [</span><br><span class="line">                    &#123;<span class="attr">removeViewBox</span>: <span class="literal">true</span>&#125;,</span><br><span class="line">                    &#123;<span class="attr">cleanupIDs</span>: <span class="literal">false</span>&#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;)</span><br><span class="line">        ]))</span><br><span class="line">        .<span class="title function_">pipe</span>(gulp.<span class="title function_">dest</span>(<span class="string">&#x27;./public/images&#x27;</span>));</span><br><span class="line">    <span class="title function_">done</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.0以后的写法</span></span><br><span class="line"><span class="comment">// 执行 gulp 命令时执行的任务</span></span><br><span class="line">gulp.<span class="title function_">task</span>(<span class="string">&#x27;default&#x27;</span>, gulp.<span class="title function_">series</span>(gulp.<span class="title function_">parallel</span>(<span class="string">&#x27;minify-html&#x27;</span>, <span class="string">&#x27;minify-css&#x27;</span>, <span class="string">&#x27;minify-js&#x27;</span>, <span class="string">&#x27;minify-images&#x27;</span>)), <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;----------gulp Finished----------&quot;</span>);</span><br><span class="line">    <span class="comment">// Do something after a, b, and c are finished.</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="butterfly的使用"><a href="#butterfly的使用" class="headerlink" title="butterfly的使用"></a>butterfly的使用</h4><p>这个主题配置简单的很，直接github上面搜，他的readme文档上讲的非常清楚，万变不离一，慢慢摸索。</p><p>一个小提示，万物皆是Markdown，不会的操作啥的直接点击右边联系我，或者评论都可以帮助你解决</p><h4 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h4><p>域名需要先买个，腾讯云的.com.club等，可以整个.org的域名更专业点。我的友链那个我公司大哥的域名就是.org，去年7八月份国内就取消了org的域名购买，所以只能翻墙了，亲，翻墙不仅能看p站还能购物哦</p><p>配置嘎嘎简单</p><p>我这直接用腾旭云演示了，上图：</p><p><img src="https://cdn.zenless.top/gh/zhonghanlu/PicGo/img/image-20220815145545439.png" alt="image-20220815145545439"></p><p>github配置下自己的域名即可：</p><p><img src="https://cdn.zenless.top/gh/zhonghanlu/PicGo/img/image-20220815145700099.png" alt="image-20220815145700099"></p><p>如果配置完这些内容生成了CNAME文件则不需要手动进行创建，如果没有，则需要在source目录进行手动创建CNAME文件里面填入自己的域名</p><p><img src="https://cdn.zenless.top/gh/zhonghanlu/PicGo/img/image-20220815145833076.png" alt="image-20220815145833076"></p><p>在_config.yml文件中进行配置为自己的域名</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">url:</span> <span class="string">https://zhonghanlu.club/</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/</span></span><br></pre></td></tr></table></figure><p>配置完即可！！！</p><p>目前就这些就可以愉快的编写博客啦！！！</p><p>写的很匆忙，欢迎指正补充，评论区见。</p><p>没备案嗷，谨慎操作嗷！！！</p><p><img src="https://cdn.zenless.top/gh/zhonghanlu/PicGo/img/image-20220815150100000.png" alt="image-20220815150100000"></p>]]></content>
      
      
      <categories>
          
          <category> 建站 </category>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HEXO </tag>
            
            <tag> CI </tag>
            
            <tag> SEO </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
